[[{"l":"ASP.NET Core Reimagined with htmx Book","p":["Have questions or feedback about the book? My email is cwoodruff@live.com.","For the source code for the book, visit the book's GitHub repo -- htmx-razor-workshop","To find translations, please check out the Translations page."]}],[{"l":"Dedication"}],[{"l":"Epigraph"}],[{"l":"Acknowledgments","p":["This is a basic page, with only a title and some text content."]}],[{"l":"Forward","p":["This is a basic page, with only a title and some text content."]}],[{"l":"Preface","p":["This is a basic page, with only a title and some text content."]}],[{"l":"Translations","p":["Language","Author","Notes","URL","Chinese","Spanish","French","Japanese","Swedish"]}],[{"l":"1"},{"l":"Why htmx with ASP.NET Core 9 Razor Pages?","p":["Web development has evolved significantly over the past decade, shifting from server-rendered applications to JavaScript-heavy frontends that rely on client-side frameworks like React, Angular, and Vue. However, these solutions often introduce excessive complexity, forcing developers to juggle state management, bundlers, and frontend dependencies.","With the rise of htmx, many developers are rediscovering the power of server-side rendering while maintaining dynamic interactivity. htmx enhances HTML, allowing it to handle interactions that traditionally require JavaScript, offering a more straightforward way to create fast, interactive, and maintainable web applications. Unlike frontend-heavy frameworks, which offload rendering and logic to the client, htmx enables a seamless experience by keeping the logic on the server and sending only the necessary updates to the client. This means developers can build highly interactive applications without the overhead of managing complex client-side code.","If you're an ASP.NET Core developer working with Razor Pages, htmx presents an efficient alternative to client-side frameworks. It enables dynamic updates with minimal JavaScript, and integrating it into your ASP.NET Core 9 Razor Pages applications is a straightforward process. This book will guide you through from basic concepts to advanced interactivity, ensuring that by the end, you'll be comfortable building fully interactive, server-driven applications that remain performant and scalable without relying on a heavy frontend framework."]},{"l":"The Power of Simplicity in Web Development","p":["One of the biggest challenges modern developers face is managing complexity. Single-page applications (SPAs) have gained popularity due to their ability to provide smooth, interactive user experiences. However, these applications often come at a cost—higher development complexity, performance bottlenecks, and increased maintenance burdens. The need for APIs, state management, and extensive client-side JavaScript can make projects challenging to scale and debug.","htmx challenges this paradigm by offering a return to simplicity. Instead of shifting rendering responsibilities to the client, htmx keeps rendering on the server and uses lightweight AJAX requests to update specific parts of the page. This approach reduces unnecessary JavaScript, improves performance, and makes applications easier to develop and maintain."]},{"l":"What is htmx?","p":["htmx is a lightweight JavaScript library that extends HTML's capabilities, allowing it to make HTTP requests and dynamically update the page without requiring JavaScript. Instead of writing JavaScript to handle AJAX interactions, developers can use htmx’s HTML attributes to perform tasks like sending HTTP requests, updating the DOM, and handling events.","For example, consider a simple interaction where a user clicks a button to load a message dynamically:","In this example, clicking the button sends an HTTP GET request to the /hello endpoint. The response from the server replaces the content inside the div id=message element, all without needing any JavaScript.","This declarative approach makes it incredibly easy to build dynamic applications while keeping HTML and server logic cleanly separated."]},{"l":"Why Use htmx with Razor Pages?","p":["Razor Pages already provides a structured, server-rendered development model, but traditional implementations often require full-page reloads or custom JavaScript for interactivity. By integrating htmx, developers can enhance their applications while reducing complexity, leading to a more efficient and effective development process.","A few key advantages of htmx include:","Eliminates JavaScript complexity– No need for frontend frameworks or extensive JavaScript.","Enhances performance– Updates only necessary parts of the page instead of reloading everything.","Simplifies backend logic– Keeps interactions on the server, making debugging easier.","Leverages server-side security– Keeps application state and logic on the backend rather than the client."]},{"l":"Real-World Use Cases","p":["htmx is particularly useful in scenarios where minimal JavaScript is preferred and seamless interactions are essential."]},{"l":"Form Submissions","p":["Forms are a fundamental part of most web applications, and htmx makes handling them straightforward. Instead of requiring JavaScript to process form submissions, htmx can handle the interaction declaratively:","On the server, the Razor Page handler processes the request and returns the response:","The result is dynamically updated without reloading the entire page, leading to a more seamless user experience."]},{"l":"Dynamic Content Loading","p":["Another common use case for htmx is dynamically loading content without a full-page refresh. For instance, a user might want to open a modal form without navigating to another page. Instead of using JavaScript to load content dynamically, htmx can handle it:","When the button is clicked, htmx fetches the modal content from the server and injects it into the designated container. This makes building interactive interfaces much simpler than manually manipulating the DOM with JavaScript."]},{"l":"Performance and Scalability Benefits","p":["By reducing unnecessary JavaScript execution, htmx significantly improves performance. Since interactions are managed on the server, applications benefit from:","Faster initial load times since there’s no need for heavy JavaScript frameworks.","Improved SEO since content is server-rendered and immediately available to search engines.","More maintainable code by keeping logic in Razor Pages rather than splitting it between frontend and backend.","Moreover, htmx can alleviate the burden of complex state synchronization between frontend and backend, reducing API load by only requesting and updating what’s necessary, rather than fetching full-page responses."]},{"l":"Conclusion","p":["htmx represents a shift back to the simplicity of server-rendered applications while maintaining interactivity. When combined with ASP.NET Core 9 Razor Pages, it provides an elegant way to build applications that are efficient, scalable, and easy to maintain. This book will explore how htmx can enhance your development workflow while keeping your applications lightweight and fast.","As we move forward, we will dive deeper into setting up a robust development environment and learn how to integrate htmx seamlessly into your projects."]}],[{"l":"2"},{"l":"Setting Up Your Development Environment","p":["The goal is to help you build a solid development environment for htmx in ASP.NET Core 9. This will ensure a smooth workflow and allow you to focus on building interactive web applications without unnecessary distractions. In this chapter, we will guide you through the process of installing .NET 9, setting up an ASP.NET Core Razor Pages project, adding htmx to the project, and configuring tools for an efficient development workflow."]},{"l":"Installing ASP.NET Core 9 and Required Tools","p":["The first step in setting up your environment is installing .NET 9. Microsoft provides an official .NET SDK that includes everything needed to build and run ASP.NET Core applications. You can download the latest SDK from the secure and official .NET website. Once installed, open a terminal or command prompt and verify the installation by running:","If the command returns a version number starting with 9., your installation was successful. Next, let’s create a new Razor Pages project to use with htmx. Run the following commands:","This command initializes a basic Razor Pages project and starts a development server at https://localhost:5001/. Now, we are ready to integrate htmx."]},{"l":"Adding htmx to an ASP.NET Core 9 Razor Pages Project","p":["To use htmx, you must include its JavaScript file in your project. The easiest way to do this is by linking to the htmx CDN inside your _Layout.cshtml file. Open Pages/Shared/_Layout.cshtml and add the following inside the head tag:","Alternatively, if you prefer to host the file locally, download htmx.min.js from the official htmx GitHub repo and place it inside the wwwroot/js/ folder. Then, update _Layout.cshtml to reference it locally:","To confirm that htmx is working correctly, create a simple button that triggers an AJAX request when clicked. Add the following to Pages/Index.cshtml:","Now, modify Pages/Index.cshtml.cs to handle the request and return a response:","Run your application and click the button. If \"Hello, htmx!\" appears in the #message div without a full page reload, congratulations! htmx is successfully integrated into your Razor Pages project."]},{"l":"Configuring a Robust Development Workflow","p":["A well-structured project is easier to maintain and allows for smooth development. Organizing Razor Pages into logical folders keeps things clean. Your project structure should look something like this:","Hot-reload is a valuable feature in ASP.NET Core that automatically applies changes without restarting the server. This is particularly useful when working with Razor Pages. To enable hot-reload, start your application using:","This command monitors file changes and refreshes the application automatically. Additionally, debugging htmx requests is straightforward using browser developer tools. Open your browser's developer console and inspect network requests to see how htmx interacts with your server.","When working with htmx, the HX-Request header helps differentiate between standard and htmx-triggered requests. You can check this in your backend code to return different responses depending on whether the request originated from htmx:","Version control is crucial for any project. To initialize a Git repository, navigate to your project directory and run:","For Razor Pages projects, a typical .gitignore file should exclude compiled binaries and user-specific files. Here's an example:"]},{"l":"Conclusion","p":["With your development environment set up to perfection, you are now fully prepared to embark on the journey of building interactive web applications with htmx and ASP.NET Core 9 Razor Pages. Having .NET installed, a Razor Pages project initialized, and htmx integrated, you are now ready to explore the world of dynamic, interactive applications. In the next chapter, we will delve into the core features of htmx and how to utilize them to create dynamic content updates in Razor Pages"]}],[{"l":"First Steps with htmx","p":["You can find the source examples for this chapter here.","The way we build web applications is changing. Client-side JavaScript frameworks dominate modern development, yet they often introduce complexity that many projects do not need. State management, bundlers, elaborate frontend tooling: these concerns consume development time and add maintenance burden. htmx takes a different path. It enhances HTML's native capabilities, allowing you to craft interactive experiences with minimal JavaScript. This chapter guides you through integrating htmx with ASP.NET Core Razor Pages to build dynamic web applications without the overhead of complex frontend frameworks.","By focusing on server-driven interactions, htmx makes it possible to create fluid user experiences while keeping your application logic where it belongs: on the server. It uses declarative attributes to handle AJAX requests, event-driven interactions, and form submissions. Your markup stays clean and understandable. When combined with Razor Pages, htmx offers a way to blend server-side rendering with targeted interactivity, making your applications efficient and maintainable.","This chapter takes you from fundamental principles to fully functional Razor Pages. You will learn to dynamically fetch, update, and submit content without full page reloads. We cover everything from using hx-get and hx-post for data retrieval and submission to debugging common issues and fine-tuning request behaviors. By the end, you will be ready to build interactive web applications that feel modern while remaining easy to maintain."]},{"l":"Adding htmx to Your Razor Pages Project","p":["Before writing any htmx code, you need to include the library in your project. The simplest approach is adding a script tag to your layout file.","Open Pages/Shared/_Layout.cshtml and add the htmx script before the closing /body tag:","Alternatively, you can download htmx and serve it locally:","With htmx loaded, every page in your application can use htmx attributes. No build step required. No npm packages to manage. Just one script tag and you are ready to go."]},{"l":"Understanding the Basics of htmx in Razor Pages","p":["htmx allows you to send AJAX requests using simple HTML attributes. The two most fundamental ones are:","hx-get: Makes an HTTP GET request to fetch content from the server","hx-post: Sends a POST request to submit data to the server","Here is a basic example:","When the button is clicked, htmx sends an asynchronous GET request to /Index?handler=Hello. The server processes the request and returns HTML. htmx then injects that HTML into the #message div. No page reload. No JavaScript to write. The interaction happens through HTML attributes alone."]},{"l":"The Handler Naming Convention","p":["In Razor Pages, the handler query parameter maps to methods in your PageModel. The naming convention follows this pattern: On{HttpMethod}{HandlerName}().","handler=Hello with a GET request calls OnGetHello()","handler=Submit with a POST request calls OnPostSubmit()","No handler parameter with GET calls OnGet()","This convention keeps your server-side code organized while giving htmx clear endpoints to call."]},{"l":"The Request-Response Cycle with htmx","p":["htmx works like a normal browser request but without a full-page reload. Here is how a typical request-response cycle flows:","User interacts with an element (clicks a button, types in an input, submits a form)","htmx sends an AJAX request to the specified endpoint","The Razor Page handler processes the request and returns partial HTML","htmx updates the target element with the returned HTML","This means you can build dynamic experiences while keeping your application logic centralized in your PageModel classes. The server remains in control. The client handles presentation."]},{"l":"Examining How Partial Updates Work","p":["Unlike traditional AJAX where you manually manipulate the DOM, htmx automatically swaps the response into a specified target. Two attributes control this behavior:","hx-target determines which element will be updated","hx-swap decides how the response is inserted","The hx-swap attribute accepts several values:","innerHTML(default): Replaces the target's inner content","outerHTML: Replaces the entire target element","beforebegin: Inserts before the target element","afterbegin: Inserts inside the target, before its first child","beforeend: Inserts inside the target, after its last child","afterend: Inserts after the target element","By returning only the relevant snippet from the server, you make updates feel instant and keep bandwidth usage low."]},{"l":"Creating Your First Interactive Razor Page","p":["Let us create a Razor Page that dynamically loads a message when a button is clicked.","Pages/Index.cshtml","Pages/Index.cshtml.cs","When you click the button, htmx calls OnGetMessage(), which returns a paragraph of HTML. htmx injects this into the #message div. The page does not reload. The URL does not change. Only the targeted element updates."]},{"l":"Understanding hx-trigger for Event-Driven Interactions","p":["By default, htmx triggers requests on click events for buttons and links, and on submit events for forms. You can customize this behavior with hx-trigger:","This input field triggers a search request when the user types. The trigger expression breaks down as follows:","keyup: Fire on keyup events","changed: Only fire if the value actually changed","delay:500ms: Wait 500 milliseconds after the last keyup before firing","This debouncing prevents flooding your server with requests on every keystroke. The user types, pauses briefly, and then the request fires. It feels responsive without being wasteful."]},{"l":"Implementing Dynamic Content Updates","p":["Let us modify our earlier example to display different content each time the button is clicked.","Pages/Index.cshtml.cs","Now each click returns a different message from the array. The Random.Shared property provides a thread-safe random instance that you can use across requests without creating new instances."]},{"l":"Handling Form Submissions with htmx","p":["Forms are where htmx truly shines. Traditional form submissions reload the entire page. With htmx, you submit data and update only what needs to change."]},{"l":"Setting Up Anti-Forgery Token Handling","p":["ASP.NET Core Razor Pages require anti-forgery tokens for POST requests. Before creating forms, configure htmx to include this token automatically.","Add this script to your _Layout.cshtml after the htmx script:","This event listener runs before every htmx request and adds the anti-forgery token to the request headers."]},{"l":"Using hx-post to Submit Forms","p":["With token handling configured, you can create forms that submit without page reloads:","Pages/Index.cshtml","Pages/Index.cshtml.cs","When the form submits, htmx sends a POST request to OnPostSubmit(). The handler validates the input and returns HTML that htmx injects into #result. The form stays on the page. The user sees immediate feedback."]},{"l":"Appending Responses Instead of Replacing","p":["Sometimes you want to add content rather than replace it. The hx-swap attribute with beforeend appends new responses:","Each submission adds a new list item without clearing previous entries. This pattern works well for todo lists, comment sections, or any accumulating content."]},{"l":"Form Validation with HTML5","p":["htmx respects standard HTML5 form validation. The browser validates fields before htmx sends the request:","The type=email attribute validates email format. The min and max attributes constrain the number range. The required attribute ensures fields are not empty. All of this happens in the browser before htmx sends anything to the server.","For complex validation logic, handle it server-side and return appropriate error messages in your HTML response."]},{"l":"Debugging and Observing htmx Requests","p":["When things do not work as expected, htmx provides several ways to investigate."]},{"l":"Inspecting Network Requests","p":["Your browser's developer tools show every htmx request in the Network tab. Filter by XHR or Fetch to see only AJAX requests. For each request, examine:","URL: Is htmx calling the correct endpoint?","Method: Is it GET or POST as expected?","Headers: Is the anti-forgery token present?","Response: What HTML is the server returning?","Status: Is the server returning 200, 400, 500?"]},{"l":"Common Errors and Solutions","p":["400 Bad Request on POST","This usually means the anti-forgery token is missing. Ensure you have @Html.AntiForgeryToken() in your form and the token handling script in your layout.","404 Not Found","The handler name in your URL does not match a method in your PageModel. Remember: handler=Submit maps to OnPostSubmit() for POST requests and OnGetSubmit() for GET requests.","Response Not Appearing","Check that your hx-target selector matches an element that exists on the page. Verify the element has the correct id attribute.","Incorrect Content-Type","Ensure your handler returns Content(..., text/html). Returning JSON or plain text may not render as expected."]},{"l":"Using htmx Events for Debugging","p":["htmx fires events throughout the request lifecycle. You can listen to these for debugging:","These event listeners help you trace exactly what htmx is doing and where problems occur."]},{"l":"Enabling htmx Logging","p":["For full debugging visibility, enable htmx's built-in logging:","This outputs every htmx event to the console, giving you complete visibility into the library's behavior."]},{"l":"Complete Working Example","p":["Here is a complete example that ties together everything from this chapter:","Pages/Index.cshtml","Pages/Index.cshtml.cs","This single page demonstrates dynamic content loading, live search with debouncing, and form submission. Each feature uses a few htmx attributes and a simple server-side handler. No JavaScript framework. No complex state management. Just HTML attributes and C# methods working together."]},{"l":"Summary","p":["This chapter introduced the fundamentals of htmx with ASP.NET Core Razor Pages:","Adding htmx to your project with a single script tag","Using hx-get and hx-post to make AJAX requests","Targeting elements with hx-target and controlling insertion with hx-swap","Customizing triggers with hx-trigger for event-driven interactions","Handling forms with proper anti-forgery token configuration","Using HTML5 validation for client-side form validation","Debugging with browser tools and htmx events","The pattern is consistent: add htmx attributes to your HTML, write a handler method that returns HTML, and let htmx handle the rest. Your server stays in control. Your markup stays readable. Your users get responsive interactions."]},{"l":"Preview of Next Chapter","p":["In the next chapter, we will explore more htmx capabilities including hx-push-url for updating the browser URL, hx-swap-oob for updating multiple elements with a single response, and additional trigger modifiers for fine-grained control over when requests fire."]}],[{"l":"Understanding htmx Commands","p":["Chapter 3 introduced the basics of htmx with hx-get, hx-post, hx-target, and hx-swap. You built simple interactions and learned how htmx sends requests and updates the DOM. Now it is time to go deeper. This chapter expands your command vocabulary with hx-put, hx-patch, hx-delete, and advanced targeting techniques. You will build complete CRUD operations, handle complex swap scenarios, and learn patterns that scale to real applications.","By the end of this chapter, you will understand what each command does and when to choose one over another. You will have working code for create, read, update, and delete operations. You will know how to update multiple page elements from a single response. These are the building blocks for the interactive dashboards, admin panels, and data-driven applications you will build in later chapters."]},{"l":"The Complete htmx Command Set","p":["Attribute","Create new resources, submit forms","DELETE","Each attribute takes a URL as its value. When the element is triggered (by default, on click for buttons and links, on submit for forms), htmx sends the corresponding HTTP request to that URL.","GET","htmx provides HTTP method attributes that map directly to RESTful operations:","HTTP Method","hx-delete","hx-get","hx-patch","hx-post","hx-put","Partially update an existing resource","PATCH","POST","PUT","Remove a resource","Replace an existing resource entirely","Retrieve and display data","Typical Use"]},{"l":"Building a Complete CRUD Example","p":["Theory only takes you so far. Let us build a working task list that demonstrates all five HTTP methods. This example will show you how htmx commands work together in a realistic scenario."]},{"l":"Project Setup","p":["Create a new Razor Pages project or add these files to an existing one. We will need a model, a page, and several partial views.","Models/TaskItem.cs","Services/TaskService.cs","For simplicity, we will use an in-memory store. In a real application, this would be a database.","Register the service in Program.cs:"]},{"l":"The Main Page","p":["Pages/Tasks.cshtml","Pages/Tasks.cshtml.cs"]},{"l":"Partial Views","p":["Pages/Shared/_TaskItem.cshtml","Pages/Shared/_TaskEditForm.cshtml"]},{"l":"Configuring Anti-Forgery Tokens for All Methods","p":["ASP.NET Core requires anti-forgery tokens for POST, PUT, PATCH, and DELETE requests. Add this script to your _Layout.cshtml:","For pages that use hx-delete, hx-put, or hx-patch outside of forms, include a hidden token somewhere on the page:"]},{"l":"Understanding Each Operation","p":["Let us examine what each htmx command does in this example.","CREATE with hx-post","When submitted, this form sends a POST request to OnPostCreate(). The handler creates a new task and returns the _TaskItem partial. The hx-swap=beforeend directive appends the new task to the end of the list rather than replacing the entire list.","The hx-on::after-request=this.reset() attribute clears the form after successful submission, ready for the next entry.","READ with hx-get","Clicking Edit sends a GET request to OnGetEdit(), which returns the edit form partial. The form loads into the modal div. This pattern separates the read operation (loading the form) from the update operation (submitting changes).","UPDATE with hx-put","The edit form uses PUT because we are replacing the entire task resource. The handler returns an updated _TaskItem partial, which replaces the old task element. Using outerHTML ensures the entire task div gets replaced, including its id attribute.","PARTIAL UPDATE with hx-patch","Toggling completion status is a partial update, so we use PATCH. We are not replacing the entire resource, just changing one property. The distinction between PUT and PATCH matters for API design clarity, even when both return the same partial view.","DELETE with hx-delete","The delete button sends a DELETE request and targets the task element itself. The handler returns empty content, so outerHTML swap effectively removes the element from the DOM. The hx-confirm attribute shows a browser confirmation dialog before sending the request."]},{"l":"Advanced Targeting with hx-target","p":["The hx-target attribute accepts CSS selectors, giving you precise control over where responses appear."]},{"l":"Targeting by ID","p":["The most common pattern targets elements by ID:"]},{"l":"Targeting Relative to the Element","p":["htmx provides special selectors for targeting elements relative to the trigger:","Available relative selectors:","this: The element that triggered the request","closest selector: The nearest ancestor matching the selector","next selector: The next element in the DOM matching the selector","previous selector: The previous element matching the selector","find selector: The first child element matching the selector"]},{"l":"Targeting the Document Body","p":["For full-page updates or navigation-like behavior:","This replaces the entire body content and updates the browser URL, simulating navigation without a full page reload."]},{"l":"Mastering hx-swap Options","p":["The hx-swap attribute controls how the response content gets inserted. Each option serves different use cases."]},{"l":"Swap Options Comparison"},{"l":"Swap Modifiers","p":["You can add modifiers to control swap timing and behavior:"]},{"l":"Out-of-Band Swaps","p":["Sometimes a single server action needs to update multiple unrelated parts of the page. Out-of-band (OOB) swaps solve this problem cleanly."]},{"l":"The Problem","p":["Consider a scenario where adding a task also needs to update a task count in the header. With standard htmx, you would need two separate requests. OOB swaps let you update both with one response."]},{"l":"The Solution","p":["Your server response includes additional elements marked with hx-swap-oob=true:","Updated OnPostCreate handler:","Or using a partial view that includes OOB elements:","Pages/Shared/_TaskItemWithCount.cshtml","The page needs a matching element:","When htmx receives the response, it:","Swaps the primary content (the new task) into the target","Finds any elements with hx-swap-oob=true","Swaps those elements into matching elements on the page by ID"]},{"l":"OOB Swap Modes","p":["You can specify how OOB elements should be swapped:"]},{"l":"Debugging htmx Applications","p":["When htmx requests do not behave as expected, you have several debugging options."]},{"l":"Enable Logging","p":["Add this to your page during development:","This outputs every htmx event to the browser console, showing you exactly what htmx is doing."]},{"l":"Listen to Specific Events","p":["For targeted debugging, listen to specific htmx events:"]},{"l":"Network Tab Inspection","p":["The browser's Network tab shows every htmx request. Check:","URL: Is the request going to the correct endpoint?","Method: Is it GET, POST, PUT, PATCH, or DELETE as expected?","Request Headers: Is the anti-forgery token present?","Request Body: For POST/PUT, is the form data correct?","Response Status: 200, 400, 404, 500?","Response Body: What HTML is the server returning?"]},{"l":"Common Issues and Solutions","p":["Problem: Request returns 400 Bad Request","Solution: The anti-forgery token is likely missing. Ensure @Html.AntiForgeryToken() is on the page and the token-forwarding script is in your layout.","Problem: Handler not found (404)","Solution: Verify the handler name matches your method. handler=Create needs OnPostCreate() for POST, OnGetCreate() for GET.","Problem: PUT/PATCH/DELETE returns 405 Method Not Allowed","Solution: ASP.NET Core needs handler methods named OnPut*, OnPatch*, OnDelete*. Verify spelling and that the method is public.","Problem: Response appears but in wrong location","Solution: Check your hx-target selector. Use browser dev tools to verify the target element exists and has the expected ID.","Problem: Element not removed after delete","Solution: Ensure you return empty content and use hx-swap=outerHTML so the element replaces itself with nothing."]},{"l":"Performance Considerations"},{"l":"Minimize Response Size","p":["Return only the HTML needed for the swap. Avoid returning full page layouts for partial updates:"]},{"l":"Use Appropriate HTTP Methods","p":["Match your HTTP method to the operation semantics:","GET for retrieving data (cacheable, safe)","POST for creating resources","PUT for full updates","PATCH for partial updates","DELETE for removal","Using the correct method helps with caching, browser behavior, and API clarity."]},{"l":"Debounce Rapid Triggers","p":["For inputs that fire on every keystroke, add a delay:","The request only fires 300ms after the user stops typing, preventing server overload."]},{"l":"Summary","p":["This chapter covered the complete htmx command set for building interactive Razor Pages applications:","hx-get retrieves data without page reloads","hx-post creates new resources and submits forms","hx-put replaces existing resources entirely","hx-patch partially updates resources","hx-delete removes resources","hx-target controls where responses appear using CSS selectors","hx-swap determines how responses are inserted into the DOM","Out-of-band swaps update multiple page elements from one response","You built a complete CRUD application demonstrating all five HTTP methods with proper anti-forgery protection. You learned advanced targeting with relative selectors and mastered swap options for different update scenarios."]},{"l":"Preview of Next Chapter","p":["In the next chapter, we will explore hx-trigger in depth. You will learn how to fire requests on custom events, combine multiple triggers, add conditions and modifiers, and create responsive interfaces that react to user behavior in sophisticated ways."]}],[{"l":"Mastering hx-get and hx-post","p":["The previous chapters introduced htmx commands and showed you how to build basic interactions. Now it is time to master the two commands you will use most often: hx-get and hx-post. These attributes handle the majority of web application interactions, from loading dynamic content to submitting forms and processing user input.","This chapter goes beyond the basics. You will learn how to construct dynamic URLs, include additional parameters with requests, handle file uploads, and manage server responses effectively. You will build real patterns: live search with debouncing, inline editing, bulk operations, and proper error handling. By the end, you will have the skills to build sophisticated server-driven interactions without writing JavaScript."]},{"l":"Fetching Dynamic Content with hx-get","p":["The hx-get attribute sends HTTP GET requests to your server and updates the page with the response. GET requests are ideal for retrieving data because they are cacheable, bookmarkable, and do not modify server state."]},{"l":"Basic Content Loading","p":["The simplest use of hx-get loads content when a user clicks a button:","The server handler returns HTML:","The partial view renders the user data:","Pages/Shared/_UserProfile.cshtml"]},{"l":"Live Search with Debouncing","p":["Search boxes that update as users type need careful handling. Without debouncing, every keystroke triggers a server request. The hx-trigger attribute with a delay prevents this:","The trigger expression breaks down as:","keyup: Fire on keyup events","changed: Only if the value actually changed","delay:300ms: Wait 300ms after the last keystroke","The server handler filters and returns results:","Pages/Shared/_UserSearchResults.cshtml"]},{"l":"Passing Parameters with hx-vals","p":["Sometimes you need to send additional data with a GET request beyond what is in the URL. The hx-vals attribute adds JSON-formatted values:","The handler receives these as parameters:"]},{"l":"Including Form Fields with hx-include","p":["When you need to include values from form fields outside the triggering element, use hx-include:","The hx-include selector can be:","An ID: #category-select","Multiple selectors: #category-select, #max-price","A CSS selector: .filter-input","closest form: Include all fields in the nearest ancestor form","this: Include the triggering element itself"]},{"l":"Caching GET Responses","p":["For data that does not change frequently, server-side caching reduces load:","The browser caches this response for 5 minutes, avoiding redundant server requests."]},{"l":"Submitting Data with hx-post","p":["The hx-post attribute sends HTTP POST requests, typically for creating resources or submitting forms. POST requests can modify server state and require anti-forgery protection in ASP.NET Core."]},{"l":"Setting Up Anti-Forgery Token Handling","p":["Before any POST examples will work, configure htmx to include anti-forgery tokens. Add this to your _Layout.cshtml:"]},{"l":"Basic Form Submission","p":["With token handling configured, forms submit without page reloads:","The handler processes the submission:"]},{"l":"Controlling Which Parameters Are Sent","p":["The hx-params attribute controls which form fields are included in the request:"]},{"l":"File Uploads","p":["File uploads require the hx-encoding attribute to set the correct content type:","The handler receives the file:"]},{"l":"Buttons Outside Forms","p":["Sometimes you need a button to POST data without being inside a form. Use hx-vals to send the data:"]},{"l":"Bulk Operations","p":["Admin interfaces often need to operate on multiple items at once. This pattern uses checkboxes with hx-include to send selected IDs:","Pages/Shared/_UserRow.cshtml","The handlers process the selected IDs:","Pages/Shared/_UserRows.cshtml"]},{"l":"Inline Editing","p":["Inline editing lets users modify data directly in a table without navigating to a separate page:","Pages/Shared/_ProductRow.cshtml","Pages/Shared/_ProductEditRow.cshtml","The handlers switch between view and edit modes:","The hx-include=closest tr on the Save button includes all input fields from the table row in the PUT request."]},{"l":"Error Handling","p":["Users need clear feedback when something goes wrong. Return appropriate HTTP status codes and error messages:","On the client side, you can handle errors with htmx events:"]},{"l":"Loading Indicators","p":["Users need visual feedback during requests. The hx-indicator attribute shows an element while the request is in progress:","Add CSS to hide indicators by default:"]},{"l":"Debugging htmx Requests","p":["When requests do not work as expected, use these debugging techniques:"]},{"l":"Browser Network Tab","p":["Open Developer Tools (F12) and go to the Network tab. Filter by XHR/Fetch to see htmx requests. Check:","Request URL and method","Request headers (look for RequestVerificationToken)","Request body (form data)","Response status code","Response body"]},{"l":"htmx Logging","p":["Enable verbose logging during development:"]},{"l":"Common Issues","p":["400 Bad Request","Usually a missing anti-forgery token. Ensure @Html.AntiForgeryToken() is present and the token-forwarding script is in your layout.","404 Not Found","The handler name does not match your method. handler=Submit requires OnPostSubmit() for POST requests.","Empty Response","The handler might be returning null or the wrong content type. Verify the handler returns Content(..., text/html) or Partial(...).","Response Not Updating Target","Check that the hx-target selector matches an element that exists. Verify the element has the correct id."]},{"l":"Summary","p":["This chapter covered hx-get and hx-post in depth:","hx-get retrieves data with GET requests, ideal for search, filtering, and loading content","hx-post submits data with POST requests, requiring anti-forgery token handling","hx-vals adds JSON data to requests","hx-include includes form fields from outside the triggering element","hx-params controls which form fields are sent","hx-encoding enables file uploads with multipart form data","hx-indicator shows loading feedback during requests","You built patterns for live search, bulk operations, inline editing, file uploads, and error handling. These patterns form the foundation for most web application interactions."]},{"l":"Preview of Next Chapter","p":["Chapter 6 explores hx-put, hx-patch, and hx-delete for RESTful update and delete operations. You will learn when to use each method, how to handle partial updates, and patterns for optimistic UI updates that make your application feel responsive."]}],[{"l":"Working with hx-put, hx-patch, and hx-delete","p":["Chapter 4 introduced all five HTTP methods with a basic CRUD example. Chapter 5 went deep on hx-get and hx-post. Now it is time to master the update and delete operations that make your applications feel truly interactive.","This chapter goes beyond the basics. You will learn when to choose PUT over PATCH, how to handle deletion with proper user confirmation, and patterns for optimistic updates that make your UI feel instant. You will build undo functionality, handle conflicts when multiple users edit the same data, and implement soft delete for recoverable removals. These are the patterns that separate toy examples from production applications."]},{"l":"Understanding PUT vs PATCH","p":["Both PUT and PATCH modify existing resources, but they serve different purposes.","PUT replaces a resource entirely. When you send a PUT request, you provide the complete new state of the resource. Any fields you omit are cleared or set to defaults. Use PUT when users are editing a complete form where all fields should be saved together.","PATCH modifies a resource partially. You send only the fields that changed. The server merges these changes with the existing data. Use PATCH for single-field updates, toggles, or when you want to minimize data transfer.","Here is how this distinction plays out in practice:","The HTML reflects this distinction:"]},{"l":"Anti-Forgery Tokens for PUT, PATCH, and DELETE","p":["ASP.NET Core requires anti-forgery tokens for all state-changing requests. This protection applies to PUT, PATCH, and DELETE just as it does to POST."]},{"l":"Layout Configuration","p":["Add this script to your _Layout.cshtml after the htmx script:"]},{"l":"Token Placement","p":["For forms, include the token inside the form:","For buttons outside forms, include a token somewhere on the page:","The event listener in the layout will find the token and add it to all htmx requests automatically."]},{"l":"Implementing Delete Operations","p":["Deletion requires careful handling. Users need confirmation before destructive actions, and the UI needs to reflect the removal immediately."]},{"l":"Basic Delete with Confirmation","p":["The hx-confirm attribute shows a browser confirmation dialog before sending the request:","The handler removes the item and returns empty content:","When htmx receives an empty response with hx-swap=outerHTML, it replaces the target element with nothing, effectively removing it from the page."]},{"l":"Why NoContent() Does Not Work for Removal","p":["You might expect return NoContent()(HTTP 204) to work for deletions, but htmx handles 204 responses differently. When htmx receives a 204 No Content response, it does not perform any swap operation. The target element remains unchanged.","Use NoContent() only when you do not want htmx to modify the DOM at all, such as for background operations or analytics tracking."]},{"l":"Delete with Feedback Message","p":["Sometimes you want to show a confirmation message where the deleted item was:","Add CSS to fade out the message:"]},{"l":"Soft Delete with Restore","p":["Production applications often use soft delete, marking records as inactive rather than removing them permanently. This allows users to restore accidentally deleted items."]},{"l":"The Model"},{"l":"The Partial Views","p":["Pages/Shared/_DocumentRow.cshtml"]},{"l":"The Handlers"},{"l":"CSS for Deleted State"},{"l":"Optimistic Updates","p":["Standard htmx requests wait for the server response before updating the UI. For fast operations, this works fine. But for operations with noticeable latency, users appreciate immediate feedback.","Optimistic updates show the expected result immediately, then correct if the server reports an error. This makes your application feel faster."]},{"l":"Toggle with Optimistic Update","p":["Here is a task completion toggle that updates instantly:","The hx-on:click attribute runs JavaScript immediately when clicked, toggling the visual state before the request completes. If the server returns successfully, the response replaces the element with the confirmed state. If the server returns an error, the response shows the original state."]},{"l":"Handling Optimistic Update Failures","p":["For more control over failure handling, use htmx events:"]},{"l":"Handling Conflicts","p":["When multiple users can edit the same data, conflicts arise. User A loads a record, User B modifies it, then User A tries to save their changes. Without conflict detection, User A would overwrite User B's changes."]},{"l":"Optimistic Concurrency with Row Version","p":["Add a version field to your model:","Include the version in your edit form:","The handler checks the version before saving:"]},{"l":"Batch Operations","p":["Sometimes you need to update or delete multiple items at once. Chapter 5 covered bulk operations with checkboxes. Here is the pattern applied to PUT and DELETE."]},{"l":"Batch Update","p":["The handler processes all selected items:"]},{"l":"Batch Delete"},{"l":"Error Handling for Update Operations","p":["Users need clear feedback when updates fail. Return appropriate HTTP status codes and error messages."]},{"l":"Validation Errors (400 Bad Request)"},{"l":"Not Found (404)"},{"l":"Server Error (500)"},{"l":"Client-Side Error Handling","p":["Handle errors globally with htmx events:"]},{"l":"Debugging PUT, PATCH, and DELETE","p":["When requests fail, use these debugging techniques."]},{"l":"Browser Network Tab","p":["Open Developer Tools (F12), go to the Network tab, and filter by XHR/Fetch. Check:","Request Method: Is it PUT, PATCH, or DELETE as expected?","Request Headers: Is RequestVerificationToken present?","Request Body: Are form fields being sent correctly?","Response Status: 200, 204, 400, 404, 409, 500?","Response Body: What HTML is returned?"]},{"l":"Common Issues","p":["400 Bad Request","The anti-forgery token is missing. Ensure @Html.AntiForgeryToken() is on the page and the token-forwarding script is in your layout.","404 Not Found","The handler name does not match your method. handler=Update with PUT requires OnPutUpdate().","405 Method Not Allowed","Your handler method is missing or named incorrectly. OnPut*, OnPatch*, and OnDelete* must be spelled exactly right and be public.","Element Not Removed After Delete","You may be returning NoContent()(204). Change to return Content(, text/html) to get a 200 response that htmx will process.","Update Does Not Appear","Check your hx-target selector. The element with that ID must exist on the page."]},{"l":"Summary","p":["This chapter covered advanced patterns for hx-put, hx-patch, and hx-delete:","PUT vs PATCH: Use PUT for complete replacements, PATCH for partial updates","Anti-forgery tokens: Required for all state-changing requests","Element removal: Return empty content with 200 status, not NoContent()","hx-confirm: Require user confirmation before destructive operations","Soft delete: Mark records as deleted while preserving data for recovery","Optimistic updates: Update UI immediately, correct on error","Conflict handling: Use row versions to detect concurrent modifications","Batch operations: Update or delete multiple items with one request","Error handling: Return appropriate status codes and error messages"]},{"l":"Preview of Next Chapter","p":["Chapter 7 explores hx-target and hx-swap in depth. You will learn advanced targeting with CSS selectors, multiple swap strategies, out-of-band updates for complex UI changes, and techniques for updating multiple page sections from a single response."]}],[{"l":"Working with hx-target and hx-swap","p":["Every htmx request updates something on the page. The question is: what gets updated and how? By default, htmx replaces the inner content of the element that triggered the request. That works for simple cases. But real applications need precision. You need to update a sidebar when a form submits. You need to append items to a list without clearing existing content. You need to remove elements entirely when users delete them.","The hx-target attribute controls where the response goes. The hx-swap attribute controls how the response is inserted. Together, they give you complete control over DOM updates. This chapter covers both attributes in depth, including relative targeting, all swap strategies, swap modifiers, and out-of-band updates for complex multi-element changes."]},{"l":"Understanding hx-target","p":["The hx-target attribute accepts a CSS selector that identifies where the server response should be placed. Without it, htmx targets the element that triggered the request."]},{"l":"Basic ID Targeting","p":["The most common pattern targets an element by ID:","When clicked, the button fetches content from the server and inserts it into #product-list. The button itself remains unchanged."]},{"l":"CSS Selector Targeting","p":["Any valid CSS selector works with hx-target:"]},{"l":"The this Keyword","p":["Use this to target the triggering element itself:","The server returns a replacement button, and htmx swaps out the entire element. This pattern works well for toggle states, inline editing, and self-updating components."]},{"l":"Relative Targeting","p":["htmx provides special selectors for targeting elements relative to the trigger. These are invaluable when you have repeating components like list items or table rows.","closest finds the nearest ancestor matching the selector:","Clicking delete removes the entire card, including its contents.","find targets a descendant of the triggering element:","next targets the next sibling matching the selector:","previous targets the previous sibling matching the selector:"]},{"l":"Targeting the Document Body","p":["For full-page updates or navigation-style interactions:","This replaces the entire body content and updates the browser URL, simulating navigation without a full page reload."]},{"l":"Understanding hx-swap","p":["The hx-swap attribute determines how the response content is inserted into the target. The default is innerHTML, but htmx provides many options for different scenarios."]},{"l":"innerHTML (Default)","p":["Replaces the target's inner content while keeping the target element itself:","After the swap, #container still exists but contains only the server response."]},{"l":"outerHTML","p":["Replaces the entire target element, including the element itself:","The server returns a new version of the task element (perhaps with a \"completed\" class), and it replaces the entire #task-5 div."]},{"l":"Position-Based Swaps","p":["These options insert content relative to the target without replacing it:","beforebegin inserts before the target element:","The new content appears before the ul, as a sibling.","afterbegin inserts inside the target, before its first child:","New messages appear at the top of the list.","beforeend inserts inside the target, after its last child:","New entries append to the bottom. This is the standard pattern for infinite scroll and \"load more\" features.","afterend inserts after the target element:","Replies appear after the comment, as siblings."]},{"l":"delete","p":["Removes the target element entirely:","The target element disappears from the DOM. The server response is ignored (though you should still return a 200 status)."]},{"l":"none","p":["Performs no swap. The server response is received but not inserted into the DOM:","Use this for side-effect-only requests like analytics, logging, or triggering background processes."]},{"l":"Swap Modifiers","p":["You can add modifiers to hx-swap to control timing, scrolling, and focus behavior."]},{"l":"Timing Modifiers","p":["swap: delays the swap operation:","settle: delays the settle step (when htmx adds classes like htmx-settling):"]},{"l":"Scroll Modifiers","p":["scroll: scrolls the target or window after the swap:","show: ensures the target is visible after the swap:"]},{"l":"Focus Modifier","p":["focus-scroll: controls whether to scroll when focusing an element:"]},{"l":"Combining Modifiers","p":["Multiple modifiers can be combined:"]},{"l":"Filtering Responses with hx-select","p":["Sometimes the server returns more HTML than you need. The hx-select attribute extracts specific content from the response:","Even if /FullPage returns an entire page, htmx extracts only the element matching #just-this-section and swaps that into #container.","This is useful when:","Reusing existing page handlers that return full pages","Extracting specific content from external sources","Avoiding duplicate handler methods for partial vs full responses"]},{"l":"Out-of-Band Updates","p":["Standard htmx updates target a single element. But what if one action needs to update multiple unrelated parts of the page? A form submission might need to update a success message, a notification count in the header, and an item in a sidebar.","Out-of-band (OOB) updates solve this. Elements in the server response marked with hx-swap-oob=true are swapped into matching elements on the page by ID, regardless of the original target."]},{"l":"Basic OOB Example","p":["Main page:","Server response:","htmx processes the response as follows:","The first element (without hx-swap-oob) goes to the target (#result)","Elements with hx-swap-oob=true find their matching elements by ID and replace them"]},{"l":"OOB with Server-Side Code","p":["Here is a complete Razor Pages example:"]},{"l":"OOB Swap Modes","p":["You can specify how OOB elements are swapped:"]},{"l":"Multiple OOB Updates","p":["A single response can include multiple OOB elements:"]},{"l":"hx-select-oob","p":["For more control, use hx-select-oob on the triggering element to specify which parts of the response should be treated as OOB:","htmx will:","Swap the response into #main-content(the target)","Extract #sidebar-stats from the response and swap it into the matching element on the page","Extract #header-alerts from the response and swap it into the matching element on the page"]},{"l":"Practical Examples"},{"l":"Infinite Scroll","p":["Load more content as the user scrolls:"]},{"l":"Live Search with Results Panel"},{"l":"Inline Edit with Cancel","p":["_UserNameEdit.cshtml:"]},{"l":"Shopping Cart with Multiple Updates","p":["_CartItem.cshtml:"]},{"l":"Debugging Target and Swap Issues"},{"l":"Common Problems","p":["Target element not found","htmx silently fails if the target selector does not match any element. Verify:","The element exists in the DOM","The ID or class is spelled correctly","The element is not inside a template or script tag","Wrong element updated","Check for duplicate IDs on the page. Each ID should be unique.","OOB elements not updating","Verify:","The element ID in the response matches an element on the page exactly","The hx-swap-oob attribute is on the element in the response, not on the page","Content appears but in wrong position","Review your hx-swap value. Common confusion:","beforeend adds inside the target, at the end","afterend adds outside the target, after it"]},{"l":"Browser Developer Tools","p":["Open the Network tab to inspect responses. Check:","Is the response HTML valid?","Does it contain the expected content?","For OOB, do element IDs match?","Use the Elements tab to watch DOM changes in real-time as htmx processes responses."]},{"l":"htmx Logging","p":["Enable verbose logging:","This outputs every htmx event to the console, including target resolution and swap operations."]},{"l":"Summary","p":["This chapter covered hx-target and hx-swap in depth:","hx-target accepts CSS selectors, including this and relative selectors ( closest, find, next, previous)","hx-swap controls insertion: innerHTML, outerHTML, beforebegin, afterbegin, beforeend, afterend, delete, none","Swap modifiers control timing ( swap:, settle:), scrolling ( scroll:, show:), and focus ( focus-scroll:)","hx-select filters which part of the response to use","hx-swap-oob enables updating multiple unrelated elements from a single response","hx-select-oob provides fine-grained control over OOB element selection","These attributes give you precise control over how your UI responds to server updates, enabling complex interactions without custom JavaScript."]},{"l":"Preview of Next Chapter","p":["Chapter 8 explores hx-trigger and event handling. You will learn how to control when requests fire, respond to custom events, add conditions and modifiers, and build responsive interfaces that react to user behavior in sophisticated ways."]}],[{"l":"Handling Events with hx-trigger and hx-on","p":["Previous chapters focused on what happens when htmx requests complete: where content goes, how it gets inserted. This chapter focuses on when requests fire in the first place. The hx-trigger attribute gives you precise control over the events that initiate requests. The hx-on attribute lets you run JavaScript in response to htmx lifecycle events. Together, they let you build interactions that respond to user behavior in sophisticated ways.","Default triggers work for most cases. Buttons fire on click. Forms fire on submit. Inputs fire on change. But real applications need more: debounced search that waits for users to stop typing, polling that checks for updates every few seconds, lazy loading that fetches content when elements scroll into view, keyboard shortcuts that respond to specific key combinations. This chapter covers all of these patterns and more."]},{"l":"Understanding hx-trigger","p":["The hx-trigger attribute specifies which events cause htmx to send a request. Without it, htmx uses sensible defaults based on the element type."]},{"l":"Default Triggers","p":["htmx assigns default triggers based on element type:","Element","Default Trigger","button","click","a","form","submit","input","change","select","textarea","Other elements","For many interactions, you never need to specify hx-trigger at all:"]},{"l":"Standard DOM Events","p":["Any DOM event can trigger a request:"]},{"l":"Multiple Triggers","p":["Combine multiple events with commas:","This fires on both keyup events and when the user clicks the search icon in a search-type input."]},{"l":"Trigger Modifiers","p":["Modifiers refine when and how triggers fire. Add them after the event name."]},{"l":"changed Modifier","p":["Only fires if the element's value actually changed:","Without changed, every keyup fires a request, even arrow keys or shift. With changed, requests only fire when the input value differs from before."]},{"l":"delay: Modifier","p":["Waits a specified time after the event before firing. If another event occurs during the delay, the timer resets:","The request fires 300ms after the user stops typing. This debouncing pattern prevents flooding your server with requests on every keystroke."]},{"l":"throttle: Modifier","p":["Limits how often requests can fire. Unlike delay, it fires immediately on the first event, then ignores subsequent events for the specified duration:","This fires at most once every 100ms, even if the mouse moves continuously."]},{"l":"once Modifier","p":["Fires only once, then stops listening:","After the first request completes, the element no longer responds to the trigger."]},{"l":"from: Modifier","p":["Listens for events from a different element:","The div makes a request when the button is clicked. This decouples the trigger source from the target element.","You can also listen for events from the document or window:"]},{"l":"target: Modifier","p":["Filters events based on the event target:","Only clicks on td elements trigger the request, not clicks on the table itself or other elements."]},{"l":"consume Modifier","p":["Prevents the event from propagating to parent elements:","Clicking the button only fires the inner request. Without consume, both requests would fire."]},{"l":"queue: Modifier","p":["Controls how events queue when a request is already in flight:","For most cases, queue:last or queue:none prevents duplicate submissions."]},{"l":"Special Triggers","p":["htmx provides special trigger values for common scenarios."]},{"l":"load Trigger","p":["Fires when the element is loaded into the DOM:","This makes the request immediately when the page loads, useful for lazy-loading initial content."]},{"l":"revealed Trigger","p":["Fires when the element scrolls into the viewport:","This is the foundation for infinite scroll and lazy loading. The request fires only when the user scrolls the element into view."]},{"l":"intersect Trigger","p":["Similar to revealed but offers more control through Intersection Observer options:"]},{"l":"every Trigger","p":["Creates polling intervals:","This checks for new notifications every 30 seconds. Combine with other triggers:","The status loads immediately, then refreshes every 10 seconds."]},{"l":"Event Filters","p":["Filter events based on conditions using bracket syntax:"]},{"l":"Key Filters"},{"l":"Modifier Key Filters"},{"l":"Custom Conditions","p":["Any JavaScript expression that returns a boolean works:"]},{"l":"Understanding hx-on","p":["The hx-on attribute executes JavaScript in response to events. It uses the syntax hx-on:event=javascript for standard DOM events and hx-on::event=javascript(double colon) for htmx-specific events."]},{"i":"standard-dom-events-1","l":"Standard DOM Events"},{"l":"htmx Lifecycle Events","p":["htmx fires events throughout the request lifecycle. Use double colon to listen for them:"]},{"l":"Key htmx Events","p":["After content is swapped into DOM","After CSS transitions complete","After request completes (success or failure)","Before content is swapped, can modify swap behavior","Before request, can modify headers/parameters","Event","htmx:afterRequest","htmx:afterSettle","htmx:afterSwap","htmx:beforeRequest","htmx:beforeSwap","htmx:configRequest","htmx:responseError","htmx:sendError","Just before request is sent","When it Fires","When request fails to send (network error)","When server returns error status"]},{"l":"Form Validation with hx-on","p":["Validate before sending the request:"]},{"l":"Animations with hx-on","p":["Trigger animations when content loads:"]},{"l":"Server-Triggered Events with HX-Trigger Header","p":["The HX-Trigger response header enables server-initiated events. When your server includes this header, htmx dispatches custom events on the client that other elements can listen for."]},{"l":"Basic Server Event","p":["Other elements can listen for this event:","When the form submits and the server returns the HX-Trigger: itemCreated header, the items list automatically refreshes."]},{"l":"Multiple Events","p":["Trigger multiple events:"]},{"l":"Events with Data","p":["Pass data with events using JSON:","Access the data in JavaScript:"]},{"l":"Timing Variations","p":["The HX-Trigger header has timing variants:"]},{"l":"Practical Examples"},{"l":"Live Search with Debouncing"},{"l":"Infinite Scroll","p":["_PostBatch.cshtml:"]},{"l":"Auto-Refreshing Dashboard"},{"l":"Keyboard Shortcuts"},{"l":"Cascading Dropdowns"},{"l":"Debugging Triggers and Events"},{"l":"Enable htmx Logging","p":["This logs every event htmx processes, showing trigger evaluation and request lifecycle."]},{"l":"Monitor Specific Events"},{"l":"Common Issues","p":["Add changed modifier for input events","Add delay: for debouncing","Add throttle: for rate limiting","Check event name spelling","Check for events firing on body element","Check JavaScript syntax in brackets","Event filter not working","For from: triggers, ensure the source element exists","Header name is case-sensitive","HX-Trigger header not working","JSON must be valid for events with data","Request fires too often","Test the condition in browser console first","Trigger not firing","Verify property names (e.g., key not keyCode)","Verify the element exists when htmx initializes"]},{"l":"Summary","p":["This chapter covered hx-trigger and hx-on for precise control over htmx interactions:","Default triggers work for common elements (click, submit, change)","Modifiers refine behavior: changed, delay:, throttle:, once, from:, target:, consume, queue:","Special triggers: load, revealed, intersect, every","Event filters use bracket syntax for conditions: keyup[key=='Enter'], click[ctrlKey]","hx-on: executes JavaScript on DOM events (single colon)","hx-on:: executes JavaScript on htmx events (double colon)","HX-Trigger header dispatches events from server responses","These tools let you build responsive, event-driven interfaces without custom JavaScript frameworks."]},{"l":"Preview of Next Chapter","p":["Chapter 9 introduces Hyperscript, a companion language to htmx that adds client-side logic with a clean, readable syntax. You will learn how to handle complex interactions, manage state, and add behaviors that would otherwise require JavaScript, all using simple English-like commands embedded in your HTML."]}],[{"l":"Integrating Hyperscript for Complex Logic","p":["htmx handles most interactions beautifully. Click a button, fetch content, swap it into the page. But some interactions need client-side logic that htmx alone cannot provide: toggling classes based on conditions, waiting for animations to complete, orchestrating multi-step sequences, or managing temporary UI state. You have two choices: write JavaScript or use Hyperscript.","Hyperscript is a scripting language built for HTML. It lives in your markup using the _ attribute, reads like English, and integrates tightly with htmx events. For many interactions, it provides a cleaner alternative to JavaScript event listeners and DOM manipulation.","This chapter teaches you when Hyperscript makes sense, when htmx alone suffices, and how to combine both for sophisticated interactions. You will learn the syntax, see complete working examples with Razor Pages, and understand the trade-offs involved."]},{"l":"Installing Hyperscript","p":["Add Hyperscript to your _Layout.cshtml after htmx:","Or install locally:","Then reference from your wwwroot:","Hyperscript uses the _ attribute (underscore) for its code. This keeps it visually distinct from htmx's hx- attributes."]},{"l":"Hyperscript Syntax Basics","p":["Hyperscript reads like English. Here are the fundamental patterns:"]},{"l":"Event Handling"},{"l":"Class Manipulation"},{"l":"Waiting and Timing"},{"l":"Conditionals"},{"l":"Targeting Elements"},{"l":"Triggering Events"},{"l":"When to Use Hyperscript vs htmx Alone","p":["Before reaching for Hyperscript, check if htmx already provides what you need."]},{"l":"Use htmx Alone For:","p":["Confirmation dialogs- htmx has hx-confirm:","Triggering requests from other elements- Use hx-trigger with from::","Refreshing elements after actions- Use HX-Trigger response header:"]},{"l":"Use Hyperscript For:","p":["Class toggling with conditions:","Sequenced animations:","Temporary UI state:","Multi-step user flows:"]},{"l":"Integrating Hyperscript with htmx Events","p":["htmx fires events throughout the request lifecycle. Hyperscript can listen for these events and respond accordingly."]},{"l":"Key htmx Events","p":["Event","When It Fires","htmx:beforeRequest","Before request is sent","htmx:afterRequest","After request completes","htmx:beforeSwap","Before content is swapped","htmx:afterSwap","After content is swapped","htmx:afterSettle","After CSS transitions complete","htmx:responseError","When server returns error"]},{"l":"Responding to htmx Events"},{"l":"Triggering htmx from Hyperscript","p":["Sometimes you need Hyperscript to initiate an htmx request. The cleanest approach triggers a click on an htmx-enabled element:"]},{"l":"Chaining Actions After htmx Completes"},{"l":"Practical Examples"},{"l":"Tooltip System","p":["A tooltip that appears on hover with smooth transitions:"]},{"l":"Modal Dialog","p":["A modal that opens, loads content via htmx, and closes on completion:","Pages/Shared/_ProductDetails.cshtml:"]},{"l":"Accordion Component","p":["An accordion that allows only one section open at a time:"]},{"l":"Form with Client-Side Validation","p":["Validate before submitting, show loading state, handle errors:"]},{"l":"Dashboard with Refresh Controls","p":["A dashboard with manual refresh and auto-refresh toggle:"]},{"l":"Copy to Clipboard","p":["A button that copies text and shows feedback:"]},{"l":"Debugging Hyperscript"},{"l":"Enable Debug Mode","p":["Add this script to see verbose output in the console:"]},{"l":"Common Issues","p":["Action not completing","Add log statements to trace execution: _=on click log 'clicked' then ...","Check for exit statements that might be stopping execution","Check that the _ attribute is on the correct element","Check that the source element exists when the event fires","Confirm the event name is correct (htmx events use colons: htmx:afterSwap)","Element not found","Ensure the target element exists in the DOM","Event not firing","Look for syntax errors in the browser console","Script not running","Use browser dev tools to test the selector","Use from: to listen for events bubbling from child elements","Verify conditionals are properly closed with end","Verify Hyperscript is loaded after htmx","Verify the selector is correct"]},{"l":"Debugging with Log","p":["The log command outputs to the browser console."]},{"l":"Performance Considerations","p":["Hyperscript is lightweight (about 15KB minified), but keep these points in mind:","Avoid heavy computation- Hyperscript is interpreted at runtime. Complex logic should live in JavaScript or on the server.","Minimize DOM queries- Cache references when performing multiple operations on the same element.","Use htmx for network requests- Hyperscript can make HTTP requests, but htmx handles them better with swapping, indicators, and error handling.","Keep scripts focused- If a Hyperscript block exceeds 10-15 lines, consider moving the logic to JavaScript."]},{"l":"Summary","p":["Hyperscript provides a readable, English-like syntax for client-side interactions that live directly in your markup:","Installation: Add the script after htmx in your layout","Syntax: Uses _ attribute with English-like commands","Class manipulation: add, remove, toggle classes on elements","Event handling: on click, on mouseenter, on htmx:afterSwap","Timing: wait 500ms, wait for eventName","Conditionals: if ... else ... end","htmx integration: Listen for htmx events, trigger htmx requests","Use Hyperscript for UI state and sequencing. Use htmx alone when its built-in features ( hx-confirm, hx-trigger, HX-Trigger header) suffice. The combination gives you sophisticated interactions without JavaScript frameworks."]},{"l":"Preview of Next Chapter","p":["Chapter 10 covers URL management with hx-push-url and hx-replace-url. You will learn how to update the browser's address bar during htmx navigation, enable back-button support, and create deep-linkable components that maintain state across page loads."]}],[{"l":"Navigating with hx-push-url and hx-replace-url","p":["htmx requests update content without page reloads. That speed comes with a cost: the browser's address bar stays frozen. Users cannot bookmark the current view. The back button does nothing useful. Shared links land on the wrong content. These problems make htmx applications feel broken despite their responsiveness.","The hx-push-url and hx-replace-url attributes solve this. They synchronize the browser's address bar with your dynamic content, enabling bookmarks, shareable links, and proper back/forward navigation. Your application gains single-page-app responsiveness while keeping multi-page-app navigation behavior.","This chapter covers both attributes in depth, shows when to use each, and demonstrates complete working examples with Razor Pages. You will learn to handle the critical server-side logic that makes URL-driven navigation work for both htmx requests and direct page loads."]},{"l":"Understanding Browser History","p":["Before diving into htmx attributes, understand how browser history works.","The browser maintains a history stack. Each navigation pushes a new entry onto the stack. The back button pops entries off. The forward button moves through entries you've backed past.","Push adds a new entry:","Replace modifies the current entry without adding:","htmx gives you control over which behavior to use for each interaction."]},{"l":"The hx-push-url Attribute","p":["The hx-push-url attribute pushes a new URL onto the browser's history stack when the htmx request completes successfully. This creates a navigation trail users can traverse with back/forward buttons."]},{"l":"Basic Usage","p":["When clicked:","htmx sends a GET request to the handler","The response swaps into #content","The browser's address bar updates to the URL","A new entry is added to the history stack","The href attribute ensures the link works without JavaScript. The hx-get tells htmx to intercept the click and handle it dynamically."]},{"l":"Custom URLs","p":["You can push a different URL than the request URL:","The request goes to the handler with query parameters, but the browser shows the cleaner URL /search/htmx."]},{"l":"When to Use hx-push-url","p":["Use hx-push-url when:","Users should be able to bookmark the current view","The back button should return to the previous view","Links should be shareable","The view represents a distinct \"page\" or \"state\"","Examples:","Tab navigation (each tab is a bookmarkable view)","Blog post links","Search results pages","Product detail views","Dashboard sections"]},{"l":"The hx-replace-url Attribute","p":["The hx-replace-url attribute updates the browser's address bar without adding a history entry. The current entry is replaced."]},{"i":"basic-usage-1","l":"Basic Usage","p":["When the selection changes:","htmx sends a GET request with the selected value","The response swaps into #product-list","The browser's address bar updates","The current history entry is replaced (no new entry added)"]},{"l":"When to Use hx-replace-url","p":["Use hx-replace-url when:","The URL should reflect current state for bookmarking","But the back button should skip this intermediate state","The change is a refinement, not a navigation","Examples:","Filter selections (sort, category, date range)","Pagination within a list","Form steps in a wizard (back should exit the wizard, not go to previous step)","Modal content changes","Auto-save states"]},{"l":"Configuring History Restoration","p":["For back/forward navigation to work properly, htmx needs to know which element contains the restorable content. Add hx-history-elt to the container that holds your dynamic content:","When the user clicks back, htmx:","Intercepts the browser's popstate event","Checks its history cache for the previous URL's content","Restores the cached content to the hx-history-elt element","If not cached, makes a fresh request to the URL","Without hx-history-elt, back button behavior is unpredictable. Add it to the outermost container that changes during navigation."]},{"l":"Handling Direct vs htmx Requests","p":["Here's the critical piece many tutorials miss: your server must handle both types of requests.","htmx request: User clicks a link with hx-get. Server should return partial content only.","Direct request: User types the URL, refreshes the page, or clicks a shared link. Server should return the complete page with layout."]},{"l":"Detecting htmx Requests","p":["htmx adds an HX-Request header to all requests. Check for it in your PageModel:"]},{"l":"The Razor Page View"},{"l":"The Partial View","p":["Pages/Shared/_BlogPost.cshtml:","This setup works for:","htmx clicks (returns partial, pushes URL)","Direct URL access (returns full page)","Page refresh (returns full page)","Shared/bookmarked links (returns full page)","Back button (restores from htmx cache or fetches fresh)"]},{"l":"Using hx-boost for Simpler Navigation","p":["If you want all links in a section to behave like htmx links with hx-push-url, use hx-boost instead of adding attributes to every link:","With hx-boost=true:","All links and forms in that container automatically use htmx","URLs are automatically pushed to history","Links degrade gracefully without JavaScript","This is often the simplest approach for traditional navigation patterns."]},{"l":"Excluding Links from Boost","p":["Add hx-boost=false to links that should navigate normally:"]},{"l":"Complete Example: Tabbed Interface","p":["Here's a complete working example of a tabbed profile page:"]},{"l":"PageModel"},{"l":"Razor Page"},{"l":"Updating Active Tab Styling","p":["When htmx loads content, the tab styling needs to update. Use hx-on or handle the htmx:afterSwap event:"]},{"l":"Complete Example: Filterable List","p":["A product list with category filtering and pagination:"]},{"i":"pagemodel-1","l":"PageModel"},{"i":"razor-page-1","l":"Razor Page"},{"l":"Product Grid Partial","p":["Pages/Shared/_ProductGrid.cshtml:","Note that category links use hx-push-url(user might want to go back to previous category), while pagination uses hx-replace-url(user probably doesn't want to back through every page)."]},{"l":"History Events","p":["htmx fires events during history operations that you can listen for:"]},{"l":"Re-initializing Components After History Restore","p":["If your pages use JavaScript components that need initialization, handle htmx:historyRestore:"]},{"l":"Common Issues and Solutions"},{"l":"Back Button Does Nothing","p":["Cause: Missing hx-history-elt attribute.","Solution: Add hx-history-elt to the container that holds changing content:"]},{"l":"Direct URL Access Shows Partial Content","p":["Cause: Server returns partial for all requests.","Solution: Check for HX-Request header:"]},{"l":"URL Updates But Content Doesn't Load on Refresh","p":["Cause: Server doesn't handle the URL parameters on direct requests.","Solution: Ensure your OnGet method loads the correct content based on URL parameters for both htmx and direct requests."]},{"l":"History Grows Too Fast","p":["Cause: Using hx-push-url for operations that should use hx-replace-url.","Solution: Use hx-replace-url for filters, sorts, pagination, and other refinements. Use hx-push-url only for distinct views."]},{"l":"Summary","p":["This chapter covered URL management with htmx:","hx-push-url adds entries to browser history (for bookmarkable, distinct views)","hx-replace-url modifies the current entry (for refinements like filtering)","hx-history-elt tells htmx which container to restore on back/forward","hx-boost automatically applies htmx with push-url to all links in a container","Server-side handling must return partials for htmx requests and full pages for direct requests","History events let you respond to navigation and re-initialize components","These tools let you build applications that feel like single-page apps while maintaining the bookmarkability and shareability of traditional multi-page applications."]},{"l":"Preview of Next Chapter","p":["Chapter 11 covers building reusable HTML components with htmx. You will learn to create forms that submit without page reloads, modal dialogs that load content dynamically, and component patterns that combine the techniques from previous chapters into cohesive, reusable building blocks."]}],[{"l":"Building Blocks with HTML Components: Forms and Modal Forms","p":["Forms are where users interact most directly with your application. Registration, login, contact forms, settings pages, checkout flows. Every meaningful action requires a form. Traditional HTML forms reload the entire page on submit, destroying scroll position, clearing transient state, and making users wait while the browser re-renders everything. This experience feels dated.","htmx transforms forms into responsive, immediate interactions. Submit a form, get back a fragment of HTML, swap it into the page. No reload. No flicker. The user stays in context. Combined with modal dialogs, you can create focused workflows that collect input without navigating away from the current page.","This chapter covers both patterns with complete, working examples. You will build inline forms that submit and update in place, modal forms that appear on demand and close on success, and learn how to handle validation errors gracefully. Every example includes the server-side code required to make it work."]},{"l":"Form Submission with hx-post","p":["The hx-post attribute converts a traditional form into an htmx-powered form. Instead of reloading the page, the form submits asynchronously and htmx swaps the response into a target element."]},{"l":"Basic Contact Form","p":["Here's a complete contact form implementation:","Pages/Contact.cshtml:","Pages/Contact.cshtml.cs:","Pages/Shared/_ContactForm.cshtml:","Pages/Shared/_ContactSuccess.cshtml:","CSS for the spinner:","This form:","Submits via htmx without page reload","Shows validation errors inline if submission fails","Displays a spinner during submission","Disables the button to prevent double-submission","Shows a success message with option to send another"]},{"l":"Comment Form with List Update","p":["For forms that add items to a list, use hx-swap=beforeend to append new items:","Pages/Comments.cshtml:","Pages/Shared/_CommentForm.cshtml:","Pages/Comments.cshtml.cs:","Pages/Shared/_Comment.cshtml:","The hx-on::after-request attribute clears the form after successful submission so users can immediately post another comment."]},{"l":"Inline Editing","p":["Allow users to edit content in place without navigating to a separate page:","Pages/Shared/_UserRow.cshtml:","Pages/Shared/_UserEditRow.cshtml:","Pages/Users.cshtml.cs (handlers):"]},{"l":"Modal Forms","p":["Modal forms appear on demand without navigating away from the current page. They focus user attention and work well for quick actions like adding items or confirming operations."]},{"l":"Modal Structure","p":["First, add a modal container to your layout or page:","Modal CSS:"]},{"l":"Opening the Modal","p":["Trigger buttons load content into the modal and open it:"]},{"l":"Modal Form Content","p":["Pages/Shared/_UserCreateForm.cshtml:"]},{"l":"Server-Side Modal Handlers","p":["Pages/Users.cshtml.cs:"]},{"l":"Closing Modal with HX-Trigger Header","p":["An alternative to Hyperscript is using the HX-Trigger response header:","Add a listener in your layout:","And simplify the form:"]},{"l":"Edit Modal","p":["The same pattern works for editing existing items:","Pages/Shared/_UserEditForm.cshtml:"]},{"l":"Confirmation Dialogs","p":["For dangerous actions, use hx-confirm for simple confirmations:","For custom confirmation modals with more detail:","Pages/Shared/_ConfirmDelete.cshtml:"]},{"l":"Form Validation Patterns"},{"l":"Client-Side Validation","p":["HTML5 validation attributes work with htmx. The form will not submit until validation passes:"]},{"l":"Server-Side Validation with Error Display","p":["Return the form partial with ModelState errors:","The partial uses tag helpers to display errors:"]},{"l":"Validation Summary","p":["For a summary of all errors:"]},{"l":"Accessibility Considerations","p":["Make your forms accessible:"]},{"l":"Labels and Inputs","p":["Always associate labels with inputs:"]},{"l":"Error Announcements","p":["Use aria-live for dynamic error messages:"]},{"l":"Focus Management in Modals","p":["When a modal opens, focus should move to the first interactive element:"]},{"l":"Reusable Form Components","p":["Create partial views for common form patterns:","Pages/Shared/_FormGroup.cshtml:","Use it across forms:"]},{"l":"Summary","p":["This chapter covered forms and modal forms with htmx:","Basic forms submit with hx-post and swap responses without page reload","Anti-forgery tokens are required in all forms using @Html.AntiForgeryToken()","Validation errors display by returning the form partial with ModelState","Loading indicators use hx-indicator to show progress","Comment/list patterns use hx-swap=beforeend to append items","Inline editing swaps table rows between view and edit states","Modal forms load content on demand and close on success","HX-Trigger header provides server-controlled modal closing","hx-confirm adds simple confirmation dialogs","Accessibility requires proper labels, aria attributes, and focus management","These patterns combine into sophisticated form workflows while keeping your Razor Pages clean and maintainable."]},{"l":"Preview of Next Chapter","p":["Chapter 12 covers tabs and accordions, two classic UI patterns that organize content into collapsible or switchable sections. You will learn to build tab interfaces that load content on demand, accordions that expand and collapse smoothly, and navigation patterns that combine with the URL management techniques from Chapter 10."]}],[{"l":"Building Blocks with HTML Components: Tabs and Accordions","p":["Tabs and accordions appear everywhere: dashboards, settings pages, FAQs, product details, documentation. These components organize content into digestible sections that users reveal on demand. Traditional implementations require JavaScript to toggle visibility, manage state, and handle keyboard navigation. With htmx and Razor Pages, you can build these components with server-rendered content, lazy loading, and minimal client-side code.","This chapter covers both patterns with complete implementations. You will build tabbed interfaces with active state management, URL integration for bookmarking, and proper accessibility. You will create accordions that expand and collapse smoothly, load content on demand, and support both single-open and multi-open behaviors. Every example includes the server-side code and CSS required to make it work."]},{"l":"Tabbed Interfaces","p":["Tabs let users switch between content panels without page navigation. Each tab represents a view, and clicking it reveals the associated content while hiding others."]},{"l":"Basic Tab Structure","p":["Start with the HTML structure:","Pages/Dashboard.cshtml:","Pages/Dashboard.cshtml.cs:","Tab partial example - Pages/Shared/_OverviewTab.cshtml:"]},{"l":"Tab CSS"},{"l":"Tabs with URL Integration","p":["Add hx-push-url to make tabs bookmarkable and support browser back/forward:","Add hx-history-elt to the tab panel for proper history restoration:","Now users can:","Bookmark specific tabs","Share links to specific tabs","Use back/forward buttons to navigate between tabs","Refresh the page and stay on the current tab"]},{"l":"Product Detail Tabs","p":["A common pattern for e-commerce or content sites:","Pages/Product.cshtml:","Pages/Product.cshtml.cs:","Pages/Shared/_ProductSpecifications.cshtml:","Pages/Shared/_ProductReviews.cshtml:"]},{"l":"Accordion Components","p":["Accordions stack content sections vertically, allowing users to expand and collapse individual sections. They work well for FAQs, settings panels, and any content where users need access to specific sections without seeing everything at once."]},{"l":"Basic Accordion","p":["Pages/FAQ.cshtml:","Pages/FAQ.cshtml.cs:","Pages/Shared/_FAQAnswer.cshtml:"]},{"l":"Accordion CSS"},{"l":"Single-Open Accordion","p":["For accordions where only one section should be open at a time:"]},{"l":"Accordion with Preloaded Content","p":["If content is small and you want instant expansion without server requests:","No htmx needed here since content is already in the page. Hyperscript handles the expand/collapse."]},{"l":"Accordion with Cached Content","p":["Load content once, then use cached version on subsequent opens:","The hx-trigger=click once ensures htmx only fetches content on the first click. Subsequent clicks just toggle visibility using Hyperscript."]},{"l":"Accessibility","p":["Tabs and accordions have specific accessibility requirements."]},{"l":"Tab Accessibility","p":["Key requirements:","Container has role=tablist","Tabs have role=tab and aria-selected","Active tab has tabindex=0, others have tabindex=-1","Panels have role=tabpanel and aria-labelledby"]},{"l":"Keyboard Navigation for Tabs","p":["Add arrow key navigation:"]},{"l":"Accordion Accessibility","p":["Use the hidden attribute alongside CSS for proper accessibility:"]},{"l":"Error Handling","p":["Handle failed requests gracefully:"]},{"l":"Loading States","p":["Show loading feedback during content fetch:"]},{"l":"Reusable Tab Component","p":["Create a partial for consistent tab styling across your application:","Pages/Shared/_TabContainer.cshtml:","Use it:"]},{"l":"Summary","p":["This chapter covered tabs and accordions with htmx and Razor Pages:","Tabs switch between content panels with lazy loading via hx-get","Active state managed with Hyperscript class toggling","URL integration uses hx-push-url and hx-history-elt for bookmarkable tabs","Accordions expand/collapse sections with aria-expanded and CSS transitions","Single-open accordions close other sections when opening a new one","Cached content uses hx-trigger=click once to load content only once","Accessibility requires proper ARIA roles, states, and keyboard navigation","Error handling shows user-friendly messages when requests fail","Loading states provide feedback during content fetch","These patterns give you interactive, accessible navigation components without JavaScript frameworks."]},{"l":"Preview of Next Chapter","p":["Chapter 13 covers dynamic lists and tables. You will learn to build sortable, filterable tables with server-side data, pagination that works with htmx, inline row editing, and real-time updates for live data displays."]}],[{"l":"Building Blocks with HTML Components: Lists and Tables","p":["Lists and tables display the data that drives business applications: product catalogs, user directories, transaction histories, order queues, audit logs. Traditional server-rendered tables require full page reloads to sort, filter, or paginate. That experience feels dated. Users expect to click a column header and see results instantly. They expect to scroll and load more items without navigating to a new page. They expect to delete a row and watch it disappear.","htmx delivers these interactions with server-rendered HTML. Your Razor Pages return table rows and list items as partial views. htmx swaps them into the page. No JavaScript frameworks. No client-side data binding. No duplicated business logic. The server owns the data, the filtering, the sorting, the pagination. The client displays what the server sends.","This chapter covers the patterns you need: dynamic table updates, sorting with clickable headers, pagination with page controls, infinite scroll for continuous loading, inline editing and deletion, and the combination of all these features into a cohesive data grid."]},{"l":"Anti-Forgery Configuration","p":["Before building lists with delete and edit operations, configure anti-forgery token handling. Add this to your layout so all htmx requests include the token:","Pages/Shared/_Layout.cshtml (in the head or before closing body):","This ensures DELETE, PUT, and POST requests from htmx include the anti-forgery token."]},{"l":"Dynamic Table Updates","p":["Tables that refresh without page reloads create a responsive experience. Use hx-get to fetch updated rows and hx-trigger to control when updates happen."]},{"l":"Live Leaderboard","p":["A leaderboard that updates every few seconds:","Pages/Leaderboard.cshtml:","Pages/Leaderboard.cshtml.cs:","Pages/Shared/_LeaderboardRows.cshtml:","The hx-trigger=load, every 10s loads data immediately and refreshes every 10 seconds. The manual refresh button lets users update on demand."]},{"l":"Sorting","p":["Clickable column headers that sort data require tracking the current sort state and toggling direction on repeated clicks."]},{"l":"Sortable Table","p":["Pages/Tasks.cshtml:","Pages/Tasks.cshtml.cs:","Pages/Shared/_TaskRows.cshtml:"]},{"l":"Sort Header CSS"},{"l":"Pagination","p":["Server-side pagination returns a subset of data based on page number and page size."]},{"l":"Paginated Product List","p":["Pages/Products.cshtml:","Pages/Products.cshtml.cs:","Pages/Shared/_ProductList.cshtml:"]},{"l":"Infinite Scroll","p":["Infinite scroll loads more content as the user scrolls down, creating a continuous browsing experience."]},{"l":"Infinite Product Feed","p":["Pages/Feed.cshtml:","Pages/Feed.cshtml.cs:","Pages/Shared/_FeedItems.cshtml:","The trigger div at the bottom uses hx-trigger=revealed to fire when it scrolls into view. It replaces itself with the next batch of items plus a new trigger (if more items exist). When no more items exist, it shows an end message instead."]},{"l":"Infinite Scroll CSS"},{"l":"Filtering","p":["Filters narrow down displayed data based on user criteria."]},{"l":"Filterable Task List","p":["Pages/Tasks.cshtml (updated with filters):","Updated PageModel with filtering:","The hx-include=.filters-bar ensures all filter values are sent with each request, preserving filter state when sorting or searching."]},{"l":"Inline Editing","p":["Edit rows in place without opening a modal or navigating to a new page."]},{"l":"Inline Edit Row","p":["Pages/Shared/_TaskRow.cshtml (view mode):","Pages/Shared/_TaskEditRow.cshtml (edit mode):","Task handlers:"]},{"l":"Complete Data Grid","p":["Combine sorting, filtering, pagination, and CRUD operations into a complete data grid:","Pages/Orders.cshtml:","Pages/Shared/_OrdersGrid.cshtml:"]},{"l":"Error Handling","p":["Handle failed requests gracefully:"]},{"l":"Summary","p":["This chapter covered dynamic lists and tables with htmx:","Anti-forgery tokens configured globally for all htmx requests","Live updates with hx-trigger=every Xs for real-time data","Sorting with clickable headers and toggle direction","Pagination with complete page controls and URL integration","Infinite scroll using hx-trigger=revealed with dynamic page tracking","Filtering with combined filters using hx-include","Inline editing with view/edit row states","Delete operations with confirmation and proper token handling","Empty states and error handling for better UX","Complete data grid combining all features","These patterns form the foundation for any data-driven application, from admin dashboards to e-commerce catalogs."]},{"l":"Preview of Next Chapter","p":["Chapter 14 covers buttons and action links. You will learn to build one-click actions that update UI instantly, confirmation workflows for dangerous operations, batch actions for multiple items, and status toggles that feel immediate and responsive."]}],[{"l":"Building Blocks with HTML Components: Buttons and Action Links","p":["Buttons and links are how users take action in your application. Every click represents intent: create this record, delete that item, toggle this setting, submit this form. Traditional web applications handle these clicks with full page reloads or complex JavaScript event handlers. htmx lets you wire up responsive, immediate interactions using HTML attributes alone.","This chapter focuses on button and link patterns that go beyond basic form submission: inline prompts that collect input without forms, confirmation dialogs that prevent accidents, toggle buttons that flip state instantly, batch actions that operate on multiple items, and buttons that disable themselves during requests to prevent double-submission. Each pattern includes complete server-side code and proper security handling."]},{"l":"Anti-Forgery Token Configuration","p":["All POST, PUT, PATCH, and DELETE requests require anti-forgery tokens. Add this configuration to your layout once, and all htmx requests will include the token automatically:","Pages/Shared/_Layout.cshtml:"]},{"l":"Inline Prompts with hx-prompt","p":["The hx-prompt attribute displays a browser prompt dialog and sends the user's input to the server. This works well for quick edits that don't warrant a full form."]},{"l":"Rename Button","p":["A button that prompts for a new name and updates the item inline:","Important: The prompt value arrives in the HX-Prompt request header, not as a form parameter.","Pages/Items.cshtml.cs:","Pages/Shared/_ItemRow.cshtml:"]},{"l":"Quick Add with Prompt","p":["Add items without a form:"]},{"l":"Confirmation Dialogs","p":["Destructive actions need confirmation. htmx provides two approaches: the simple hx-confirm attribute and custom modal confirmations."]},{"l":"Simple Confirmation with hx-confirm","p":["The hx-confirm attribute shows a browser confirmation dialog before sending the request:","If the user clicks \"OK,\" the request proceeds. If they click \"Cancel,\" nothing happens.","Server handler:"]},{"l":"Custom Modal Confirmation","p":["For styled confirmations with more context, load a modal:","Trigger button:","Modal structure (in layout):","Pages/Shared/_ConfirmDeleteTask.cshtml:","Server handlers:","Modal CSS:"]},{"l":"Toggle Buttons","p":["Toggle buttons switch state and update their appearance immediately."]},{"l":"Complete/Incomplete Toggle","p":["Server handler:","Pages/Shared/_ToggleButton.cshtml:"]},{"l":"Favorite/Unfavorite Toggle"},{"l":"Preventing Double Submission","p":["Users sometimes click buttons multiple times during slow requests. Prevent this with the hx-disabled-elt attribute or CSS."]},{"l":"Using hx-disabled-elt","p":["The hx-disabled-elt attribute specifies which element(s) to disable during the request:","During the request, htmx adds the disabled attribute to the button. When the request completes, it removes it."]},{"l":"Disabling Multiple Elements","p":["Disable the entire form during submission:"]},{"l":"CSS-Based Disable with Loading State","p":["For better visual feedback, combine hx-disabled-elt with loading indicators:"]},{"l":"Batch Actions","p":["Select multiple items and apply an action to all of them."]},{"l":"Batch Delete","p":["Server handler:","Pages/Shared/_ItemsTableBody.cshtml:"]},{"l":"Action Links","p":["Links that trigger htmx actions instead of page navigation."]},{"l":"Load Content Link"},{"l":"Tab-Style Links"},{"l":"Reusable Button Components","p":["Create partial views for consistent button styling and behavior."]},{"l":"Delete Button Partial","p":["Pages/Shared/_DeleteButton.cshtml:","DeleteButtonModel.cs:","Usage:"]},{"l":"Action Button Partial","p":["Pages/Shared/_ActionButton.cshtml:"]},{"l":"Error Handling","p":["Handle failed requests gracefully:","Or handle errors server-side with appropriate status codes:"]},{"l":"Summary","p":["This chapter covered button and link patterns with htmx:","hx-prompt displays a browser prompt and sends input via the HX-Prompt header","hx-confirm shows a confirmation dialog before proceeding","Custom modal confirmations provide styled dialogs with more context","Toggle buttons switch state and update appearance immediately","hx-disabled-elt prevents double-submission by disabling elements during requests","Batch actions operate on multiple selected items","Action links trigger htmx requests instead of page navigation","Reusable partials create consistent button components","These patterns make user interactions feel immediate and responsive while keeping all business logic on the server."]},{"l":"Preview of Next Chapter","p":["Chapter 15 covers loading indicators with hx-indicator and state preservation with hx-preserve. You will learn to show spinners during requests, maintain scroll position and form state across swaps, and create loading skeletons that make your application feel fast and polished."]}],[{"l":"Visual Feedback with hx-indicator and hx-preserve","p":["Users hate uncertainty. When they click a button and nothing happens for 500 milliseconds, they wonder: Did it work? Should I click again? Is the page frozen? That half-second of silence erodes trust in your application. Visual feedback fills that gap. A spinner, a loading overlay, a subtle animation tells users \"I heard you, I'm working on it.\"","htmx provides two attributes for managing visual feedback: hx-indicator shows loading states during requests, and hx-preserve protects specific elements from being replaced during swaps. This chapter covers both with complete, working examples that include proper CSS patterns, accessibility considerations, and common use cases like button spinners, table overlays, and skeleton loaders."]},{"l":"How hx-indicator Works","p":["When htmx sends a request, it adds the htmx-request CSS class to elements. By default, this class is added to the element that triggered the request. The hx-indicator attribute lets you specify additional elements that should receive this class during the request.","Here's the key insight: htmx adds htmx-request directly to the indicator element, not to a parent. Your CSS must account for this."]},{"l":"Basic Indicator CSS Pattern","p":["For indicators inside the triggering element, use a descendant selector:"]},{"l":"Fade Transitions","p":["For smoother appearance, use opacity with transitions:"]},{"l":"Button Loading States","p":["The most common indicator pattern shows a spinner inside a button during form submission."]},{"l":"Button with Inline Spinner","p":["Pages/Tasks.cshtml:","Button CSS:","Pages/Tasks.cshtml.cs:","Pages/Shared/_TaskItem.cshtml:"]},{"l":"Standalone Button Spinner","p":["When you want the spinner next to the button rather than inside:"]},{"l":"Table and List Loading Overlays","p":["For tables and lists that refresh data, overlay the entire container with a loading state."]},{"l":"Table Overlay Pattern","p":["Pages/Products.cshtml:","Overlay CSS:","Pages/Products.cshtml.cs:","Pages/Shared/_ProductRows.cshtml:"]},{"l":"Skeleton Loaders","p":["Skeleton loaders show placeholder shapes that mimic the content layout. They feel faster than spinners because they set expectations about what's coming."]},{"l":"Profile Card Skeleton","p":["Skeleton CSS:","Server handler:","Pages/Shared/_ProfileCard.cshtml:"]},{"l":"Table Skeleton"},{"l":"Understanding hx-preserve","p":["The hx-preserve attribute prevents an element from being replaced during a swap. This is critical to understand: the element is never updated, even if the server sends new content for it."]},{"l":"When to Use hx-preserve","p":["Use hx-preserve for elements that:","Would break or reset if replaced (video players, audio players)","Contain third-party widgets that initialize once (chat widgets, maps)","Have complex client-side state that can't be recreated"]},{"l":"Video Player Example","p":["If htmx swaps #page-content, the video player keeps playing while the video info updates."]},{"l":"Third-Party Widget"},{"l":"When NOT to Use hx-preserve","p":["Do not use hx-preserve for:","Form inputs you want to validate (server can't update them)","Content that should refresh from the server","Elements that need server-side updates","Wrong approach for forms:","Correct approach for forms:","Or use hx-swap-oob to update specific elements:","Server response can include OOB update for error:"]},{"l":"Accessibility","p":["Loading indicators must work for all users, including those using screen readers."]},{"l":"ARIA Attributes for Loading States","p":["Key accessibility patterns:","aria-live=polite announces content changes to screen readers","aria-busy=true during loading tells assistive technology content is updating","role=status on spinners makes them announce to screen readers","visually-hidden class provides text for screen readers without visual display"]},{"l":"Screen Reader CSS"},{"l":"Complete Example: Search with All Patterns","p":["Pages/Search.cshtml:","Pages/Search.cshtml.cs:","Pages/Shared/_SearchResults.cshtml:","Complete CSS:"]},{"l":"Summary","p":["This chapter covered visual feedback with htmx:","hx-indicator specifies elements that receive the htmx-request class during requests","CSS patterns differ based on indicator placement (inside vs. outside trigger)","Button spinners replace button text with loading state during submission","Table overlays cover content with semi-transparent loading indicators","Skeleton loaders show placeholder shapes that mimic expected content","hx-preserve prevents elements from being replaced during swaps (use for video players, widgets)","Accessibility requires ARIA attributes ( aria-busy, aria-live, role=status)","Visual feedback makes the difference between an application that feels broken and one that feels responsive. Users should never wonder if their action was received."]},{"l":"Preview of Next Chapter","p":["Chapter 16 covers hx-select and hx-select-oob for precise content selection. You will learn to extract specific elements from server responses, update multiple page sections with a single request, and build notification systems that update independently from main content."]}],[{"l":"Scoped Updates with hx-select and Out-of-Band Swaps","p":["Most htmx interactions follow a simple pattern: trigger a request, receive HTML, swap it into a target. But real applications rarely update just one thing. Adding an item to a cart should update the cart count in the header. Completing a task should update the task list and the completion percentage. Sending a message should refresh the conversation and show a toast notification.","htmx provides two mechanisms for these multi-element updates: hx-select extracts specific content from a response, and out-of-band (OOB) swaps update elements outside your primary target. This chapter covers both patterns with complete working examples."]},{"l":"Understanding the Two Approaches","p":["Before writing code, understand the distinction:","hx-select filters the response before swapping. If your server returns a full page or a large fragment, hx-select extracts only the part you want. This happens on the client side.","Out-of-band swaps update multiple elements from a single response. The server returns the primary content plus additional elements marked with hx-swap-oob. htmx swaps the primary content into hx-target, then processes each OOB element separately.","Use hx-select when you can't control the response format or need to strip wrapper elements. Use OOB swaps when you control the server and need to update multiple unrelated page sections."]},{"l":"Filtering Responses with hx-select","p":["The hx-select attribute takes a CSS selector and extracts matching content from the response before swapping."]},{"l":"When hx-select is Useful","p":["Consider a blog that returns full pages for SEO. When navigating via htmx, you want just the article content, not the header and footer:","The server returns the full page (header, navigation, article, footer), but htmx extracts only article.post-content and swaps that into #main-content."]},{"l":"Stripping Wrapper Elements","p":["If your partial view includes a wrapper you don't want:","Server returns:","Client extracts just the list:"]},{"l":"Complete hx-select Example","p":["Pages/Articles.cshtml:","Pages/Articles.cshtml.cs:","Pages/Shared/_ArticleFull.cshtml:","The client uses hx-select=.article-body to extract only the content div, leaving out the header and footer."]},{"l":"Out-of-Band Swaps","p":["Out-of-band (OOB) swaps update elements outside your hx-target. The server includes extra elements in the response marked with hx-swap-oob, and htmx processes them after the primary swap."]},{"l":"How OOB Works","p":["htmx sends request to server","Server returns primary content plus OOB elements","htmx swaps primary content into hx-target","htmx finds elements with hx-swap-oob attribute","For each OOB element, htmx finds matching element on page by ID","htmx swaps the OOB content into the matching element"]},{"l":"Basic OOB Pattern","p":["Page structure:","Add to cart button:","Server response includes OOB update:","The feedback message goes into #cart-feedback(the target). The cart count updates #cart-count in the header via OOB."]},{"l":"OOB Swap Strategies","p":["afterbegin","Append to matching element","beforeend","Behavior","Examples:","innerHTML","outerHTML","outerHTML:#other-id","Prepend to matching element","Replace a different element by ID","Replace innerHTML (same as true)","Replace innerHTML of matching element","Replace the entire matching element","The hx-swap-oob attribute accepts swap strategies:","true","Value"]},{"l":"Complete OOB Example: Task Management","p":["A task list where completing a task updates the list, completion count, and shows a toast notification.","Pages/Tasks.cshtml:","Pages/Tasks.cshtml.cs:","Pages/Shared/_TaskItem.cshtml:","Pages/Shared/_TaskToggleResponse.cshtml:","Pages/Shared/_TaskDeleteResponse.cshtml:","Toast CSS:"]},{"l":"Shopping Cart with Multiple OOB Updates","p":["A product page where adding to cart updates the cart count, shows confirmation, and updates stock display.","Pages/Product.cshtml:","Pages/Product.cshtml.cs:","Pages/Shared/_AddToCartSuccess.cshtml:"]},{"l":"Using hx-select-oob on the Trigger","p":["While hx-swap-oob goes in the response, hx-select-oob goes on the triggering element. It tells htmx which elements to treat as OOB from the response.","This is useful when you can't modify the server response but know it contains elements with IDs that should swap OOB:","The response might be:","htmx swaps #main-content into the target, then processes #notification-count and #user-status as OOB swaps."]},{"l":"Debugging OOB Swaps","p":["When OOB swaps don't work, check these common issues:"]},{"l":"1. Missing ID on Page Element","p":["The OOB element must have a matching ID on the page:"]},{"l":"2. ID Mismatch","p":["IDs are case-sensitive:"]},{"l":"3. Element Not in DOM","p":["If the target element is inside content that gets swapped first, it may not exist when OOB runs. Place OOB targets outside swap areas."]},{"l":"4. Using htmx Debug Mode","p":["Enable debug logging:","Check the console for OOB processing messages."]},{"l":"Accessibility Considerations"},{"l":"Announce Dynamic Updates","p":["Use aria-live for regions that update:"]},{"l":"Maintain Focus","p":["When updating content, avoid disrupting keyboard focus:"]},{"l":"Screen Reader Feedback","p":["For important updates, include screen-reader-only text:"]},{"l":"Summary","p":["This chapter covered scoped updates with htmx:","hx-select extracts specific content from responses using CSS selectors","hx-swap-oob in responses marks elements for out-of-band swapping","hx-select-oob on triggers specifies which response elements are OOB","OOB swap strategies include true, outerHTML, beforeend, afterbegin","Multiple OOB elements can update several page sections from one response","Toast notifications append to a container using hx-swap-oob=beforeend","Debugging requires matching IDs and htmx debug logging","OOB swaps let your server tell the full story of what changed, updating every affected element in a single response. This keeps your UI consistent without client-side state management or multiple requests."]},{"l":"Preview of Next Chapter","p":["Chapter 17 covers advanced form techniques with hx-params, hx-vals, and hx-validate. You will learn to control which parameters get sent, inject computed values into requests, and integrate client-side validation with server-side processing."]}],[{"l":"Form Enhancements with hx-params, hx-vals, and hx-validate","p":["Forms collect data. htmx submits that data without page reloads. But real-world forms need more control. You need to exclude fields from submission, inject values that aren't visible in the form, and validate input before it reaches the server. This chapter covers three htmx attributes that give you that control: hx-params filters which fields get sent, hx-vals injects additional data into requests, and hx-validate triggers HTML5 validation before submission.","These attributes work together with the form patterns from Chapter 11. Combined with server-side validation, they create forms that guide users through correct input while keeping your validation logic where it belongs: on the server."]},{"l":"Anti-Forgery Token Setup","p":["All POST form examples in this chapter require anti-forgery tokens. Configure htmx to include them automatically:","Pages/Shared/_Layout.cshtml:"]},{"l":"Filtering Parameters with hx-params","p":["The hx-params attribute controls which form fields are included in a request. By default, htmx sends all fields. With hx-params, you can include all, exclude specific fields, or send none."]},{"l":"hx-params Values","p":["Value","Behavior","*","Send all parameters (default)","none","Send no parameters","not fieldName","Send all except the named field","fieldName","Send only the named field","field1, field2","Send only these fields"]},{"l":"Multi-Step Form Example","p":["A wizard-style form where each step submits only its own fields:","Pages/Signup.cshtml:","Pages/Shared/_SignupStep1.cshtml:","Pages/Shared/_SignupStep2.cshtml:","Pages/Signup.cshtml.cs:"]},{"l":"Excluding Specific Fields","p":["Use hx-params=not fieldName to exclude fields:"]},{"l":"Sending No Parameters","p":["Use hx-params=none for actions that don't need form data:"]},{"l":"Injecting Values with hx-vals","p":["The hx-vals attribute adds extra name-value pairs to requests. These values don't appear in the form but get sent to the server alongside form fields."]},{"l":"Static Values","p":["For fixed values, use JSON syntax:","The server receives source=homepage and category=general as if they were form fields."]},{"l":"Values from Razor","p":["Inject server-side values:","Rendered HTML:"]},{"l":"Dynamic JavaScript Values","p":["For values computed at request time, use the js: prefix:","The js: prefix tells htmx to evaluate the object as JavaScript when the request fires."]},{"l":"Complete Feedback Form Example","p":["Pages/Feedback.cshtml:","Pages/Feedback.cshtml.cs:"]},{"l":"Combining hx-vals with Form Data","p":["Values from hx-vals merge with form fields:","The server receives: Quantity(from form) + productId+ source(from hx-vals)."]},{"l":"HTML5 Validation with hx-validate","p":["The hx-validate attribute triggers HTML5 form validation before htmx sends a request. If validation fails, the request is cancelled and the browser shows validation messages."]},{"l":"Basic Usage","p":["Without hx-validate, htmx would send the request even if fields are empty. With hx-validate, the browser prevents submission and shows \"Please fill out this field\" messages."]},{"l":"Validation Attributes","p":["Common HTML5 validation attributes work with hx-validate:"]},{"l":"When to Use hx-validate","p":["Use hx-validate on form submissions to catch obvious errors before hitting the server:","Don't use hx-validate on real-time validation triggers (like keyup). It would prevent the request from firing at all if the field is incomplete:"]},{"l":"Real-Time Server Validation","p":["For validation that requires server checks (username availability, email uniqueness), use hx-get with debounced triggers."]},{"l":"Username Availability Check","p":["Pages/Register.cshtml:","Pages/Register.cshtml.cs:","Pages/Shared/_RegisterErrors.cshtml:"]},{"l":"Key Patterns for Real-Time Validation","p":["1. Debounce with delay:","Waits 500ms after typing stops before sending the request.","2. Cancel in-flight requests:","If the user keeps typing, cancel the previous request and send a new one.","3. Show loading state:","Display a spinner while checking.","4. Target feedback area:","Put validation messages in a dedicated container."]},{"l":"Validation CSS"},{"l":"Combining All Three Attributes","p":["A profile editor that uses all three attributes:","Pages/Profile.cshtml:","Pages/Profile.cshtml.cs:"]},{"l":"Summary","p":["This chapter covered form enhancement attributes:","hx-params controls which fields are sent: *(all), none, not fieldName, or specific field names","hx-vals injects additional data using JSON syntax or js: prefix for dynamic values","hx-validate triggers HTML5 validation before htmx sends the request","Real-time validation uses hx-get with delay: trigger and hx-sync=this:replace","Server validation should always run on submit, even if client-side checks passed","These attributes give you fine control over form data while keeping validation logic on the server where it can access databases, enforce business rules, and stay consistent across all clients."]},{"l":"Preview of Next Chapter","p":["Chapter 18 covers drag-and-drop functionality with htmx and Hyperscript. You will learn to build sortable lists, kanban boards, and file upload zones that let users rearrange content with natural mouse and touch interactions."]}],[{"l":"Caching and History with hx-history and hx-history-elt","p":["The fastest request is the one you never make. If you have ever hit the back button on a web app and watched it reload a page you visited seconds ago, you know the frustration. That reload breaks your flow, wastes your time, and makes the app feel sluggish. This chapter shows you how htmx eliminates that pain by caching responses in the browser's history stack. With minimal effort, your Razor Pages can feel as fluid as a single-page app without the JavaScript complexity.","You have already seen how htmx handles form submissions, dynamic interactions, and server-driven updates. Now you can give users a smoother navigation experience by preserving state across page transitions. These features do more than improve performance. They let users move backward and forward through your app without losing their place or waiting for redundant server calls. This builds naturally on the scoped updates, real-time interactions, and Hyperscript techniques from earlier chapters.","We will start by examining how htmx manages browser history and caching. You will learn how to control caching behavior for specific elements, reducing server load while making your app feel more responsive. A content-heavy dashboard benefits from caching just as much as a multi-step workflow does. In both cases, intelligent caching dramatically improves the user experience.","By the end of this chapter, you will have the tools to create state-aware applications that feel fast and modern while keeping the simplicity of Razor Pages. Let us see how htmx puts the browser's built-in navigation features to work for you."]},{"l":"Understanding htmx History Caching","p":["Before we look at specific attributes and code, you need to understand how htmx handles history. When you use hx-push-url=true on a request, htmx automatically does two things: it updates the browser's URL, and it saves a snapshot of the current page content to a local cache. This cache lives in the browser's localStorage and holds the HTML content that was on the page before the navigation occurred.","When a user clicks the back button, htmx intercepts that navigation. Instead of making a new server request, it pulls the cached HTML from localStorage and restores it to the page. This restoration happens almost instantly because no network round-trip is required.","The key insight here is that htmx caches by default when you push URLs. The hx-history attribute exists primarily to opt out of this behavior, not to opt in. Setting hx-history=false tells htmx to skip caching for that particular element or request. This becomes important when you have sensitive content like personal information, checkout flows, or admin panels that should not persist in the browser's cache.","You can control how many pages htmx keeps in its history cache through configuration:","Setting this to zero disables history caching entirely. For most applications, the default works well, but you might increase it for apps where users frequently navigate back through many pages."]},{"l":"Making Back Feel Fast Again: History Management with hx-history","p":["In traditional server-rendered apps, clicking the back button typically reloads the entire page. Users lose form inputs, search results disappear, and any scroll position resets. This behavior is so common that many users avoid the back button altogether. With htmx, you can reclaim the back button and make it work the way users expect.","When hx-push-url=true is set on a request, htmx stores the current page content before swapping in the new response. If the user navigates back, htmx restores that stored content without hitting the server. The result feels instant.","Consider a user searching for products in your app. They browse results, click into a product detail page, then hit the back button expecting to see their search results. Without htmx history caching, the page reloads and the results vanish. With hx-push-url=true, the result list reappears immediately, exactly as they left it. No server call. No loading spinner. No frustration.","Here is a search form on a Search.cshtml page that demonstrates this pattern:","The hx-push-url=true attribute handles the caching work. It updates the browser URL with the search query and triggers htmx to cache the page state. When the user navigates away and returns, htmx restores the cached results.","On the server side, the handler returns a partial view:","The _SearchResults.cshtml partial renders the product list:","Notice that the product links use hx-target=#main-content rather than targeting the body. This scoped approach gives you more control over what gets replaced and avoids potential issues with scripts or styles in the document head.","When should you disable history caching? Use hx-history=false in these situations:","Checkout or payment pages where sensitive data should not persist","User profile or account settings pages","Admin panels with privileged information","Any content that becomes stale quickly and must be fresh on every view","This pattern keeps secure content out of the browser's localStorage while still updating the URL for bookmarking purposes."]},{"l":"Locking In the Experience: Retaining State with hx-history-elt","p":["The hx-history-elt attribute solves a specific problem: which element's innerHTML should htmx snapshot when saving to the history cache? By default, htmx snapshots the body element. This works for simple pages, but complex layouts often need more precision.","Place hx-history-elt on the container element whose content represents the \"main\" state of your page. When htmx takes a history snapshot, it captures the innerHTML of this element. When the user navigates back, htmx restores that specific content.","Consider a dashboard with a main content area and persistent navigation:","With hx-history-elt on #app-content, htmx only caches the main content area. The sidebar stays untouched, and the notifications panel can update independently without being overwritten by stale cached data.","Here is a tabbed interface that uses this pattern:","The Hyperscript on each button handles the active state: first it removes the .active class from all tab buttons, then adds it to the clicked button. This sequence ensures only one tab appears active at a time.","When the user clicks Tab 2, views its content, navigates to another page, and then hits back, htmx restores the entire #dashboard-content element including the active tab state and the tab content. The experience feels continuous rather than reset.","You can also preserve form input values by placing the form inside your history element:","When users apply filters, navigate to a product, and return, their filter selections and search text remain intact. This small detail eliminates the frustration of re-entering search criteria."]},{"l":"Speed in the Stack: Supercharging UX with History-Based Caching","p":["Performance extends beyond server response time to include how quickly your app responds to user actions. History caching gives you a performance boost without touching backend code. Instead of reloading content when a user navigates back, htmx serves the previous state from memory. The page appears instantly.","When users browse paginated content like search results or data tables, each page typically requires an hx-get request. Without caching, clicking into an item and returning to the list means another server request to reload the same data. With htmx history caching, the previous list view comes from the browser's cache instead. Users perceive a dramatic speed improvement.","Combine hx-push-url with hx-select to control exactly which parts of the response get stored:","The hx-trigger=load ensures the request fires when the element enters the DOM. The hx-select=#page-content tells htmx to extract only the #page-content portion from the server response. This scoped approach prevents caching headers, footers, or other page elements that should remain dynamic.","Your server handler returns a complete response, but htmx extracts only what you specified:","When users navigate through pages, each view gets cached. Hitting the back button cycles through those cached pages without server requests. The pagination feels as responsive as flipping through local content.","Test your caching behavior using browser developer tools. Open the Application tab and inspect localStorage to see what htmx has cached. You can also add htmx.logAll() to your JavaScript console to watch htmx events in real time, including history save and restore operations."]},{"l":"Designing for Memory: Best Practices with History and Performance","p":["History caching makes your app feel faster, but it requires thoughtful implementation. Cache the wrong content and users see stale data. Cache too much and you waste browser storage. Here are patterns that work well in production."]},{"l":"Isolate Dynamic Content","p":["Real-time elements like notification counts, shopping cart totals, or live status indicators should not live inside cached regions. Structure your layout to keep these elements outside the hx-history-elt container:","The cart count loads fresh on every page view while the main content benefits from caching."]},{"l":"Use hx-select to Scope Cached Responses","p":["When your server returns a full page but you only want to cache part of it, use hx-select:","The server returns both the product list and cart summary, but only #product-list gets extracted and cached."]},{"l":"Build Consistent Partials","p":["Razor Partials should return stable HTML structures regardless of request context. Avoid conditional wrappers that change the DOM structure:","Consistent structures ensure htmx can reliably cache and restore content without layout shifts or broken references."]},{"l":"Manage Focus for Accessibility","p":["When content restores from cache, users navigating via keyboard or screen reader need proper focus management. Use Hyperscript to restore focus after history restoration:","The htmx:historyRestore event fires after htmx restores cached content. The Hyperscript moves focus to the search input, orienting the user within the restored interface.","For screen reader users, include aria-live regions to announce dynamic updates:"]},{"l":"Handle Forms Carefully","p":["Forms inside cached regions retain their values when restored, which is usually what users want. CSRF tokens and other security-sensitive hidden fields can become stale though. Consider refreshing these on restoration:","This pattern ensures security tokens stay valid even when forms are restored from cache."]},{"l":"Test Navigation Thoroughly","p":["History-related bugs are subtle and vary by browser. Build a testing checklist:","Navigate forward through several pages","Use the back button to return through each page","Use the forward button to advance again","Verify scroll positions, form values, and active states at each step","Test with browser developer tools open to watch for console errors","Test on multiple browsers since history handling can differ","Use htmx debugging to trace history operations:","This logs only history-related events, making it easier to trace caching behavior."]},{"l":"Common Pitfalls and Solutions"},{"l":"Stale Data After Server Changes","p":["If server data changes while a user has cached content, they might see outdated information when navigating back. For critical data, consider adding a freshness check:","The htmx:historyRestore from:body trigger causes a fresh request whenever content is restored from history, ensuring users always see current data. Use this selectively since it negates the performance benefits of caching."]},{"l":"Cache Size Limits","p":["Browsers limit localStorage to around 5-10MB. If your pages are large or users navigate extensively, you might hit this limit. Monitor cache size and adjust historyCacheSize accordingly:"]},{"l":"URL Mismatch Issues","p":["Ensure your hx-get URLs match the pattern you want in the browser address bar. Inconsistent URLs can cause confusion when users bookmark or share links:","The hx-push-url can specify a different URL than hx-get, letting you maintain clean user-facing URLs while using Razor Pages handler routing internally."]},{"l":"Summary","p":["History caching transforms how users experience navigation in your Razor Pages application. Instead of reloading pages, htmx restores cached content instantly. Instead of losing form inputs and scroll positions, users return to exactly where they left off.","The key concepts to remember:","hx-push-url=true enables history caching automatically","hx-history=false disables caching for sensitive content","hx-history-elt specifies which element to snapshot","hx-select scopes which parts of the response get cached","Consistent HTML structures make caching reliable","Focus management maintains accessibility","Testing across browsers catches subtle issues","In the next chapter, we will explore hx-disable and hx-request for fine-grained control over when and how htmx makes requests. These tools complement history caching by letting you optimize request behavior and manage loading states."]}],[{"l":"Optimizing Requests with hx-disabled-elt, hx-request, and hx-sync","p":["Every click, every keystroke, every interaction in your application translates to a potential server request. Most of the time, that is exactly what you want. But what happens when users click a submit button five times because they are impatient? What happens when two requests race each other and the slower one overwrites fresher data? What happens when your API expects specific headers or timeout settings that htmx does not send by default?","These problems will find you eventually. The question is: do you have the tools to handle them?","This chapter shifts focus from visual interactivity to request behavior. You have already learned how to cache history, preserve state, and build responsive interfaces. Now you will learn how to control the requests themselves. Three htmx attributes give you that control: hx-disabled-elt prevents duplicate submissions by disabling elements during requests, hx-request configures timeout and credential settings, and hx-sync coordinates multiple requests to prevent race conditions.","By the end of this chapter, you will know how to build forms that cannot be double-submitted, configure requests for cross-origin authentication, and synchronize competing interactions so they do not corrupt your data. These are the details that separate amateur implementations from production-ready applications."]},{"l":"Preventing Double Submissions with hx-disabled-elt","p":["Users click buttons more than once. They do it when the network is slow. They do it when nothing appears to happen. They do it out of habit. Each extra click can trigger another request to your server, creating duplicate database entries, charging credit cards twice, or sending the same email multiple times.","The hx-disabled-elt attribute solves this problem by disabling specified elements while a request is in flight. When the request completes, htmx automatically re-enables the elements. The user sees immediate feedback that their action registered, and your server handles exactly one request.","Here is a feedback form that uses hx-disabled-elt to prevent duplicate submissions:","The find button[type='submit'] expression tells htmx to locate the submit button within the form and disable it during the request. You can also use simpler selectors:","Using this as the selector disables the element that triggered the request. This works when the button itself carries the htmx attributes.","The server-side handler stays simple:","Notice that the parameter name Message matches the form field name exactly. ASP.NET Core model binding is case-insensitive by default, but matching cases makes your code clearer."]},{"l":"Disabling Multiple Elements","p":["Sometimes you need to disable more than just the submit button. A form might have multiple action buttons, or you might want to disable the entire input area to prevent edits during submission:","The comma-separated selector disables all inputs and buttons within the controls container. Users cannot modify the promo code or click either button while the order processes."]},{"l":"Combining with Visual Feedback","p":["Disabling elements prevents duplicate submissions, but users also need visual confirmation that something is happening. Combine hx-disabled-elt with hx-indicator for a complete solution:","The htmx-indicator class hides the spinner by default. When a request starts, htmx adds the htmx-request class to the element, and your CSS can reveal the spinner:","Now users see the button dim and display \"Processing...\" while the payment request completes. They cannot click again, and they know the system received their action."]},{"l":"Configuring Request Behavior with hx-request","p":["The hx-request attribute lets you configure how htmx sends requests. Unlike what you might assume, this attribute focuses on three specific settings: timeout duration, credential handling, and whether to include htmx-specific headers."]},{"l":"Setting Request Timeouts","p":["By default, htmx does not enforce a timeout on requests. If your server hangs, the user waits indefinitely. The timeout option lets you set a maximum wait time in milliseconds:","This request will abort after 30 seconds if the server has not responded. You can handle the timeout on the client with htmx events:","The Hyperscript listens for the htmx:timeout event and displays a friendly message when the request exceeds the time limit."]},{"l":"Handling Credentials for Cross-Origin Requests","p":["When your Razor Pages application calls APIs on different domains, browsers apply strict rules about cookies and authentication headers. The credentials option controls whether htmx includes credentials with cross-origin requests:","Setting credentials to true is equivalent to setting credentials: 'include' on a fetch request. The browser will send cookies and HTTP authentication headers to the cross-origin server.","Your server must be configured to accept credentialed requests. In ASP.NET Core, this means setting up CORS properly:","Without the AllowCredentials() call and a specific origin (not wildcard), the browser will block the credentialed request."]},{"l":"Suppressing htmx Headers","p":["Every htmx request includes several custom headers: HX-Request, HX-Trigger, HX-Target, and others. These headers help your server understand the request context. In some situations, you might want to suppress them:","Setting noHeaders to true prevents htmx from adding its custom headers. This can be useful when calling third-party APIs that might reject requests with unfamiliar headers, or when you want requests to appear as standard browser requests rather than htmx-initiated ones."]},{"l":"Combining Options","p":["You can combine multiple options in a single hx-request attribute:","This request will timeout after 10 seconds, include credentials, and omit htmx headers."]},{"l":"Adding Custom Headers with hx-headers","p":["When you need to send custom headers with your requests, use hx-headers rather than trying to configure them through hx-request. This attribute accepts a JSON object of header names and values:","The server receives the custom header and can validate it:","The CryptographicOperations.FixedTimeEquals method prevents timing attacks by comparing strings in constant time. Never use simple string equality for security tokens."]},{"l":"Dynamic Headers","p":["For headers that change based on user state or page context, you can set them dynamically using JavaScript:","The htmx:configRequest event fires before each request, allowing you to modify headers, parameters, or other request details."]},{"l":"Security Considerations","p":["Placing tokens directly in HTML attributes means anyone can view them by inspecting the page source. For truly sensitive operations:","Use server-side sessions and cookies rather than client-visible tokens","Implement proper authentication middleware","Consider using hx-vals to send data that gets validated server-side against the user's session","This approach embeds the anti-forgery token in a header rather than a hidden field, which some security configurations require."]},{"l":"Coordinating Competing Requests with hx-sync","p":["Race conditions happen when multiple requests compete and the results arrive out of order. Picture a search box that sends a request on every keystroke. The user types \"cat\", generating requests for \"c\", \"ca\", and \"cat\". If the \"ca\" response arrives after the \"cat\" response, the user sees results for \"ca\" instead of their complete query.","The hx-sync attribute prevents these problems by coordinating requests from related elements. It specifies a synchronization strategy that determines how competing requests should be handled."]},{"l":"Basic Synchronization Strategies","p":["The hx-sync attribute takes two parts: a CSS selector identifying the synchronization scope, and a strategy keyword.","Drop Strategy- Ignore new requests while one is in flight:","With drop, if a request is already running when a new one would start, the new request is simply ignored. This prevents request pileup but might miss the user's final input.","Abort Strategy- Cancel the in-flight request and start the new one:","With abort, the previous request is cancelled when a new one starts. This ensures users always see results for their most recent input. For search boxes, this is usually the right choice.","Replace Strategy- Same as abort, the default behavior:","The replace strategy is the default and behaves identically to abort. Explicitly stating it can make your intent clearer.","Queue Strategies- Process requests in order:","Queue strategies process requests sequentially. Options include:","queue first- Queue the first request, drop subsequent ones","queue last- Queue only the most recent request","queue all- Queue every request (use with caution)"]},{"l":"Synchronizing Multiple Elements","p":["The CSS selector in hx-sync determines what scope to synchronize against. This lets you coordinate requests across related elements:","All three filter controls synchronize against the same form. If a user changes the category while a search request is running, the search request aborts and the category request proceeds. This ensures the product list always reflects the most recent filter state."]},{"l":"Server-Side Handler for Synchronized Requests","p":["The handler receives all filter parameters and returns the filtered results:","Because requests are synchronized on the client, you do not need to worry about race conditions corrupting the displayed data. The UI always reflects the most recent user selection."]},{"l":"Combining Attributes for Production-Ready Forms","p":["Real forms often need multiple optimizations working together. Here is a complete example that combines hx-disabled-elt, hx-sync, hx-indicator, and proper validation:","This form:","Disables all inputs and the button during submission","Aborts any in-flight request if the user somehow triggers another","Shows a loading indicator in the button","Uses HTML5 validation attributes for client-side checks","The server handler:"]},{"l":"Debugging Request Issues","p":["When requests behave unexpectedly, htmx provides tools to understand what is happening."]},{"l":"Browser Developer Tools","p":["Open the Network tab in your browser's developer tools. Filter by XHR/Fetch to see only AJAX requests. For each request, examine:","Headers: Verify custom headers are present and correct","Payload: Confirm form data is being sent as expected","Timing: Identify slow requests that might need timeouts","Response: Check that the server returns valid HTML"]},{"l":"htmx Logging","p":["Enable htmx logging to see events in the console:","This outputs every htmx event, which can be noisy but thorough. For targeted debugging, listen for specific events:"]},{"l":"Common Issues and Solutions","p":["Problem: Button does not re-enable after request completes. Solution: Verify the request actually completes. Check for JavaScript errors. Ensure hx-disabled-elt selector matches the element.","Problem: Requests still race despite hx-sync. Solution: Confirm all related elements use the same sync scope. The CSS selector must resolve to the same element for coordination to work.","Problem: Custom headers not appearing in requests. Solution: Check for typos in hx-headers JSON. Verify the JSON is valid. Some proxies strip non-standard headers.","Problem: Credentials not sent to cross-origin API. Solution: Ensure both hx-request='{credentials: true}' on the client and AllowCredentials() in server CORS configuration."]},{"l":"Summary","p":["Request optimization separates functional applications from professional ones. Users expect buttons to work exactly once. They expect the most recent action to win. They expect the application to handle edge cases gracefully.","The three attributes covered in this chapter give you that control:","hx-disabled-elt prevents duplicate submissions by disabling elements during requests","hx-request configures timeout, credentials, and header behavior","hx-sync coordinates competing requests to prevent race conditions","Use hx-headers when you need custom headers. Combine these attributes with hx-indicator for visual feedback. Test thoroughly with browser developer tools.","In the next chapter, we will explore advanced performance techniques including lazy loading, request batching, and strategies for minimizing latency in complex Razor Pages applications."]}],[{"l":"Performance Optimization","p":["Performance is more than speed. It is responsiveness, stability, and fluidity at every interaction. After building a solid foundation with htmx and Razor Pages, after layering in forms, tabs, modals, history management, and drag-and-drop interactivity, you need to look under the hood and refine how everything runs. This chapter focuses on smart, thoughtful enhancements that make your app feel fast without burning through server resources or exhausting browser patience.","You have seen how htmx handles interactions by communicating directly with the server using small, focused HTTP requests. But as your UI grows more dynamic and your users become more active, you will notice where optimizations matter most. Knowing when to prevent unnecessary requests, when to cache previously loaded content, and how to coordinate competing interactions can turn a sluggish interface into something satisfying to use.","This chapter explores patterns and techniques for improving performance from both client and server perspectives. You will learn how to reduce network chatter, streamline rendering, and prevent the classic pitfalls of excessive or redundant requests. You will also see how to synchronize competing requests so they do not corrupt your data or confuse your users.","Before moving into building a real-world dashboard in the next chapter, this chapter serves as your final checkpoint. It is where you tighten the bolts, polish the engine, and make sure the interactive experience you have built runs at its best."]},{"l":"Smart Requests, Smooth Experience: Reducing Load the Right Way","p":["When htmx makes it easy to fetch and swap content with just a few attributes, you will be tempted to use it everywhere. That temptation is part of its appeal. But unintentional overuse can silently degrade performance. One of the most common pitfalls in growing htmx applications is triggering more requests than necessary. Search boxes firing on every keystroke, buttons clicked repeatedly in quick succession, filters that race each other and arrive out of order: these inefficiencies add up fast, especially as your user base grows.","A good starting point for reducing server load is understanding where redundant or excessive requests happen. Dynamic search inputs are a frequent culprit. Developers often bind hx-get to keyup events without any delay, resulting in a flood of server requests as users type. This creates strain on your backend and jittery UX as responses race to update the DOM, sometimes arriving out of order.","Consider a search form where results appear as the user types. A naive implementation might look like this:","Every single keystroke fires a request. If your user types quickly, that could mean 10 or more server calls in just a few seconds. The solution is throttling. Adding delay:500ms to hx-trigger introduces a half-second pause after typing stops before firing the request. Combined with changed, which ensures it only triggers if the value has actually changed, this drastically cuts the number of requests:","This simple change alone can reduce server requests by 80 to 90 percent in many cases. Throttling and debouncing are foundational patterns for interactive elements that respond to rapid user input. While htmx handles some of this internally, explicitly controlling trigger behavior with delay settings gives you more predictable and scalable performance.","On the server side, your Razor Page handler stays lean:","The _SearchResults.cshtml partial returns a simple list of results, allowing htmx to update the UI efficiently without loading or redrawing anything unrelated.","By optimizing when and how requests are sent, you help your server operate more efficiently and deliver a smoother experience to users. As your application scales, these adjustments make the difference between an app that groans under traffic and one that handles it with grace."]},{"l":"Preventing Race Conditions with hx-sync","p":["Debouncing helps reduce request volume, but it does not solve every problem. What happens when a user changes a dropdown while a previous request is still in flight? What if they click a button twice before the first response arrives? These race conditions can corrupt your UI by displaying stale data or applying updates in the wrong order.","The hx-sync attribute coordinates requests from related elements, ensuring they do not compete in destructive ways. It specifies a synchronization scope and a strategy for handling conflicts."]},{"l":"Abort Strategy for Search Inputs","p":["For search boxes and filters, the abort strategy cancels any in-flight request when a new one starts:","With hx-sync=this:abort, if the user types \"cat\" while a request for \"ca\" is still pending, the \"ca\" request gets cancelled. The results will always reflect the most recent input, never an outdated intermediate state."]},{"l":"Drop Strategy for Expensive Operations","p":["For operations that should not be interrupted, the drop strategy ignores new requests while one is running:","If the user clicks while a report is generating, the second click is ignored entirely. Combined with hx-disabled-elt to visually disable the button, this creates a foolproof interaction that cannot produce duplicate reports."]},{"l":"Synchronizing Multiple Elements","p":["When several elements can trigger requests that update the same target, synchronize them against a common ancestor:","All three controls synchronize against #product-filters. If a user changes the category while a search request is running, the search request aborts and the category request proceeds. The product list always reflects the most recent user action.","The server handler receives all filter parameters:"]},{"l":"On-Demand Loading: Lazy Loading for Speed and Sanity","p":["Lazy loading defers fetching content until it is actually needed. Instead of overwhelming the browser and backend by loading everything up front, you spread the work across the user's session. This approach improves perceived performance and reduces bandwidth usage, which matters most when dealing with large datasets, media-heavy pages, or sections hidden until scrolled into view.","htmx makes lazy loading almost effortless using hx-get combined with hx-trigger=revealed. The revealed trigger fires when an element becomes visible in the viewport. You can delay loading sections of your page until the user scrolls down to them, reducing initial page load time significantly.","Suppose you have a report with several data tables, and only the first one is visible when the page loads. Rather than load all of them at once, lazy load the others as the user scrolls:","On the server side:","The _SalesTable.cshtml partial renders the table. With this setup, the placeholder div swaps out with actual content once it becomes visible in the browser. The interaction feels smooth without blocking initial page load."]},{"l":"Infinite Scrolling","p":["You can extend lazy loading to create infinite scrolling. Each batch of content includes a loader for the next batch at the bottom:","The server sends both content and the next loader. Users see endless scrolling without overwhelming the page:","Taking one extra record lets you determine if more content exists without a separate count query."]},{"l":"Lazy Loading Images","p":["For media-heavy pages, wrap images in containers that load actual markup only when visible:","The server returns the actual image tag:","This reduces the number of active image requests on initial load, giving users a faster and more responsive browsing experience."]},{"l":"History Caching for Instant Back Navigation","p":["When users click the back button, they expect instant results. Without caching, htmx would need to re-fetch content from the server. History caching stores previously loaded content and restores it immediately during navigation.","When you use hx-push-url=true, htmx automatically caches the current page state before navigation. The hx-history-elt attribute specifies which element should be snapshotted. Place it on the container whose content represents your page's main state:","The hx-history-elt attribute on #main-content tells htmx to snapshot that element's innerHTML when the URL changes. When users navigate back, htmx restores the cached content instantly without a server request."]},{"l":"When to Disable History Caching","p":["Some content should not be cached. Sensitive information, rapidly changing data, or personalized content might become stale or inappropriate to restore. Use hx-history=false to exclude specific requests from caching:","This still updates the URL but does not cache the response. Navigating back will trigger a fresh server request."]},{"l":"Configuring Cache Size","p":["htmx stores history in localStorage with a default limit of 10 pages. Adjust this based on your application's needs:","Set it to zero to disable history caching entirely while keeping URL updates functional."]},{"l":"Out-of-Band Updates for Complex Interactions","p":["Sometimes a single user action needs to update multiple unrelated parts of the page. A form submission might need to refresh a data table, update a notification count, and show a status message. Making three separate requests wastes bandwidth and creates timing issues.","Out-of-band (OOB) updates let you include multiple fragments in a single response. htmx swaps the primary content into the target, then processes any elements marked with hx-swap-oob=true and swaps them into matching elements elsewhere on the page.","Suppose submitting a support ticket should update the ticket list, notification badge, and show a confirmation message:","Your server response includes the primary content plus OOB fragments:","Or using a partial view that includes OOB elements:","htmx processes the response as follows:","Swaps the primary content (everything before the first OOB element) into #ticket-list","Finds #notification-badge in the current page and replaces it with the OOB version","Finds #status-message in the current page and replaces it with the OOB version","This pattern keeps your interactions efficient while handling complex UI updates in a single round trip."]},{"l":"Server-Side Performance for htmx Endpoints","p":["Client-side optimizations only go so far. Your server needs to respond quickly with minimal payloads for htmx to feel fast."]},{"l":"Return Minimal HTML Fragments","p":["htmx endpoints should return only the HTML needed for the swap. Avoid returning full page layouts:"]},{"l":"Enable Response Compression","p":["ASP.NET Core can compress responses, reducing transfer size for HTML fragments:"]},{"l":"Cache Partial View Results","p":["For content that does not change frequently, cache the rendered output:"]},{"l":"Add Timing Headers for Debugging","p":["Include server timing information in responses to help identify slow endpoints:","Browser developer tools display these timings in the Network tab, making performance issues visible during development."]},{"l":"Debugging htmx Performance","p":["When requests behave unexpectedly or performance degrades, htmx provides tools to understand what is happening."]},{"l":"Enable Logging","p":["The simplest debugging approach is enabling htmx logging:","This outputs every htmx event to the console. For targeted debugging, listen for specific events:"]},{"l":"Monitor Network Activity","p":["Your browser's Network tab reveals:","Which requests htmx is firing","Request frequency (are triggers too aggressive?)","Response sizes (are you returning too much HTML?)","Timing breakdowns (where is time being spent?)","Filter by XHR/Fetch to see only AJAX requests and hide static assets."]},{"l":"Common Performance Issues","p":["Problem: Search fires too many requests. Solution: Add delay:300ms to debounce and hx-sync=this:abort to cancel stale requests.","Problem: Page feels slow despite fast server responses. Solution: Check if you are returning too much HTML. Use browser paint profiling to identify rendering bottlenecks.","Problem: Back button triggers server requests instead of using cache. Solution: Verify hx-push-url is set and hx-history-elt is on the correct container element.","Problem: Multiple clicks create duplicate database entries. Solution: Add hx-disabled-elt to disable buttons during requests and hx-sync=this:drop to ignore repeated clicks.","Problem: Filters update with stale data after rapid changes. Solution: Synchronize all filter elements with hx-sync against a common ancestor using the abort strategy."]},{"l":"Summary","p":["Performance optimization with htmx combines several complementary techniques:","Debouncing reduces request volume by waiting for user input to settle","hx-sync prevents race conditions by coordinating competing requests","Lazy loading defers content fetching until elements become visible","History caching restores previously loaded content instantly during navigation","Out-of-band updates handle complex multi-element updates in single responses","Server optimizations ensure fast responses with minimal payloads","These patterns work together. A well-optimized htmx application debounces rapid input, synchronizes related controls, lazy loads heavy content, caches navigation states, and returns minimal server responses. The result is an interface that feels immediate and reliable, even as complexity grows.","In the next chapter, you will build a dynamic, data-rich dashboard using htmx and Razor Pages. You will apply these performance techniques across interactive charts, live updates, and admin panels to see how clean and responsive your applications can be when performance is part of the plan from the start."]}],[{"l":"Htmx extensions"}],[{"l":"Author Bio","p":["Chris Woodruff Presenting","Chris Woodruff, also known as Woody, is an Architect at Real Times Technologies and brings nearly three decades of industry expertise, having launched his career before the first .COM boom. Renowned for his contributions to software development and architecture, Woody is a regular speaker at international conferences, where he shares his deep knowledge on topics ranging from database development to APIs and web technologies.","A dedicated mentor, Woody thrives on guiding fellow developers and enhancing their skills through his talks, written work, and digital content. He co-hosts the popular “Breakpoint Show” podcast and YouTube channel, which he uses to connect with and educate the tech community. He is also writing a book covering network programming with C# and .NET.","Woody’s interests extend beyond his professional life, adding a personal touch to his character. He is a passionate bourbon enthusiast, often embarking on adventures along the Bourbon Trail in search of unique finds to savor and share with friends. Family time is a cherished part of his life, and he often shares insights from his professional journey on his blog at https://woodruff.dev. To stay updated on his latest projects and adventures, follow him on BlueSky at https://bsky.app/profile/woodruff.dev or Mastodon at https://mastodon.social/@cwoodruff, where he shares his thoughts and experiences, fostering a sense of connection with his audience."]},{"l":"Contact Info","p":["Email - chris@woodruff.dev","WhatsApp - https://wa.me/16167246885","GitHub - https://github.com/cwoodruff"]}],[{"l":"Updates and Corrections","p":["I want to thank every reader who took the time to share their feedback and corrections on my book. Your insights and meticulous attention to detail have helped enhance the work's quality and enriched the reading experience for others. It's through your engagement and thoughtful contributions that the book has evolved and improved. Thank you for your invaluable support and for being an integral part of this journey. Your feedback is genuinely appreciated.","Date","Chapter","Section","Acknowledgement","Notes","17 February 2025","2","Adding htmx to an ASP.NET Core 9 Razor Pages Project","/n/DenverBob","fixed the burron htmx to call the handler"]}]]