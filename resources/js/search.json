[[{"l":"ASP.NET Core Reimagined with htmx Book","p":["Have questions or feedback about the book? My email is cwoodruff@live.com.","For the source code for the book, visit the book's GitHub repo -- htmx-razor-workshop","To find translations, please check out the Translations page."]}],[{"l":"Dedication"}],[{"l":"Epigraph"}],[{"l":"Acknowledgments","p":["This is a basic page, with only a title and some text content."]}],[{"l":"Forward","p":["This is a basic page, with only a title and some text content."]}],[{"l":"Preface","p":["This is a basic page, with only a title and some text content."]}],[{"l":"Translations","p":["Language","Author","Notes","URL","Chinese","Spanish","French","Japanese","Swedish"]}],[{"l":"1"},{"l":"Why htmx with ASP.NET Core 9 Razor Pages?","p":["Web development has evolved significantly over the past decade, shifting from server-rendered applications to JavaScript-heavy frontends that rely on client-side frameworks like React, Angular, and Vue. However, these solutions often introduce excessive complexity, forcing developers to juggle state management, bundlers, and frontend dependencies.","With the rise of htmx, many developers are rediscovering the power of server-side rendering while maintaining dynamic interactivity. htmx enhances HTML, allowing it to handle interactions that traditionally require JavaScript, offering a more straightforward way to create fast, interactive, and maintainable web applications. Unlike frontend-heavy frameworks, which offload rendering and logic to the client, htmx enables a seamless experience by keeping the logic on the server and sending only the necessary updates to the client. This means developers can build highly interactive applications without the overhead of managing complex client-side code.","If you're an ASP.NET Core developer working with Razor Pages, htmx presents an efficient alternative to client-side frameworks. It enables dynamic updates with minimal JavaScript, and integrating it into your ASP.NET Core 9 Razor Pages applications is a straightforward process. This book will guide you through from basic concepts to advanced interactivity, ensuring that by the end, you'll be comfortable building fully interactive, server-driven applications that remain performant and scalable without relying on a heavy frontend framework."]},{"l":"The Power of Simplicity in Web Development","p":["One of the biggest challenges modern developers face is managing complexity. Single-page applications (SPAs) have gained popularity due to their ability to provide smooth, interactive user experiences. However, these applications often come at a cost—higher development complexity, performance bottlenecks, and increased maintenance burdens. The need for APIs, state management, and extensive client-side JavaScript can make projects challenging to scale and debug.","htmx challenges this paradigm by offering a return to simplicity. Instead of shifting rendering responsibilities to the client, htmx keeps rendering on the server and uses lightweight AJAX requests to update specific parts of the page. This approach reduces unnecessary JavaScript, improves performance, and makes applications easier to develop and maintain."]},{"l":"What is htmx?","p":["htmx is a lightweight JavaScript library that extends HTML's capabilities, allowing it to make HTTP requests and dynamically update the page without requiring JavaScript. Instead of writing JavaScript to handle AJAX interactions, developers can use htmx’s HTML attributes to perform tasks like sending HTTP requests, updating the DOM, and handling events.","For example, consider a simple interaction where a user clicks a button to load a message dynamically:","In this example, clicking the button sends an HTTP GET request to the /hello endpoint. The response from the server replaces the content inside the div id=message element, all without needing any JavaScript.","This declarative approach makes it incredibly easy to build dynamic applications while keeping HTML and server logic cleanly separated."]},{"l":"Why Use htmx with Razor Pages?","p":["Razor Pages already provides a structured, server-rendered development model, but traditional implementations often require full-page reloads or custom JavaScript for interactivity. By integrating htmx, developers can enhance their applications while reducing complexity, leading to a more efficient and effective development process.","A few key advantages of htmx include:","Eliminates JavaScript complexity– No need for frontend frameworks or extensive JavaScript.","Enhances performance– Updates only necessary parts of the page instead of reloading everything.","Simplifies backend logic– Keeps interactions on the server, making debugging easier.","Leverages server-side security– Keeps application state and logic on the backend rather than the client."]},{"l":"Real-World Use Cases","p":["htmx is particularly useful in scenarios where minimal JavaScript is preferred and seamless interactions are essential."]},{"l":"Form Submissions","p":["Forms are a fundamental part of most web applications, and htmx makes handling them straightforward. Instead of requiring JavaScript to process form submissions, htmx can handle the interaction declaratively:","On the server, the Razor Page handler processes the request and returns the response:","The result is dynamically updated without reloading the entire page, leading to a more seamless user experience."]},{"l":"Dynamic Content Loading","p":["Another common use case for htmx is dynamically loading content without a full-page refresh. For instance, a user might want to open a modal form without navigating to another page. Instead of using JavaScript to load content dynamically, htmx can handle it:","When the button is clicked, htmx fetches the modal content from the server and injects it into the designated container. This makes building interactive interfaces much simpler than manually manipulating the DOM with JavaScript."]},{"l":"Performance and Scalability Benefits","p":["By reducing unnecessary JavaScript execution, htmx significantly improves performance. Since interactions are managed on the server, applications benefit from:","Faster initial load times since there’s no need for heavy JavaScript frameworks.","Improved SEO since content is server-rendered and immediately available to search engines.","More maintainable code by keeping logic in Razor Pages rather than splitting it between frontend and backend.","Moreover, htmx can alleviate the burden of complex state synchronization between frontend and backend, reducing API load by only requesting and updating what’s necessary, rather than fetching full-page responses."]},{"l":"Conclusion","p":["htmx represents a shift back to the simplicity of server-rendered applications while maintaining interactivity. When combined with ASP.NET Core 9 Razor Pages, it provides an elegant way to build applications that are efficient, scalable, and easy to maintain. This book will explore how htmx can enhance your development workflow while keeping your applications lightweight and fast.","As we move forward, we will dive deeper into setting up a robust development environment and learn how to integrate htmx seamlessly into your projects."]}],[{"l":"2"},{"l":"Setting Up Your Development Environment","p":["The goal is to help you build a solid development environment for htmx in ASP.NET Core 9. This will ensure a smooth workflow and allow you to focus on building interactive web applications without unnecessary distractions. In this chapter, we will guide you through the process of installing .NET 9, setting up an ASP.NET Core Razor Pages project, adding htmx to the project, and configuring tools for an efficient development workflow."]},{"l":"Installing ASP.NET Core 9 and Required Tools","p":["The first step in setting up your environment is installing .NET 9. Microsoft provides an official .NET SDK that includes everything needed to build and run ASP.NET Core applications. You can download the latest SDK from the secure and official .NET website. Once installed, open a terminal or command prompt and verify the installation by running:","If the command returns a version number starting with 9., your installation was successful. Next, let’s create a new Razor Pages project to use with htmx. Run the following commands:","This command initializes a basic Razor Pages project and starts a development server at https://localhost:5001/. Now, we are ready to integrate htmx."]},{"l":"Adding htmx to an ASP.NET Core 9 Razor Pages Project","p":["To use htmx, you must include its JavaScript file in your project. The easiest way to do this is by linking to the htmx CDN inside your _Layout.cshtml file. Open Pages/Shared/_Layout.cshtml and add the following inside the head tag:","Alternatively, if you prefer to host the file locally, download htmx.min.js from the official htmx GitHub repo and place it inside the wwwroot/js/ folder. Then, update _Layout.cshtml to reference it locally:","To confirm that htmx is working correctly, create a simple button that triggers an AJAX request when clicked. Add the following to Pages/Index.cshtml:","Now, modify Pages/Index.cshtml.cs to handle the request and return a response:","Run your application and click the button. If \"Hello, htmx!\" appears in the #message div without a full page reload, congratulations! htmx is successfully integrated into your Razor Pages project."]},{"l":"Configuring a Robust Development Workflow","p":["A well-structured project is easier to maintain and allows for smooth development. Organizing Razor Pages into logical folders keeps things clean. Your project structure should look something like this:","Hot-reload is a valuable feature in ASP.NET Core that automatically applies changes without restarting the server. This is particularly useful when working with Razor Pages. To enable hot-reload, start your application using:","This command monitors file changes and refreshes the application automatically. Additionally, debugging htmx requests is straightforward using browser developer tools. Open your browser's developer console and inspect network requests to see how htmx interacts with your server.","When working with htmx, the HX-Request header helps differentiate between standard and htmx-triggered requests. You can check this in your backend code to return different responses depending on whether the request originated from htmx:","Version control is crucial for any project. To initialize a Git repository, navigate to your project directory and run:","For Razor Pages projects, a typical .gitignore file should exclude compiled binaries and user-specific files. Here's an example:"]},{"l":"Conclusion","p":["With your development environment set up to perfection, you are now fully prepared to embark on the journey of building interactive web applications with htmx and ASP.NET Core 9 Razor Pages. Having .NET installed, a Razor Pages project initialized, and htmx integrated, you are now ready to explore the world of dynamic, interactive applications. In the next chapter, we will delve into the core features of htmx and how to utilize them to create dynamic content updates in Razor Pages"]}],[{"l":"First Steps with htmx","p":["You can find the source examples for this chapter here.","The way we build web applications is changing. Client-side JavaScript frameworks dominate modern development, yet they often introduce complexity that many projects do not need. State management, bundlers, elaborate frontend tooling: these concerns consume development time and add maintenance burden. htmx takes a different path. It enhances HTML's native capabilities, allowing you to craft interactive experiences with minimal JavaScript. This chapter guides you through integrating htmx with ASP.NET Core Razor Pages to build dynamic web applications without the overhead of complex frontend frameworks.","By focusing on server-driven interactions, htmx makes it possible to create fluid user experiences while keeping your application logic where it belongs: on the server. It uses declarative attributes to handle AJAX requests, event-driven interactions, and form submissions. Your markup stays clean and understandable. When combined with Razor Pages, htmx offers a way to blend server-side rendering with targeted interactivity, making your applications efficient and maintainable.","This chapter takes you from fundamental principles to fully functional Razor Pages. You will learn to dynamically fetch, update, and submit content without full page reloads. We cover everything from using hx-get and hx-post for data retrieval and submission to debugging common issues and fine-tuning request behaviors. By the end, you will be ready to build interactive web applications that feel modern while remaining easy to maintain."]},{"l":"Adding htmx to Your Razor Pages Project","p":["Before writing any htmx code, you need to include the library in your project. The simplest approach is adding a script tag to your layout file.","Open Pages/Shared/_Layout.cshtml and add the htmx script before the closing /body tag:","Alternatively, you can download htmx and serve it locally:","With htmx loaded, every page in your application can use htmx attributes. No build step required. No npm packages to manage. Just one script tag and you are ready to go."]},{"l":"Understanding the Basics of htmx in Razor Pages","p":["htmx allows you to send AJAX requests using simple HTML attributes. The two most fundamental ones are:","hx-get: Makes an HTTP GET request to fetch content from the server","hx-post: Sends a POST request to submit data to the server","Here is a basic example:","When the button is clicked, htmx sends an asynchronous GET request to /Index?handler=Hello. The server processes the request and returns HTML. htmx then injects that HTML into the #message div. No page reload. No JavaScript to write. The interaction happens through HTML attributes alone."]},{"l":"The Handler Naming Convention","p":["In Razor Pages, the handler query parameter maps to methods in your PageModel. The naming convention follows this pattern: On{HttpMethod}{HandlerName}().","handler=Hello with a GET request calls OnGetHello()","handler=Submit with a POST request calls OnPostSubmit()","No handler parameter with GET calls OnGet()","This convention keeps your server-side code organized while giving htmx clear endpoints to call."]},{"l":"The Request-Response Cycle with htmx","p":["htmx works like a normal browser request but without a full-page reload. Here is how a typical request-response cycle flows:","User interacts with an element (clicks a button, types in an input, submits a form)","htmx sends an AJAX request to the specified endpoint","The Razor Page handler processes the request and returns partial HTML","htmx updates the target element with the returned HTML","This means you can build dynamic experiences while keeping your application logic centralized in your PageModel classes. The server remains in control. The client handles presentation."]},{"l":"Examining How Partial Updates Work","p":["Unlike traditional AJAX where you manually manipulate the DOM, htmx automatically swaps the response into a specified target. Two attributes control this behavior:","hx-target determines which element will be updated","hx-swap decides how the response is inserted","The hx-swap attribute accepts several values:","innerHTML(default): Replaces the target's inner content","outerHTML: Replaces the entire target element","beforebegin: Inserts before the target element","afterbegin: Inserts inside the target, before its first child","beforeend: Inserts inside the target, after its last child","afterend: Inserts after the target element","By returning only the relevant snippet from the server, you make updates feel instant and keep bandwidth usage low."]},{"l":"Creating Your First Interactive Razor Page","p":["Let us create a Razor Page that dynamically loads a message when a button is clicked.","Pages/Index.cshtml","Pages/Index.cshtml.cs","When you click the button, htmx calls OnGetMessage(), which returns a paragraph of HTML. htmx injects this into the #message div. The page does not reload. The URL does not change. Only the targeted element updates."]},{"l":"Understanding hx-trigger for Event-Driven Interactions","p":["By default, htmx triggers requests on click events for buttons and links, and on submit events for forms. You can customize this behavior with hx-trigger:","This input field triggers a search request when the user types. The trigger expression breaks down as follows:","keyup: Fire on keyup events","changed: Only fire if the value actually changed","delay:500ms: Wait 500 milliseconds after the last keyup before firing","This debouncing prevents flooding your server with requests on every keystroke. The user types, pauses briefly, and then the request fires. It feels responsive without being wasteful."]},{"l":"Implementing Dynamic Content Updates","p":["Let us modify our earlier example to display different content each time the button is clicked.","Pages/Index.cshtml.cs","Now each click returns a different message from the array. The Random.Shared property provides a thread-safe random instance that you can use across requests without creating new instances."]},{"l":"Handling Form Submissions with htmx","p":["Forms are where htmx truly shines. Traditional form submissions reload the entire page. With htmx, you submit data and update only what needs to change."]},{"l":"Setting Up Anti-Forgery Token Handling","p":["ASP.NET Core Razor Pages require anti-forgery tokens for POST requests. Before creating forms, configure htmx to include this token automatically.","Add this script to your _Layout.cshtml after the htmx script:","This event listener runs before every htmx request and adds the anti-forgery token to the request headers."]},{"l":"Using hx-post to Submit Forms","p":["With token handling configured, you can create forms that submit without page reloads:","Pages/Index.cshtml","Pages/Index.cshtml.cs","When the form submits, htmx sends a POST request to OnPostSubmit(). The handler validates the input and returns HTML that htmx injects into #result. The form stays on the page. The user sees immediate feedback."]},{"l":"Appending Responses Instead of Replacing","p":["Sometimes you want to add content rather than replace it. The hx-swap attribute with beforeend appends new responses:","Each submission adds a new list item without clearing previous entries. This pattern works well for todo lists, comment sections, or any accumulating content."]},{"l":"Form Validation with HTML5","p":["htmx respects standard HTML5 form validation. The browser validates fields before htmx sends the request:","The type=email attribute validates email format. The min and max attributes constrain the number range. The required attribute ensures fields are not empty. All of this happens in the browser before htmx sends anything to the server.","For complex validation logic, handle it server-side and return appropriate error messages in your HTML response."]},{"l":"Debugging and Observing htmx Requests","p":["When things do not work as expected, htmx provides several ways to investigate."]},{"l":"Inspecting Network Requests","p":["Your browser's developer tools show every htmx request in the Network tab. Filter by XHR or Fetch to see only AJAX requests. For each request, examine:","URL: Is htmx calling the correct endpoint?","Method: Is it GET or POST as expected?","Headers: Is the anti-forgery token present?","Response: What HTML is the server returning?","Status: Is the server returning 200, 400, 500?"]},{"l":"Common Errors and Solutions","p":["400 Bad Request on POST","This usually means the anti-forgery token is missing. Ensure you have @Html.AntiForgeryToken() in your form and the token handling script in your layout.","404 Not Found","The handler name in your URL does not match a method in your PageModel. Remember: handler=Submit maps to OnPostSubmit() for POST requests and OnGetSubmit() for GET requests.","Response Not Appearing","Check that your hx-target selector matches an element that exists on the page. Verify the element has the correct id attribute.","Incorrect Content-Type","Ensure your handler returns Content(..., text/html). Returning JSON or plain text may not render as expected."]},{"l":"Using htmx Events for Debugging","p":["htmx fires events throughout the request lifecycle. You can listen to these for debugging:","These event listeners help you trace exactly what htmx is doing and where problems occur."]},{"l":"Enabling htmx Logging","p":["For full debugging visibility, enable htmx's built-in logging:","This outputs every htmx event to the console, giving you complete visibility into the library's behavior."]},{"l":"Complete Working Example","p":["Here is a complete example that ties together everything from this chapter:","Pages/Index.cshtml","Pages/Index.cshtml.cs","This single page demonstrates dynamic content loading, live search with debouncing, and form submission. Each feature uses a few htmx attributes and a simple server-side handler. No JavaScript framework. No complex state management. Just HTML attributes and C# methods working together."]},{"l":"Summary","p":["This chapter introduced the fundamentals of htmx with ASP.NET Core Razor Pages:","Adding htmx to your project with a single script tag","Using hx-get and hx-post to make AJAX requests","Targeting elements with hx-target and controlling insertion with hx-swap","Customizing triggers with hx-trigger for event-driven interactions","Handling forms with proper anti-forgery token configuration","Using HTML5 validation for client-side form validation","Debugging with browser tools and htmx events","The pattern is consistent: add htmx attributes to your HTML, write a handler method that returns HTML, and let htmx handle the rest. Your server stays in control. Your markup stays readable. Your users get responsive interactions."]},{"l":"Preview of Next Chapter","p":["In the next chapter, we will explore more htmx capabilities including hx-push-url for updating the browser URL, hx-swap-oob for updating multiple elements with a single response, and additional trigger modifiers for fine-grained control over when requests fire."]}],[{"l":"Understanding htmx Commands","p":["Chapter 3 introduced the basics of htmx with hx-get, hx-post, hx-target, and hx-swap. You built simple interactions and learned how htmx sends requests and updates the DOM. Now it is time to go deeper. This chapter expands your command vocabulary with hx-put, hx-patch, hx-delete, and advanced targeting techniques. You will build complete CRUD operations, handle complex swap scenarios, and learn patterns that scale to real applications.","By the end of this chapter, you will understand what each command does and when to choose one over another. You will have working code for create, read, update, and delete operations. You will know how to update multiple page elements from a single response. These are the building blocks for the interactive dashboards, admin panels, and data-driven applications you will build in later chapters."]},{"l":"The Complete htmx Command Set","p":["Attribute","Create new resources, submit forms","DELETE","Each attribute takes a URL as its value. When the element is triggered (by default, on click for buttons and links, on submit for forms), htmx sends the corresponding HTTP request to that URL.","GET","htmx provides HTTP method attributes that map directly to RESTful operations:","HTTP Method","hx-delete","hx-get","hx-patch","hx-post","hx-put","Partially update an existing resource","PATCH","POST","PUT","Remove a resource","Replace an existing resource entirely","Retrieve and display data","Typical Use"]},{"l":"Building a Complete CRUD Example","p":["Theory only takes you so far. Let us build a working task list that demonstrates all five HTTP methods. This example will show you how htmx commands work together in a realistic scenario."]},{"l":"Project Setup","p":["Create a new Razor Pages project or add these files to an existing one. We will need a model, a page, and several partial views.","Models/TaskItem.cs","Services/TaskService.cs","For simplicity, we will use an in-memory store. In a real application, this would be a database.","Register the service in Program.cs:"]},{"l":"The Main Page","p":["Pages/Tasks.cshtml","Pages/Tasks.cshtml.cs"]},{"l":"Partial Views","p":["Pages/Shared/_TaskItem.cshtml","Pages/Shared/_TaskEditForm.cshtml"]},{"l":"Configuring Anti-Forgery Tokens for All Methods","p":["ASP.NET Core requires anti-forgery tokens for POST, PUT, PATCH, and DELETE requests. Add this script to your _Layout.cshtml:","For pages that use hx-delete, hx-put, or hx-patch outside of forms, include a hidden token somewhere on the page:"]},{"l":"Understanding Each Operation","p":["Let us examine what each htmx command does in this example.","CREATE with hx-post","When submitted, this form sends a POST request to OnPostCreate(). The handler creates a new task and returns the _TaskItem partial. The hx-swap=beforeend directive appends the new task to the end of the list rather than replacing the entire list.","The hx-on::after-request=this.reset() attribute clears the form after successful submission, ready for the next entry.","READ with hx-get","Clicking Edit sends a GET request to OnGetEdit(), which returns the edit form partial. The form loads into the modal div. This pattern separates the read operation (loading the form) from the update operation (submitting changes).","UPDATE with hx-put","The edit form uses PUT because we are replacing the entire task resource. The handler returns an updated _TaskItem partial, which replaces the old task element. Using outerHTML ensures the entire task div gets replaced, including its id attribute.","PARTIAL UPDATE with hx-patch","Toggling completion status is a partial update, so we use PATCH. We are not replacing the entire resource, just changing one property. The distinction between PUT and PATCH matters for API design clarity, even when both return the same partial view.","DELETE with hx-delete","The delete button sends a DELETE request and targets the task element itself. The handler returns empty content, so outerHTML swap effectively removes the element from the DOM. The hx-confirm attribute shows a browser confirmation dialog before sending the request."]},{"l":"Advanced Targeting with hx-target","p":["The hx-target attribute accepts CSS selectors, giving you precise control over where responses appear."]},{"l":"Targeting by ID","p":["The most common pattern targets elements by ID:"]},{"l":"Targeting Relative to the Element","p":["htmx provides special selectors for targeting elements relative to the trigger:","Available relative selectors:","this: The element that triggered the request","closest selector: The nearest ancestor matching the selector","next selector: The next element in the DOM matching the selector","previous selector: The previous element matching the selector","find selector: The first child element matching the selector"]},{"l":"Targeting the Document Body","p":["For full-page updates or navigation-like behavior:","This replaces the entire body content and updates the browser URL, simulating navigation without a full page reload."]},{"l":"Mastering hx-swap Options","p":["The hx-swap attribute controls how the response content gets inserted. Each option serves different use cases."]},{"l":"Swap Options Comparison"},{"l":"Swap Modifiers","p":["You can add modifiers to control swap timing and behavior:"]},{"l":"Out-of-Band Swaps","p":["Sometimes a single server action needs to update multiple unrelated parts of the page. Out-of-band (OOB) swaps solve this problem cleanly."]},{"l":"The Problem","p":["Consider a scenario where adding a task also needs to update a task count in the header. With standard htmx, you would need two separate requests. OOB swaps let you update both with one response."]},{"l":"The Solution","p":["Your server response includes additional elements marked with hx-swap-oob=true:","Updated OnPostCreate handler:","Or using a partial view that includes OOB elements:","Pages/Shared/_TaskItemWithCount.cshtml","The page needs a matching element:","When htmx receives the response, it:","Swaps the primary content (the new task) into the target","Finds any elements with hx-swap-oob=true","Swaps those elements into matching elements on the page by ID"]},{"l":"OOB Swap Modes","p":["You can specify how OOB elements should be swapped:"]},{"l":"Debugging htmx Applications","p":["When htmx requests do not behave as expected, you have several debugging options."]},{"l":"Enable Logging","p":["Add this to your page during development:","This outputs every htmx event to the browser console, showing you exactly what htmx is doing."]},{"l":"Listen to Specific Events","p":["For targeted debugging, listen to specific htmx events:"]},{"l":"Network Tab Inspection","p":["The browser's Network tab shows every htmx request. Check:","URL: Is the request going to the correct endpoint?","Method: Is it GET, POST, PUT, PATCH, or DELETE as expected?","Request Headers: Is the anti-forgery token present?","Request Body: For POST/PUT, is the form data correct?","Response Status: 200, 400, 404, 500?","Response Body: What HTML is the server returning?"]},{"l":"Common Issues and Solutions","p":["Problem: Request returns 400 Bad Request","Solution: The anti-forgery token is likely missing. Ensure @Html.AntiForgeryToken() is on the page and the token-forwarding script is in your layout.","Problem: Handler not found (404)","Solution: Verify the handler name matches your method. handler=Create needs OnPostCreate() for POST, OnGetCreate() for GET.","Problem: PUT/PATCH/DELETE returns 405 Method Not Allowed","Solution: ASP.NET Core needs handler methods named OnPut*, OnPatch*, OnDelete*. Verify spelling and that the method is public.","Problem: Response appears but in wrong location","Solution: Check your hx-target selector. Use browser dev tools to verify the target element exists and has the expected ID.","Problem: Element not removed after delete","Solution: Ensure you return empty content and use hx-swap=outerHTML so the element replaces itself with nothing."]},{"l":"Performance Considerations"},{"l":"Minimize Response Size","p":["Return only the HTML needed for the swap. Avoid returning full page layouts for partial updates:"]},{"l":"Use Appropriate HTTP Methods","p":["Match your HTTP method to the operation semantics:","GET for retrieving data (cacheable, safe)","POST for creating resources","PUT for full updates","PATCH for partial updates","DELETE for removal","Using the correct method helps with caching, browser behavior, and API clarity."]},{"l":"Debounce Rapid Triggers","p":["For inputs that fire on every keystroke, add a delay:","The request only fires 300ms after the user stops typing, preventing server overload."]},{"l":"Summary","p":["This chapter covered the complete htmx command set for building interactive Razor Pages applications:","hx-get retrieves data without page reloads","hx-post creates new resources and submits forms","hx-put replaces existing resources entirely","hx-patch partially updates resources","hx-delete removes resources","hx-target controls where responses appear using CSS selectors","hx-swap determines how responses are inserted into the DOM","Out-of-band swaps update multiple page elements from one response","You built a complete CRUD application demonstrating all five HTTP methods with proper anti-forgery protection. You learned advanced targeting with relative selectors and mastered swap options for different update scenarios."]},{"l":"Preview of Next Chapter","p":["In the next chapter, we will explore hx-trigger in depth. You will learn how to fire requests on custom events, combine multiple triggers, add conditions and modifiers, and create responsive interfaces that react to user behavior in sophisticated ways."]}],[{"l":"Mastering hx-get and hx-post","p":["The previous chapters introduced htmx commands and showed you how to build basic interactions. Now it is time to master the two commands you will use most often: hx-get and hx-post. These attributes handle the majority of web application interactions, from loading dynamic content to submitting forms and processing user input.","This chapter goes beyond the basics. You will learn how to construct dynamic URLs, include additional parameters with requests, handle file uploads, and manage server responses effectively. You will build real patterns: live search with debouncing, inline editing, bulk operations, and proper error handling. By the end, you will have the skills to build sophisticated server-driven interactions without writing JavaScript."]},{"l":"Fetching Dynamic Content with hx-get","p":["The hx-get attribute sends HTTP GET requests to your server and updates the page with the response. GET requests are ideal for retrieving data because they are cacheable, bookmarkable, and do not modify server state."]},{"l":"Basic Content Loading","p":["The simplest use of hx-get loads content when a user clicks a button:","The server handler returns HTML:","The partial view renders the user data:","Pages/Shared/_UserProfile.cshtml"]},{"l":"Live Search with Debouncing","p":["Search boxes that update as users type need careful handling. Without debouncing, every keystroke triggers a server request. The hx-trigger attribute with a delay prevents this:","The trigger expression breaks down as:","keyup: Fire on keyup events","changed: Only if the value actually changed","delay:300ms: Wait 300ms after the last keystroke","The server handler filters and returns results:","Pages/Shared/_UserSearchResults.cshtml"]},{"l":"Passing Parameters with hx-vals","p":["Sometimes you need to send additional data with a GET request beyond what is in the URL. The hx-vals attribute adds JSON-formatted values:","The handler receives these as parameters:"]},{"l":"Including Form Fields with hx-include","p":["When you need to include values from form fields outside the triggering element, use hx-include:","The hx-include selector can be:","An ID: #category-select","Multiple selectors: #category-select, #max-price","A CSS selector: .filter-input","closest form: Include all fields in the nearest ancestor form","this: Include the triggering element itself"]},{"l":"Caching GET Responses","p":["For data that does not change frequently, server-side caching reduces load:","The browser caches this response for 5 minutes, avoiding redundant server requests."]},{"l":"Submitting Data with hx-post","p":["The hx-post attribute sends HTTP POST requests, typically for creating resources or submitting forms. POST requests can modify server state and require anti-forgery protection in ASP.NET Core."]},{"l":"Setting Up Anti-Forgery Token Handling","p":["Before any POST examples will work, configure htmx to include anti-forgery tokens. Add this to your _Layout.cshtml:"]},{"l":"Basic Form Submission","p":["With token handling configured, forms submit without page reloads:","The handler processes the submission:"]},{"l":"Controlling Which Parameters Are Sent","p":["The hx-params attribute controls which form fields are included in the request:"]},{"l":"File Uploads","p":["File uploads require the hx-encoding attribute to set the correct content type:","The handler receives the file:"]},{"l":"Buttons Outside Forms","p":["Sometimes you need a button to POST data without being inside a form. Use hx-vals to send the data:"]},{"l":"Bulk Operations","p":["Admin interfaces often need to operate on multiple items at once. This pattern uses checkboxes with hx-include to send selected IDs:","Pages/Shared/_UserRow.cshtml","The handlers process the selected IDs:","Pages/Shared/_UserRows.cshtml"]},{"l":"Inline Editing","p":["Inline editing lets users modify data directly in a table without navigating to a separate page:","Pages/Shared/_ProductRow.cshtml","Pages/Shared/_ProductEditRow.cshtml","The handlers switch between view and edit modes:","The hx-include=closest tr on the Save button includes all input fields from the table row in the PUT request."]},{"l":"Error Handling","p":["Users need clear feedback when something goes wrong. Return appropriate HTTP status codes and error messages:","On the client side, you can handle errors with htmx events:"]},{"l":"Loading Indicators","p":["Users need visual feedback during requests. The hx-indicator attribute shows an element while the request is in progress:","Add CSS to hide indicators by default:"]},{"l":"Debugging htmx Requests","p":["When requests do not work as expected, use these debugging techniques:"]},{"l":"Browser Network Tab","p":["Open Developer Tools (F12) and go to the Network tab. Filter by XHR/Fetch to see htmx requests. Check:","Request URL and method","Request headers (look for RequestVerificationToken)","Request body (form data)","Response status code","Response body"]},{"l":"htmx Logging","p":["Enable verbose logging during development:"]},{"l":"Common Issues","p":["400 Bad Request","Usually a missing anti-forgery token. Ensure @Html.AntiForgeryToken() is present and the token-forwarding script is in your layout.","404 Not Found","The handler name does not match your method. handler=Submit requires OnPostSubmit() for POST requests.","Empty Response","The handler might be returning null or the wrong content type. Verify the handler returns Content(..., text/html) or Partial(...).","Response Not Updating Target","Check that the hx-target selector matches an element that exists. Verify the element has the correct id."]},{"l":"Summary","p":["This chapter covered hx-get and hx-post in depth:","hx-get retrieves data with GET requests, ideal for search, filtering, and loading content","hx-post submits data with POST requests, requiring anti-forgery token handling","hx-vals adds JSON data to requests","hx-include includes form fields from outside the triggering element","hx-params controls which form fields are sent","hx-encoding enables file uploads with multipart form data","hx-indicator shows loading feedback during requests","You built patterns for live search, bulk operations, inline editing, file uploads, and error handling. These patterns form the foundation for most web application interactions."]},{"l":"Preview of Next Chapter","p":["Chapter 6 explores hx-put, hx-patch, and hx-delete for RESTful update and delete operations. You will learn when to use each method, how to handle partial updates, and patterns for optimistic UI updates that make your application feel responsive."]}],[{"l":"Working with hx-put, hx-patch, and hx-delete","p":["Chapter 4 introduced all five HTTP methods with a basic CRUD example. Chapter 5 went deep on hx-get and hx-post. Now it is time to master the update and delete operations that make your applications feel truly interactive.","This chapter goes beyond the basics. You will learn when to choose PUT over PATCH, how to handle deletion with proper user confirmation, and patterns for optimistic updates that make your UI feel instant. You will build undo functionality, handle conflicts when multiple users edit the same data, and implement soft delete for recoverable removals. These are the patterns that separate toy examples from production applications."]},{"l":"Understanding PUT vs PATCH","p":["Both PUT and PATCH modify existing resources, but they serve different purposes.","PUT replaces a resource entirely. When you send a PUT request, you provide the complete new state of the resource. Any fields you omit are cleared or set to defaults. Use PUT when users are editing a complete form where all fields should be saved together.","PATCH modifies a resource partially. You send only the fields that changed. The server merges these changes with the existing data. Use PATCH for single-field updates, toggles, or when you want to minimize data transfer.","Here is how this distinction plays out in practice:","The HTML reflects this distinction:"]},{"l":"Anti-Forgery Tokens for PUT, PATCH, and DELETE","p":["ASP.NET Core requires anti-forgery tokens for all state-changing requests. This protection applies to PUT, PATCH, and DELETE just as it does to POST."]},{"l":"Layout Configuration","p":["Add this script to your _Layout.cshtml after the htmx script:"]},{"l":"Token Placement","p":["For forms, include the token inside the form:","For buttons outside forms, include a token somewhere on the page:","The event listener in the layout will find the token and add it to all htmx requests automatically."]},{"l":"Implementing Delete Operations","p":["Deletion requires careful handling. Users need confirmation before destructive actions, and the UI needs to reflect the removal immediately."]},{"l":"Basic Delete with Confirmation","p":["The hx-confirm attribute shows a browser confirmation dialog before sending the request:","The handler removes the item and returns empty content:","When htmx receives an empty response with hx-swap=outerHTML, it replaces the target element with nothing, effectively removing it from the page."]},{"l":"Why NoContent() Does Not Work for Removal","p":["You might expect return NoContent()(HTTP 204) to work for deletions, but htmx handles 204 responses differently. When htmx receives a 204 No Content response, it does not perform any swap operation. The target element remains unchanged.","Use NoContent() only when you do not want htmx to modify the DOM at all, such as for background operations or analytics tracking."]},{"l":"Delete with Feedback Message","p":["Sometimes you want to show a confirmation message where the deleted item was:","Add CSS to fade out the message:"]},{"l":"Soft Delete with Restore","p":["Production applications often use soft delete, marking records as inactive rather than removing them permanently. This allows users to restore accidentally deleted items."]},{"l":"The Model"},{"l":"The Partial Views","p":["Pages/Shared/_DocumentRow.cshtml"]},{"l":"The Handlers"},{"l":"CSS for Deleted State"},{"l":"Optimistic Updates","p":["Standard htmx requests wait for the server response before updating the UI. For fast operations, this works fine. But for operations with noticeable latency, users appreciate immediate feedback.","Optimistic updates show the expected result immediately, then correct if the server reports an error. This makes your application feel faster."]},{"l":"Toggle with Optimistic Update","p":["Here is a task completion toggle that updates instantly:","The hx-on:click attribute runs JavaScript immediately when clicked, toggling the visual state before the request completes. If the server returns successfully, the response replaces the element with the confirmed state. If the server returns an error, the response shows the original state."]},{"l":"Handling Optimistic Update Failures","p":["For more control over failure handling, use htmx events:"]},{"l":"Handling Conflicts","p":["When multiple users can edit the same data, conflicts arise. User A loads a record, User B modifies it, then User A tries to save their changes. Without conflict detection, User A would overwrite User B's changes."]},{"l":"Optimistic Concurrency with Row Version","p":["Add a version field to your model:","Include the version in your edit form:","The handler checks the version before saving:"]},{"l":"Batch Operations","p":["Sometimes you need to update or delete multiple items at once. Chapter 5 covered bulk operations with checkboxes. Here is the pattern applied to PUT and DELETE."]},{"l":"Batch Update","p":["The handler processes all selected items:"]},{"l":"Batch Delete"},{"l":"Error Handling for Update Operations","p":["Users need clear feedback when updates fail. Return appropriate HTTP status codes and error messages."]},{"l":"Validation Errors (400 Bad Request)"},{"l":"Not Found (404)"},{"l":"Server Error (500)"},{"l":"Client-Side Error Handling","p":["Handle errors globally with htmx events:"]},{"l":"Debugging PUT, PATCH, and DELETE","p":["When requests fail, use these debugging techniques."]},{"l":"Browser Network Tab","p":["Open Developer Tools (F12), go to the Network tab, and filter by XHR/Fetch. Check:","Request Method: Is it PUT, PATCH, or DELETE as expected?","Request Headers: Is RequestVerificationToken present?","Request Body: Are form fields being sent correctly?","Response Status: 200, 204, 400, 404, 409, 500?","Response Body: What HTML is returned?"]},{"l":"Common Issues","p":["400 Bad Request","The anti-forgery token is missing. Ensure @Html.AntiForgeryToken() is on the page and the token-forwarding script is in your layout.","404 Not Found","The handler name does not match your method. handler=Update with PUT requires OnPutUpdate().","405 Method Not Allowed","Your handler method is missing or named incorrectly. OnPut*, OnPatch*, and OnDelete* must be spelled exactly right and be public.","Element Not Removed After Delete","You may be returning NoContent()(204). Change to return Content(, text/html) to get a 200 response that htmx will process.","Update Does Not Appear","Check your hx-target selector. The element with that ID must exist on the page."]},{"l":"Summary","p":["This chapter covered advanced patterns for hx-put, hx-patch, and hx-delete:","PUT vs PATCH: Use PUT for complete replacements, PATCH for partial updates","Anti-forgery tokens: Required for all state-changing requests","Element removal: Return empty content with 200 status, not NoContent()","hx-confirm: Require user confirmation before destructive operations","Soft delete: Mark records as deleted while preserving data for recovery","Optimistic updates: Update UI immediately, correct on error","Conflict handling: Use row versions to detect concurrent modifications","Batch operations: Update or delete multiple items with one request","Error handling: Return appropriate status codes and error messages"]},{"l":"Preview of Next Chapter","p":["Chapter 7 explores hx-target and hx-swap in depth. You will learn advanced targeting with CSS selectors, multiple swap strategies, out-of-band updates for complex UI changes, and techniques for updating multiple page sections from a single response."]}],[{"l":"Working with hx-target and hx-swap","p":["Every htmx request updates something on the page. The question is: what gets updated and how? By default, htmx replaces the inner content of the element that triggered the request. That works for simple cases. But real applications need precision. You need to update a sidebar when a form submits. You need to append items to a list without clearing existing content. You need to remove elements entirely when users delete them.","The hx-target attribute controls where the response goes. The hx-swap attribute controls how the response is inserted. Together, they give you complete control over DOM updates. This chapter covers both attributes in depth, including relative targeting, all swap strategies, swap modifiers, and out-of-band updates for complex multi-element changes."]},{"l":"Understanding hx-target","p":["The hx-target attribute accepts a CSS selector that identifies where the server response should be placed. Without it, htmx targets the element that triggered the request."]},{"l":"Basic ID Targeting","p":["The most common pattern targets an element by ID:","When clicked, the button fetches content from the server and inserts it into #product-list. The button itself remains unchanged."]},{"l":"CSS Selector Targeting","p":["Any valid CSS selector works with hx-target:"]},{"l":"The this Keyword","p":["Use this to target the triggering element itself:","The server returns a replacement button, and htmx swaps out the entire element. This pattern works well for toggle states, inline editing, and self-updating components."]},{"l":"Relative Targeting","p":["htmx provides special selectors for targeting elements relative to the trigger. These are invaluable when you have repeating components like list items or table rows.","closest finds the nearest ancestor matching the selector:","Clicking delete removes the entire card, including its contents.","find targets a descendant of the triggering element:","next targets the next sibling matching the selector:","previous targets the previous sibling matching the selector:"]},{"l":"Targeting the Document Body","p":["For full-page updates or navigation-style interactions:","This replaces the entire body content and updates the browser URL, simulating navigation without a full page reload."]},{"l":"Understanding hx-swap","p":["The hx-swap attribute determines how the response content is inserted into the target. The default is innerHTML, but htmx provides many options for different scenarios."]},{"l":"innerHTML (Default)","p":["Replaces the target's inner content while keeping the target element itself:","After the swap, #container still exists but contains only the server response."]},{"l":"outerHTML","p":["Replaces the entire target element, including the element itself:","The server returns a new version of the task element (perhaps with a \"completed\" class), and it replaces the entire #task-5 div."]},{"l":"Position-Based Swaps","p":["These options insert content relative to the target without replacing it:","beforebegin inserts before the target element:","The new content appears before the ul, as a sibling.","afterbegin inserts inside the target, before its first child:","New messages appear at the top of the list.","beforeend inserts inside the target, after its last child:","New entries append to the bottom. This is the standard pattern for infinite scroll and \"load more\" features.","afterend inserts after the target element:","Replies appear after the comment, as siblings."]},{"l":"delete","p":["Removes the target element entirely:","The target element disappears from the DOM. The server response is ignored (though you should still return a 200 status)."]},{"l":"none","p":["Performs no swap. The server response is received but not inserted into the DOM:","Use this for side-effect-only requests like analytics, logging, or triggering background processes."]},{"l":"Swap Modifiers","p":["You can add modifiers to hx-swap to control timing, scrolling, and focus behavior."]},{"l":"Timing Modifiers","p":["swap: delays the swap operation:","settle: delays the settle step (when htmx adds classes like htmx-settling):"]},{"l":"Scroll Modifiers","p":["scroll: scrolls the target or window after the swap:","show: ensures the target is visible after the swap:"]},{"l":"Focus Modifier","p":["focus-scroll: controls whether to scroll when focusing an element:"]},{"l":"Combining Modifiers","p":["Multiple modifiers can be combined:"]},{"l":"Filtering Responses with hx-select","p":["Sometimes the server returns more HTML than you need. The hx-select attribute extracts specific content from the response:","Even if /FullPage returns an entire page, htmx extracts only the element matching #just-this-section and swaps that into #container.","This is useful when:","Reusing existing page handlers that return full pages","Extracting specific content from external sources","Avoiding duplicate handler methods for partial vs full responses"]},{"l":"Out-of-Band Updates","p":["Standard htmx updates target a single element. But what if one action needs to update multiple unrelated parts of the page? A form submission might need to update a success message, a notification count in the header, and an item in a sidebar.","Out-of-band (OOB) updates solve this. Elements in the server response marked with hx-swap-oob=true are swapped into matching elements on the page by ID, regardless of the original target."]},{"l":"Basic OOB Example","p":["Main page:","Server response:","htmx processes the response as follows:","The first element (without hx-swap-oob) goes to the target (#result)","Elements with hx-swap-oob=true find their matching elements by ID and replace them"]},{"l":"OOB with Server-Side Code","p":["Here is a complete Razor Pages example:"]},{"l":"OOB Swap Modes","p":["You can specify how OOB elements are swapped:"]},{"l":"Multiple OOB Updates","p":["A single response can include multiple OOB elements:"]},{"l":"hx-select-oob","p":["For more control, use hx-select-oob on the triggering element to specify which parts of the response should be treated as OOB:","htmx will:","Swap the response into #main-content(the target)","Extract #sidebar-stats from the response and swap it into the matching element on the page","Extract #header-alerts from the response and swap it into the matching element on the page"]},{"l":"Practical Examples"},{"l":"Infinite Scroll","p":["Load more content as the user scrolls:"]},{"l":"Live Search with Results Panel"},{"l":"Inline Edit with Cancel","p":["_UserNameEdit.cshtml:"]},{"l":"Shopping Cart with Multiple Updates","p":["_CartItem.cshtml:"]},{"l":"Debugging Target and Swap Issues"},{"l":"Common Problems","p":["Target element not found","htmx silently fails if the target selector does not match any element. Verify:","The element exists in the DOM","The ID or class is spelled correctly","The element is not inside a template or script tag","Wrong element updated","Check for duplicate IDs on the page. Each ID should be unique.","OOB elements not updating","Verify:","The element ID in the response matches an element on the page exactly","The hx-swap-oob attribute is on the element in the response, not on the page","Content appears but in wrong position","Review your hx-swap value. Common confusion:","beforeend adds inside the target, at the end","afterend adds outside the target, after it"]},{"l":"Browser Developer Tools","p":["Open the Network tab to inspect responses. Check:","Is the response HTML valid?","Does it contain the expected content?","For OOB, do element IDs match?","Use the Elements tab to watch DOM changes in real-time as htmx processes responses."]},{"l":"htmx Logging","p":["Enable verbose logging:","This outputs every htmx event to the console, including target resolution and swap operations."]},{"l":"Summary","p":["This chapter covered hx-target and hx-swap in depth:","hx-target accepts CSS selectors, including this and relative selectors ( closest, find, next, previous)","hx-swap controls insertion: innerHTML, outerHTML, beforebegin, afterbegin, beforeend, afterend, delete, none","Swap modifiers control timing ( swap:, settle:), scrolling ( scroll:, show:), and focus ( focus-scroll:)","hx-select filters which part of the response to use","hx-swap-oob enables updating multiple unrelated elements from a single response","hx-select-oob provides fine-grained control over OOB element selection","These attributes give you precise control over how your UI responds to server updates, enabling complex interactions without custom JavaScript."]},{"l":"Preview of Next Chapter","p":["Chapter 8 explores hx-trigger and event handling. You will learn how to control when requests fire, respond to custom events, add conditions and modifiers, and build responsive interfaces that react to user behavior in sophisticated ways."]}],[{"l":"Handling Events with hx-trigger and hx-on","p":["Previous chapters focused on what happens when htmx requests complete: where content goes, how it gets inserted. This chapter focuses on when requests fire in the first place. The hx-trigger attribute gives you precise control over the events that initiate requests. The hx-on attribute lets you run JavaScript in response to htmx lifecycle events. Together, they let you build interactions that respond to user behavior in sophisticated ways.","Default triggers work for most cases. Buttons fire on click. Forms fire on submit. Inputs fire on change. But real applications need more: debounced search that waits for users to stop typing, polling that checks for updates every few seconds, lazy loading that fetches content when elements scroll into view, keyboard shortcuts that respond to specific key combinations. This chapter covers all of these patterns and more."]},{"l":"Understanding hx-trigger","p":["The hx-trigger attribute specifies which events cause htmx to send a request. Without it, htmx uses sensible defaults based on the element type."]},{"l":"Default Triggers","p":["htmx assigns default triggers based on element type:","Element","Default Trigger","button","click","a","form","submit","input","change","select","textarea","Other elements","For many interactions, you never need to specify hx-trigger at all:"]},{"l":"Standard DOM Events","p":["Any DOM event can trigger a request:"]},{"l":"Multiple Triggers","p":["Combine multiple events with commas:","This fires on both keyup events and when the user clicks the search icon in a search-type input."]},{"l":"Trigger Modifiers","p":["Modifiers refine when and how triggers fire. Add them after the event name."]},{"l":"changed Modifier","p":["Only fires if the element's value actually changed:","Without changed, every keyup fires a request, even arrow keys or shift. With changed, requests only fire when the input value differs from before."]},{"l":"delay: Modifier","p":["Waits a specified time after the event before firing. If another event occurs during the delay, the timer resets:","The request fires 300ms after the user stops typing. This debouncing pattern prevents flooding your server with requests on every keystroke."]},{"l":"throttle: Modifier","p":["Limits how often requests can fire. Unlike delay, it fires immediately on the first event, then ignores subsequent events for the specified duration:","This fires at most once every 100ms, even if the mouse moves continuously."]},{"l":"once Modifier","p":["Fires only once, then stops listening:","After the first request completes, the element no longer responds to the trigger."]},{"l":"from: Modifier","p":["Listens for events from a different element:","The div makes a request when the button is clicked. This decouples the trigger source from the target element.","You can also listen for events from the document or window:"]},{"l":"target: Modifier","p":["Filters events based on the event target:","Only clicks on td elements trigger the request, not clicks on the table itself or other elements."]},{"l":"consume Modifier","p":["Prevents the event from propagating to parent elements:","Clicking the button only fires the inner request. Without consume, both requests would fire."]},{"l":"queue: Modifier","p":["Controls how events queue when a request is already in flight:","For most cases, queue:last or queue:none prevents duplicate submissions."]},{"l":"Special Triggers","p":["htmx provides special trigger values for common scenarios."]},{"l":"load Trigger","p":["Fires when the element is loaded into the DOM:","This makes the request immediately when the page loads, useful for lazy-loading initial content."]},{"l":"revealed Trigger","p":["Fires when the element scrolls into the viewport:","This is the foundation for infinite scroll and lazy loading. The request fires only when the user scrolls the element into view."]},{"l":"intersect Trigger","p":["Similar to revealed but offers more control through Intersection Observer options:"]},{"l":"every Trigger","p":["Creates polling intervals:","This checks for new notifications every 30 seconds. Combine with other triggers:","The status loads immediately, then refreshes every 10 seconds."]},{"l":"Event Filters","p":["Filter events based on conditions using bracket syntax:"]},{"l":"Key Filters"},{"l":"Modifier Key Filters"},{"l":"Custom Conditions","p":["Any JavaScript expression that returns a boolean works:"]},{"l":"Understanding hx-on","p":["The hx-on attribute executes JavaScript in response to events. It uses the syntax hx-on:event=javascript for standard DOM events and hx-on::event=javascript(double colon) for htmx-specific events."]},{"i":"standard-dom-events-1","l":"Standard DOM Events"},{"l":"htmx Lifecycle Events","p":["htmx fires events throughout the request lifecycle. Use double colon to listen for them:"]},{"l":"Key htmx Events","p":["After content is swapped into DOM","After CSS transitions complete","After request completes (success or failure)","Before content is swapped, can modify swap behavior","Before request, can modify headers/parameters","Event","htmx:afterRequest","htmx:afterSettle","htmx:afterSwap","htmx:beforeRequest","htmx:beforeSwap","htmx:configRequest","htmx:responseError","htmx:sendError","Just before request is sent","When it Fires","When request fails to send (network error)","When server returns error status"]},{"l":"Form Validation with hx-on","p":["Validate before sending the request:"]},{"l":"Animations with hx-on","p":["Trigger animations when content loads:"]},{"l":"Server-Triggered Events with HX-Trigger Header","p":["The HX-Trigger response header enables server-initiated events. When your server includes this header, htmx dispatches custom events on the client that other elements can listen for."]},{"l":"Basic Server Event","p":["Other elements can listen for this event:","When the form submits and the server returns the HX-Trigger: itemCreated header, the items list automatically refreshes."]},{"l":"Multiple Events","p":["Trigger multiple events:"]},{"l":"Events with Data","p":["Pass data with events using JSON:","Access the data in JavaScript:"]},{"l":"Timing Variations","p":["The HX-Trigger header has timing variants:"]},{"l":"Practical Examples"},{"l":"Live Search with Debouncing"},{"l":"Infinite Scroll","p":["_PostBatch.cshtml:"]},{"l":"Auto-Refreshing Dashboard"},{"l":"Keyboard Shortcuts"},{"l":"Cascading Dropdowns"},{"l":"Debugging Triggers and Events"},{"l":"Enable htmx Logging","p":["This logs every event htmx processes, showing trigger evaluation and request lifecycle."]},{"l":"Monitor Specific Events"},{"l":"Common Issues","p":["Add changed modifier for input events","Add delay: for debouncing","Add throttle: for rate limiting","Check event name spelling","Check for events firing on body element","Check JavaScript syntax in brackets","Event filter not working","For from: triggers, ensure the source element exists","Header name is case-sensitive","HX-Trigger header not working","JSON must be valid for events with data","Request fires too often","Test the condition in browser console first","Trigger not firing","Verify property names (e.g., key not keyCode)","Verify the element exists when htmx initializes"]},{"l":"Summary","p":["This chapter covered hx-trigger and hx-on for precise control over htmx interactions:","Default triggers work for common elements (click, submit, change)","Modifiers refine behavior: changed, delay:, throttle:, once, from:, target:, consume, queue:","Special triggers: load, revealed, intersect, every","Event filters use bracket syntax for conditions: keyup[key=='Enter'], click[ctrlKey]","hx-on: executes JavaScript on DOM events (single colon)","hx-on:: executes JavaScript on htmx events (double colon)","HX-Trigger header dispatches events from server responses","These tools let you build responsive, event-driven interfaces without custom JavaScript frameworks."]},{"l":"Preview of Next Chapter","p":["Chapter 9 introduces Hyperscript, a companion language to htmx that adds client-side logic with a clean, readable syntax. You will learn how to handle complex interactions, manage state, and add behaviors that would otherwise require JavaScript, all using simple English-like commands embedded in your HTML."]}],[{"l":"Integrating Hyperscript for Complex Logic","p":["htmx handles most interactions beautifully. Click a button, fetch content, swap it into the page. But some interactions need client-side logic that htmx alone cannot provide: toggling classes based on conditions, waiting for animations to complete, orchestrating multi-step sequences, or managing temporary UI state. You have two choices: write JavaScript or use Hyperscript.","Hyperscript is a scripting language built for HTML. It lives in your markup using the _ attribute, reads like English, and integrates tightly with htmx events. For many interactions, it provides a cleaner alternative to JavaScript event listeners and DOM manipulation.","This chapter teaches you when Hyperscript makes sense, when htmx alone suffices, and how to combine both for sophisticated interactions. You will learn the syntax, see complete working examples with Razor Pages, and understand the trade-offs involved."]},{"l":"Installing Hyperscript","p":["Add Hyperscript to your _Layout.cshtml after htmx:","Or install locally:","Then reference from your wwwroot:","Hyperscript uses the _ attribute (underscore) for its code. This keeps it visually distinct from htmx's hx- attributes."]},{"l":"Hyperscript Syntax Basics","p":["Hyperscript reads like English. Here are the fundamental patterns:"]},{"l":"Event Handling"},{"l":"Class Manipulation"},{"l":"Waiting and Timing"},{"l":"Conditionals"},{"l":"Targeting Elements"},{"l":"Triggering Events"},{"l":"When to Use Hyperscript vs htmx Alone","p":["Before reaching for Hyperscript, check if htmx already provides what you need."]},{"l":"Use htmx Alone For:","p":["Confirmation dialogs- htmx has hx-confirm:","Triggering requests from other elements- Use hx-trigger with from::","Refreshing elements after actions- Use HX-Trigger response header:"]},{"l":"Use Hyperscript For:","p":["Class toggling with conditions:","Sequenced animations:","Temporary UI state:","Multi-step user flows:"]},{"l":"Integrating Hyperscript with htmx Events","p":["htmx fires events throughout the request lifecycle. Hyperscript can listen for these events and respond accordingly."]},{"l":"Key htmx Events","p":["Event","When It Fires","htmx:beforeRequest","Before request is sent","htmx:afterRequest","After request completes","htmx:beforeSwap","Before content is swapped","htmx:afterSwap","After content is swapped","htmx:afterSettle","After CSS transitions complete","htmx:responseError","When server returns error"]},{"l":"Responding to htmx Events"},{"l":"Triggering htmx from Hyperscript","p":["Sometimes you need Hyperscript to initiate an htmx request. The cleanest approach triggers a click on an htmx-enabled element:"]},{"l":"Chaining Actions After htmx Completes"},{"l":"Practical Examples"},{"l":"Tooltip System","p":["A tooltip that appears on hover with smooth transitions:"]},{"l":"Modal Dialog","p":["A modal that opens, loads content via htmx, and closes on completion:","Pages/Shared/_ProductDetails.cshtml:"]},{"l":"Accordion Component","p":["An accordion that allows only one section open at a time:"]},{"l":"Form with Client-Side Validation","p":["Validate before submitting, show loading state, handle errors:"]},{"l":"Dashboard with Refresh Controls","p":["A dashboard with manual refresh and auto-refresh toggle:"]},{"l":"Copy to Clipboard","p":["A button that copies text and shows feedback:"]},{"l":"Debugging Hyperscript"},{"l":"Enable Debug Mode","p":["Add this script to see verbose output in the console:"]},{"l":"Common Issues","p":["Action not completing","Add log statements to trace execution: _=on click log 'clicked' then ...","Check for exit statements that might be stopping execution","Check that the _ attribute is on the correct element","Check that the source element exists when the event fires","Confirm the event name is correct (htmx events use colons: htmx:afterSwap)","Element not found","Ensure the target element exists in the DOM","Event not firing","Look for syntax errors in the browser console","Script not running","Use browser dev tools to test the selector","Use from: to listen for events bubbling from child elements","Verify conditionals are properly closed with end","Verify Hyperscript is loaded after htmx","Verify the selector is correct"]},{"l":"Debugging with Log","p":["The log command outputs to the browser console."]},{"l":"Performance Considerations","p":["Hyperscript is lightweight (about 15KB minified), but keep these points in mind:","Avoid heavy computation- Hyperscript is interpreted at runtime. Complex logic should live in JavaScript or on the server.","Minimize DOM queries- Cache references when performing multiple operations on the same element.","Use htmx for network requests- Hyperscript can make HTTP requests, but htmx handles them better with swapping, indicators, and error handling.","Keep scripts focused- If a Hyperscript block exceeds 10-15 lines, consider moving the logic to JavaScript."]},{"l":"Summary","p":["Hyperscript provides a readable, English-like syntax for client-side interactions that live directly in your markup:","Installation: Add the script after htmx in your layout","Syntax: Uses _ attribute with English-like commands","Class manipulation: add, remove, toggle classes on elements","Event handling: on click, on mouseenter, on htmx:afterSwap","Timing: wait 500ms, wait for eventName","Conditionals: if ... else ... end","htmx integration: Listen for htmx events, trigger htmx requests","Use Hyperscript for UI state and sequencing. Use htmx alone when its built-in features ( hx-confirm, hx-trigger, HX-Trigger header) suffice. The combination gives you sophisticated interactions without JavaScript frameworks."]},{"l":"Preview of Next Chapter","p":["Chapter 10 covers URL management with hx-push-url and hx-replace-url. You will learn how to update the browser's address bar during htmx navigation, enable back-button support, and create deep-linkable components that maintain state across page loads."]}],[{"l":"Navigating with hx-push-url and hx-replace-url","p":["htmx requests update content without page reloads. That speed comes with a cost: the browser's address bar stays frozen. Users cannot bookmark the current view. The back button does nothing useful. Shared links land on the wrong content. These problems make htmx applications feel broken despite their responsiveness.","The hx-push-url and hx-replace-url attributes solve this. They synchronize the browser's address bar with your dynamic content, enabling bookmarks, shareable links, and proper back/forward navigation. Your application gains single-page-app responsiveness while keeping multi-page-app navigation behavior.","This chapter covers both attributes in depth, shows when to use each, and demonstrates complete working examples with Razor Pages. You will learn to handle the critical server-side logic that makes URL-driven navigation work for both htmx requests and direct page loads."]},{"l":"Understanding Browser History","p":["Before diving into htmx attributes, understand how browser history works.","The browser maintains a history stack. Each navigation pushes a new entry onto the stack. The back button pops entries off. The forward button moves through entries you've backed past.","Push adds a new entry:","Replace modifies the current entry without adding:","htmx gives you control over which behavior to use for each interaction."]},{"l":"The hx-push-url Attribute","p":["The hx-push-url attribute pushes a new URL onto the browser's history stack when the htmx request completes successfully. This creates a navigation trail users can traverse with back/forward buttons."]},{"l":"Basic Usage","p":["When clicked:","htmx sends a GET request to the handler","The response swaps into #content","The browser's address bar updates to the URL","A new entry is added to the history stack","The href attribute ensures the link works without JavaScript. The hx-get tells htmx to intercept the click and handle it dynamically."]},{"l":"Custom URLs","p":["You can push a different URL than the request URL:","The request goes to the handler with query parameters, but the browser shows the cleaner URL /search/htmx."]},{"l":"When to Use hx-push-url","p":["Use hx-push-url when:","Users should be able to bookmark the current view","The back button should return to the previous view","Links should be shareable","The view represents a distinct \"page\" or \"state\"","Examples:","Tab navigation (each tab is a bookmarkable view)","Blog post links","Search results pages","Product detail views","Dashboard sections"]},{"l":"The hx-replace-url Attribute","p":["The hx-replace-url attribute updates the browser's address bar without adding a history entry. The current entry is replaced."]},{"i":"basic-usage-1","l":"Basic Usage","p":["When the selection changes:","htmx sends a GET request with the selected value","The response swaps into #product-list","The browser's address bar updates","The current history entry is replaced (no new entry added)"]},{"l":"When to Use hx-replace-url","p":["Use hx-replace-url when:","The URL should reflect current state for bookmarking","But the back button should skip this intermediate state","The change is a refinement, not a navigation","Examples:","Filter selections (sort, category, date range)","Pagination within a list","Form steps in a wizard (back should exit the wizard, not go to previous step)","Modal content changes","Auto-save states"]},{"l":"Configuring History Restoration","p":["For back/forward navigation to work properly, htmx needs to know which element contains the restorable content. Add hx-history-elt to the container that holds your dynamic content:","When the user clicks back, htmx:","Intercepts the browser's popstate event","Checks its history cache for the previous URL's content","Restores the cached content to the hx-history-elt element","If not cached, makes a fresh request to the URL","Without hx-history-elt, back button behavior is unpredictable. Add it to the outermost container that changes during navigation."]},{"l":"Handling Direct vs htmx Requests","p":["Here's the critical piece many tutorials miss: your server must handle both types of requests.","htmx request: User clicks a link with hx-get. Server should return partial content only.","Direct request: User types the URL, refreshes the page, or clicks a shared link. Server should return the complete page with layout."]},{"l":"Detecting htmx Requests","p":["htmx adds an HX-Request header to all requests. Check for it in your PageModel:"]},{"l":"The Razor Page View"},{"l":"The Partial View","p":["Pages/Shared/_BlogPost.cshtml:","This setup works for:","htmx clicks (returns partial, pushes URL)","Direct URL access (returns full page)","Page refresh (returns full page)","Shared/bookmarked links (returns full page)","Back button (restores from htmx cache or fetches fresh)"]},{"l":"Using hx-boost for Simpler Navigation","p":["If you want all links in a section to behave like htmx links with hx-push-url, use hx-boost instead of adding attributes to every link:","With hx-boost=true:","All links and forms in that container automatically use htmx","URLs are automatically pushed to history","Links degrade gracefully without JavaScript","This is often the simplest approach for traditional navigation patterns."]},{"l":"Excluding Links from Boost","p":["Add hx-boost=false to links that should navigate normally:"]},{"l":"Complete Example: Tabbed Interface","p":["Here's a complete working example of a tabbed profile page:"]},{"l":"PageModel"},{"l":"Razor Page"},{"l":"Updating Active Tab Styling","p":["When htmx loads content, the tab styling needs to update. Use hx-on or handle the htmx:afterSwap event:"]},{"l":"Complete Example: Filterable List","p":["A product list with category filtering and pagination:"]},{"i":"pagemodel-1","l":"PageModel"},{"i":"razor-page-1","l":"Razor Page"},{"l":"Product Grid Partial","p":["Pages/Shared/_ProductGrid.cshtml:","Note that category links use hx-push-url(user might want to go back to previous category), while pagination uses hx-replace-url(user probably doesn't want to back through every page)."]},{"l":"History Events","p":["htmx fires events during history operations that you can listen for:"]},{"l":"Re-initializing Components After History Restore","p":["If your pages use JavaScript components that need initialization, handle htmx:historyRestore:"]},{"l":"Common Issues and Solutions"},{"l":"Back Button Does Nothing","p":["Cause: Missing hx-history-elt attribute.","Solution: Add hx-history-elt to the container that holds changing content:"]},{"l":"Direct URL Access Shows Partial Content","p":["Cause: Server returns partial for all requests.","Solution: Check for HX-Request header:"]},{"l":"URL Updates But Content Doesn't Load on Refresh","p":["Cause: Server doesn't handle the URL parameters on direct requests.","Solution: Ensure your OnGet method loads the correct content based on URL parameters for both htmx and direct requests."]},{"l":"History Grows Too Fast","p":["Cause: Using hx-push-url for operations that should use hx-replace-url.","Solution: Use hx-replace-url for filters, sorts, pagination, and other refinements. Use hx-push-url only for distinct views."]},{"l":"Summary","p":["This chapter covered URL management with htmx:","hx-push-url adds entries to browser history (for bookmarkable, distinct views)","hx-replace-url modifies the current entry (for refinements like filtering)","hx-history-elt tells htmx which container to restore on back/forward","hx-boost automatically applies htmx with push-url to all links in a container","Server-side handling must return partials for htmx requests and full pages for direct requests","History events let you respond to navigation and re-initialize components","These tools let you build applications that feel like single-page apps while maintaining the bookmarkability and shareability of traditional multi-page applications."]},{"l":"Preview of Next Chapter","p":["Chapter 11 covers building reusable HTML components with htmx. You will learn to create forms that submit without page reloads, modal dialogs that load content dynamically, and component patterns that combine the techniques from previous chapters into cohesive, reusable building blocks."]}],[{"l":"Building Blocks with HTML Components: Forms and Modal Forms","p":["Forms are where users interact most directly with your application. Registration, login, contact forms, settings pages, checkout flows. Every meaningful action requires a form. Traditional HTML forms reload the entire page on submit, destroying scroll position, clearing transient state, and making users wait while the browser re-renders everything. This experience feels dated.","htmx transforms forms into responsive, immediate interactions. Submit a form, get back a fragment of HTML, swap it into the page. No reload. No flicker. The user stays in context. Combined with modal dialogs, you can create focused workflows that collect input without navigating away from the current page.","This chapter covers both patterns with complete, working examples. You will build inline forms that submit and update in place, modal forms that appear on demand and close on success, and learn how to handle validation errors gracefully. Every example includes the server-side code required to make it work."]},{"l":"Form Submission with hx-post","p":["The hx-post attribute converts a traditional form into an htmx-powered form. Instead of reloading the page, the form submits asynchronously and htmx swaps the response into a target element."]},{"l":"Basic Contact Form","p":["Here's a complete contact form implementation:","Pages/Contact.cshtml:","Pages/Contact.cshtml.cs:","Pages/Shared/_ContactForm.cshtml:","Pages/Shared/_ContactSuccess.cshtml:","CSS for the spinner:","This form:","Submits via htmx without page reload","Shows validation errors inline if submission fails","Displays a spinner during submission","Disables the button to prevent double-submission","Shows a success message with option to send another"]},{"l":"Comment Form with List Update","p":["For forms that add items to a list, use hx-swap=beforeend to append new items:","Pages/Comments.cshtml:","Pages/Shared/_CommentForm.cshtml:","Pages/Comments.cshtml.cs:","Pages/Shared/_Comment.cshtml:","The hx-on::after-request attribute clears the form after successful submission so users can immediately post another comment."]},{"l":"Inline Editing","p":["Allow users to edit content in place without navigating to a separate page:","Pages/Shared/_UserRow.cshtml:","Pages/Shared/_UserEditRow.cshtml:","Pages/Users.cshtml.cs (handlers):"]},{"l":"Modal Forms","p":["Modal forms appear on demand without navigating away from the current page. They focus user attention and work well for quick actions like adding items or confirming operations."]},{"l":"Modal Structure","p":["First, add a modal container to your layout or page:","Modal CSS:"]},{"l":"Opening the Modal","p":["Trigger buttons load content into the modal and open it:"]},{"l":"Modal Form Content","p":["Pages/Shared/_UserCreateForm.cshtml:"]},{"l":"Server-Side Modal Handlers","p":["Pages/Users.cshtml.cs:"]},{"l":"Closing Modal with HX-Trigger Header","p":["An alternative to Hyperscript is using the HX-Trigger response header:","Add a listener in your layout:","And simplify the form:"]},{"l":"Edit Modal","p":["The same pattern works for editing existing items:","Pages/Shared/_UserEditForm.cshtml:"]},{"l":"Confirmation Dialogs","p":["For dangerous actions, use hx-confirm for simple confirmations:","For custom confirmation modals with more detail:","Pages/Shared/_ConfirmDelete.cshtml:"]},{"l":"Form Validation Patterns"},{"l":"Client-Side Validation","p":["HTML5 validation attributes work with htmx. The form will not submit until validation passes:"]},{"l":"Server-Side Validation with Error Display","p":["Return the form partial with ModelState errors:","The partial uses tag helpers to display errors:"]},{"l":"Validation Summary","p":["For a summary of all errors:"]},{"l":"Accessibility Considerations","p":["Make your forms accessible:"]},{"l":"Labels and Inputs","p":["Always associate labels with inputs:"]},{"l":"Error Announcements","p":["Use aria-live for dynamic error messages:"]},{"l":"Focus Management in Modals","p":["When a modal opens, focus should move to the first interactive element:"]},{"l":"Reusable Form Components","p":["Create partial views for common form patterns:","Pages/Shared/_FormGroup.cshtml:","Use it across forms:"]},{"l":"Summary","p":["This chapter covered forms and modal forms with htmx:","Basic forms submit with hx-post and swap responses without page reload","Anti-forgery tokens are required in all forms using @Html.AntiForgeryToken()","Validation errors display by returning the form partial with ModelState","Loading indicators use hx-indicator to show progress","Comment/list patterns use hx-swap=beforeend to append items","Inline editing swaps table rows between view and edit states","Modal forms load content on demand and close on success","HX-Trigger header provides server-controlled modal closing","hx-confirm adds simple confirmation dialogs","Accessibility requires proper labels, aria attributes, and focus management","These patterns combine into sophisticated form workflows while keeping your Razor Pages clean and maintainable."]},{"l":"Preview of Next Chapter","p":["Chapter 12 covers tabs and accordions, two classic UI patterns that organize content into collapsible or switchable sections. You will learn to build tab interfaces that load content on demand, accordions that expand and collapse smoothly, and navigation patterns that combine with the URL management techniques from Chapter 10."]}],[{"l":"Building Blocks with HTML Components: Tabs and Accordions","p":["Tabs and accordions appear everywhere: dashboards, settings pages, FAQs, product details, documentation. These components organize content into digestible sections that users reveal on demand. Traditional implementations require JavaScript to toggle visibility, manage state, and handle keyboard navigation. With htmx and Razor Pages, you can build these components with server-rendered content, lazy loading, and minimal client-side code.","This chapter covers both patterns with complete implementations. You will build tabbed interfaces with active state management, URL integration for bookmarking, and proper accessibility. You will create accordions that expand and collapse smoothly, load content on demand, and support both single-open and multi-open behaviors. Every example includes the server-side code and CSS required to make it work."]},{"l":"Tabbed Interfaces","p":["Tabs let users switch between content panels without page navigation. Each tab represents a view, and clicking it reveals the associated content while hiding others."]},{"l":"Basic Tab Structure","p":["Start with the HTML structure:","Pages/Dashboard.cshtml:","Pages/Dashboard.cshtml.cs:","Tab partial example - Pages/Shared/_OverviewTab.cshtml:"]},{"l":"Tab CSS"},{"l":"Tabs with URL Integration","p":["Add hx-push-url to make tabs bookmarkable and support browser back/forward:","Add hx-history-elt to the tab panel for proper history restoration:","Now users can:","Bookmark specific tabs","Share links to specific tabs","Use back/forward buttons to navigate between tabs","Refresh the page and stay on the current tab"]},{"l":"Product Detail Tabs","p":["A common pattern for e-commerce or content sites:","Pages/Product.cshtml:","Pages/Product.cshtml.cs:","Pages/Shared/_ProductSpecifications.cshtml:","Pages/Shared/_ProductReviews.cshtml:"]},{"l":"Accordion Components","p":["Accordions stack content sections vertically, allowing users to expand and collapse individual sections. They work well for FAQs, settings panels, and any content where users need access to specific sections without seeing everything at once."]},{"l":"Basic Accordion","p":["Pages/FAQ.cshtml:","Pages/FAQ.cshtml.cs:","Pages/Shared/_FAQAnswer.cshtml:"]},{"l":"Accordion CSS"},{"l":"Single-Open Accordion","p":["For accordions where only one section should be open at a time:"]},{"l":"Accordion with Preloaded Content","p":["If content is small and you want instant expansion without server requests:","No htmx needed here since content is already in the page. Hyperscript handles the expand/collapse."]},{"l":"Accordion with Cached Content","p":["Load content once, then use cached version on subsequent opens:","The hx-trigger=click once ensures htmx only fetches content on the first click. Subsequent clicks just toggle visibility using Hyperscript."]},{"l":"Accessibility","p":["Tabs and accordions have specific accessibility requirements."]},{"l":"Tab Accessibility","p":["Key requirements:","Container has role=tablist","Tabs have role=tab and aria-selected","Active tab has tabindex=0, others have tabindex=-1","Panels have role=tabpanel and aria-labelledby"]},{"l":"Keyboard Navigation for Tabs","p":["Add arrow key navigation:"]},{"l":"Accordion Accessibility","p":["Use the hidden attribute alongside CSS for proper accessibility:"]},{"l":"Error Handling","p":["Handle failed requests gracefully:"]},{"l":"Loading States","p":["Show loading feedback during content fetch:"]},{"l":"Reusable Tab Component","p":["Create a partial for consistent tab styling across your application:","Pages/Shared/_TabContainer.cshtml:","Use it:"]},{"l":"Summary","p":["This chapter covered tabs and accordions with htmx and Razor Pages:","Tabs switch between content panels with lazy loading via hx-get","Active state managed with Hyperscript class toggling","URL integration uses hx-push-url and hx-history-elt for bookmarkable tabs","Accordions expand/collapse sections with aria-expanded and CSS transitions","Single-open accordions close other sections when opening a new one","Cached content uses hx-trigger=click once to load content only once","Accessibility requires proper ARIA roles, states, and keyboard navigation","Error handling shows user-friendly messages when requests fail","Loading states provide feedback during content fetch","These patterns give you interactive, accessible navigation components without JavaScript frameworks."]},{"l":"Preview of Next Chapter","p":["Chapter 13 covers dynamic lists and tables. You will learn to build sortable, filterable tables with server-side data, pagination that works with htmx, inline row editing, and real-time updates for live data displays."]}],[{"l":"Building Blocks with HTML Components: Lists and Tables","p":["Lists and tables display the data that drives business applications: product catalogs, user directories, transaction histories, order queues, audit logs. Traditional server-rendered tables require full page reloads to sort, filter, or paginate. That experience feels dated. Users expect to click a column header and see results instantly. They expect to scroll and load more items without navigating to a new page. They expect to delete a row and watch it disappear.","htmx delivers these interactions with server-rendered HTML. Your Razor Pages return table rows and list items as partial views. htmx swaps them into the page. No JavaScript frameworks. No client-side data binding. No duplicated business logic. The server owns the data, the filtering, the sorting, the pagination. The client displays what the server sends.","This chapter covers the patterns you need: dynamic table updates, sorting with clickable headers, pagination with page controls, infinite scroll for continuous loading, inline editing and deletion, and the combination of all these features into a cohesive data grid."]},{"l":"Anti-Forgery Configuration","p":["Before building lists with delete and edit operations, configure anti-forgery token handling. Add this to your layout so all htmx requests include the token:","Pages/Shared/_Layout.cshtml (in the head or before closing body):","This ensures DELETE, PUT, and POST requests from htmx include the anti-forgery token."]},{"l":"Dynamic Table Updates","p":["Tables that refresh without page reloads create a responsive experience. Use hx-get to fetch updated rows and hx-trigger to control when updates happen."]},{"l":"Live Leaderboard","p":["A leaderboard that updates every few seconds:","Pages/Leaderboard.cshtml:","Pages/Leaderboard.cshtml.cs:","Pages/Shared/_LeaderboardRows.cshtml:","The hx-trigger=load, every 10s loads data immediately and refreshes every 10 seconds. The manual refresh button lets users update on demand."]},{"l":"Sorting","p":["Clickable column headers that sort data require tracking the current sort state and toggling direction on repeated clicks."]},{"l":"Sortable Table","p":["Pages/Tasks.cshtml:","Pages/Tasks.cshtml.cs:","Pages/Shared/_TaskRows.cshtml:"]},{"l":"Sort Header CSS"},{"l":"Pagination","p":["Server-side pagination returns a subset of data based on page number and page size."]},{"l":"Paginated Product List","p":["Pages/Products.cshtml:","Pages/Products.cshtml.cs:","Pages/Shared/_ProductList.cshtml:"]},{"l":"Infinite Scroll","p":["Infinite scroll loads more content as the user scrolls down, creating a continuous browsing experience."]},{"l":"Infinite Product Feed","p":["Pages/Feed.cshtml:","Pages/Feed.cshtml.cs:","Pages/Shared/_FeedItems.cshtml:","The trigger div at the bottom uses hx-trigger=revealed to fire when it scrolls into view. It replaces itself with the next batch of items plus a new trigger (if more items exist). When no more items exist, it shows an end message instead."]},{"l":"Infinite Scroll CSS"},{"l":"Filtering","p":["Filters narrow down displayed data based on user criteria."]},{"l":"Filterable Task List","p":["Pages/Tasks.cshtml (updated with filters):","Updated PageModel with filtering:","The hx-include=.filters-bar ensures all filter values are sent with each request, preserving filter state when sorting or searching."]},{"l":"Inline Editing","p":["Edit rows in place without opening a modal or navigating to a new page."]},{"l":"Inline Edit Row","p":["Pages/Shared/_TaskRow.cshtml (view mode):","Pages/Shared/_TaskEditRow.cshtml (edit mode):","Task handlers:"]},{"l":"Complete Data Grid","p":["Combine sorting, filtering, pagination, and CRUD operations into a complete data grid:","Pages/Orders.cshtml:","Pages/Shared/_OrdersGrid.cshtml:"]},{"l":"Error Handling","p":["Handle failed requests gracefully:"]},{"l":"Summary","p":["This chapter covered dynamic lists and tables with htmx:","Anti-forgery tokens configured globally for all htmx requests","Live updates with hx-trigger=every Xs for real-time data","Sorting with clickable headers and toggle direction","Pagination with complete page controls and URL integration","Infinite scroll using hx-trigger=revealed with dynamic page tracking","Filtering with combined filters using hx-include","Inline editing with view/edit row states","Delete operations with confirmation and proper token handling","Empty states and error handling for better UX","Complete data grid combining all features","These patterns form the foundation for any data-driven application, from admin dashboards to e-commerce catalogs."]},{"l":"Preview of Next Chapter","p":["Chapter 14 covers buttons and action links. You will learn to build one-click actions that update UI instantly, confirmation workflows for dangerous operations, batch actions for multiple items, and status toggles that feel immediate and responsive."]}],[{"l":"Building Blocks with HTML Components: Buttons and Action Links","p":["Buttons and links are how users take action in your application. Every click represents intent: create this record, delete that item, toggle this setting, submit this form. Traditional web applications handle these clicks with full page reloads or complex JavaScript event handlers. htmx lets you wire up responsive, immediate interactions using HTML attributes alone.","This chapter focuses on button and link patterns that go beyond basic form submission: inline prompts that collect input without forms, confirmation dialogs that prevent accidents, toggle buttons that flip state instantly, batch actions that operate on multiple items, and buttons that disable themselves during requests to prevent double-submission. Each pattern includes complete server-side code and proper security handling."]},{"l":"Anti-Forgery Token Configuration","p":["All POST, PUT, PATCH, and DELETE requests require anti-forgery tokens. Add this configuration to your layout once, and all htmx requests will include the token automatically:","Pages/Shared/_Layout.cshtml:"]},{"l":"Inline Prompts with hx-prompt","p":["The hx-prompt attribute displays a browser prompt dialog and sends the user's input to the server. This works well for quick edits that don't warrant a full form."]},{"l":"Rename Button","p":["A button that prompts for a new name and updates the item inline:","Important: The prompt value arrives in the HX-Prompt request header, not as a form parameter.","Pages/Items.cshtml.cs:","Pages/Shared/_ItemRow.cshtml:"]},{"l":"Quick Add with Prompt","p":["Add items without a form:"]},{"l":"Confirmation Dialogs","p":["Destructive actions need confirmation. htmx provides two approaches: the simple hx-confirm attribute and custom modal confirmations."]},{"l":"Simple Confirmation with hx-confirm","p":["The hx-confirm attribute shows a browser confirmation dialog before sending the request:","If the user clicks \"OK,\" the request proceeds. If they click \"Cancel,\" nothing happens.","Server handler:"]},{"l":"Custom Modal Confirmation","p":["For styled confirmations with more context, load a modal:","Trigger button:","Modal structure (in layout):","Pages/Shared/_ConfirmDeleteTask.cshtml:","Server handlers:","Modal CSS:"]},{"l":"Toggle Buttons","p":["Toggle buttons switch state and update their appearance immediately."]},{"l":"Complete/Incomplete Toggle","p":["Server handler:","Pages/Shared/_ToggleButton.cshtml:"]},{"l":"Favorite/Unfavorite Toggle"},{"l":"Preventing Double Submission","p":["Users sometimes click buttons multiple times during slow requests. Prevent this with the hx-disabled-elt attribute or CSS."]},{"l":"Using hx-disabled-elt","p":["The hx-disabled-elt attribute specifies which element(s) to disable during the request:","During the request, htmx adds the disabled attribute to the button. When the request completes, it removes it."]},{"l":"Disabling Multiple Elements","p":["Disable the entire form during submission:"]},{"l":"CSS-Based Disable with Loading State","p":["For better visual feedback, combine hx-disabled-elt with loading indicators:"]},{"l":"Batch Actions","p":["Select multiple items and apply an action to all of them."]},{"l":"Batch Delete","p":["Server handler:","Pages/Shared/_ItemsTableBody.cshtml:"]},{"l":"Action Links","p":["Links that trigger htmx actions instead of page navigation."]},{"l":"Load Content Link"},{"l":"Tab-Style Links"},{"l":"Reusable Button Components","p":["Create partial views for consistent button styling and behavior."]},{"l":"Delete Button Partial","p":["Pages/Shared/_DeleteButton.cshtml:","DeleteButtonModel.cs:","Usage:"]},{"l":"Action Button Partial","p":["Pages/Shared/_ActionButton.cshtml:"]},{"l":"Error Handling","p":["Handle failed requests gracefully:","Or handle errors server-side with appropriate status codes:"]},{"l":"Summary","p":["This chapter covered button and link patterns with htmx:","hx-prompt displays a browser prompt and sends input via the HX-Prompt header","hx-confirm shows a confirmation dialog before proceeding","Custom modal confirmations provide styled dialogs with more context","Toggle buttons switch state and update appearance immediately","hx-disabled-elt prevents double-submission by disabling elements during requests","Batch actions operate on multiple selected items","Action links trigger htmx requests instead of page navigation","Reusable partials create consistent button components","These patterns make user interactions feel immediate and responsive while keeping all business logic on the server."]},{"l":"Preview of Next Chapter","p":["Chapter 15 covers loading indicators with hx-indicator and state preservation with hx-preserve. You will learn to show spinners during requests, maintain scroll position and form state across swaps, and create loading skeletons that make your application feel fast and polished."]}],[{"l":"Visual Feedback with hx-indicator and hx-preserve","p":["Users hate uncertainty. When they click a button and nothing happens for 500 milliseconds, they wonder: Did it work? Should I click again? Is the page frozen? That half-second of silence erodes trust in your application. Visual feedback fills that gap. A spinner, a loading overlay, a subtle animation tells users \"I heard you, I'm working on it.\"","htmx provides two attributes for managing visual feedback: hx-indicator shows loading states during requests, and hx-preserve protects specific elements from being replaced during swaps. This chapter covers both with complete, working examples that include proper CSS patterns, accessibility considerations, and common use cases like button spinners, table overlays, and skeleton loaders."]},{"l":"How hx-indicator Works","p":["When htmx sends a request, it adds the htmx-request CSS class to elements. By default, this class is added to the element that triggered the request. The hx-indicator attribute lets you specify additional elements that should receive this class during the request.","Here's the key insight: htmx adds htmx-request directly to the indicator element, not to a parent. Your CSS must account for this."]},{"l":"Basic Indicator CSS Pattern","p":["For indicators inside the triggering element, use a descendant selector:"]},{"l":"Fade Transitions","p":["For smoother appearance, use opacity with transitions:"]},{"l":"Button Loading States","p":["The most common indicator pattern shows a spinner inside a button during form submission."]},{"l":"Button with Inline Spinner","p":["Pages/Tasks.cshtml:","Button CSS:","Pages/Tasks.cshtml.cs:","Pages/Shared/_TaskItem.cshtml:"]},{"l":"Standalone Button Spinner","p":["When you want the spinner next to the button rather than inside:"]},{"l":"Table and List Loading Overlays","p":["For tables and lists that refresh data, overlay the entire container with a loading state."]},{"l":"Table Overlay Pattern","p":["Pages/Products.cshtml:","Overlay CSS:","Pages/Products.cshtml.cs:","Pages/Shared/_ProductRows.cshtml:"]},{"l":"Skeleton Loaders","p":["Skeleton loaders show placeholder shapes that mimic the content layout. They feel faster than spinners because they set expectations about what's coming."]},{"l":"Profile Card Skeleton","p":["Skeleton CSS:","Server handler:","Pages/Shared/_ProfileCard.cshtml:"]},{"l":"Table Skeleton"},{"l":"Understanding hx-preserve","p":["The hx-preserve attribute prevents an element from being replaced during a swap. This is critical to understand: the element is never updated, even if the server sends new content for it."]},{"l":"When to Use hx-preserve","p":["Use hx-preserve for elements that:","Would break or reset if replaced (video players, audio players)","Contain third-party widgets that initialize once (chat widgets, maps)","Have complex client-side state that can't be recreated"]},{"l":"Video Player Example","p":["If htmx swaps #page-content, the video player keeps playing while the video info updates."]},{"l":"Third-Party Widget"},{"l":"When NOT to Use hx-preserve","p":["Do not use hx-preserve for:","Form inputs you want to validate (server can't update them)","Content that should refresh from the server","Elements that need server-side updates","Wrong approach for forms:","Correct approach for forms:","Or use hx-swap-oob to update specific elements:","Server response can include OOB update for error:"]},{"l":"Accessibility","p":["Loading indicators must work for all users, including those using screen readers."]},{"l":"ARIA Attributes for Loading States","p":["Key accessibility patterns:","aria-live=polite announces content changes to screen readers","aria-busy=true during loading tells assistive technology content is updating","role=status on spinners makes them announce to screen readers","visually-hidden class provides text for screen readers without visual display"]},{"l":"Screen Reader CSS"},{"l":"Complete Example: Search with All Patterns","p":["Pages/Search.cshtml:","Pages/Search.cshtml.cs:","Pages/Shared/_SearchResults.cshtml:","Complete CSS:"]},{"l":"Summary","p":["This chapter covered visual feedback with htmx:","hx-indicator specifies elements that receive the htmx-request class during requests","CSS patterns differ based on indicator placement (inside vs. outside trigger)","Button spinners replace button text with loading state during submission","Table overlays cover content with semi-transparent loading indicators","Skeleton loaders show placeholder shapes that mimic expected content","hx-preserve prevents elements from being replaced during swaps (use for video players, widgets)","Accessibility requires ARIA attributes ( aria-busy, aria-live, role=status)","Visual feedback makes the difference between an application that feels broken and one that feels responsive. Users should never wonder if their action was received."]},{"l":"Preview of Next Chapter","p":["Chapter 16 covers hx-select and hx-select-oob for precise content selection. You will learn to extract specific elements from server responses, update multiple page sections with a single request, and build notification systems that update independently from main content."]}],[{"l":"Scoped Updates with hx-select and Out-of-Band Swaps","p":["Most htmx interactions follow a simple pattern: trigger a request, receive HTML, swap it into a target. But real applications rarely update just one thing. Adding an item to a cart should update the cart count in the header. Completing a task should update the task list and the completion percentage. Sending a message should refresh the conversation and show a toast notification.","htmx provides two mechanisms for these multi-element updates: hx-select extracts specific content from a response, and out-of-band (OOB) swaps update elements outside your primary target. This chapter covers both patterns with complete working examples."]},{"l":"Understanding the Two Approaches","p":["Before writing code, understand the distinction:","hx-select filters the response before swapping. If your server returns a full page or a large fragment, hx-select extracts only the part you want. This happens on the client side.","Out-of-band swaps update multiple elements from a single response. The server returns the primary content plus additional elements marked with hx-swap-oob. htmx swaps the primary content into hx-target, then processes each OOB element separately.","Use hx-select when you can't control the response format or need to strip wrapper elements. Use OOB swaps when you control the server and need to update multiple unrelated page sections."]},{"l":"Filtering Responses with hx-select","p":["The hx-select attribute takes a CSS selector and extracts matching content from the response before swapping."]},{"l":"When hx-select is Useful","p":["Consider a blog that returns full pages for SEO. When navigating via htmx, you want just the article content, not the header and footer:","The server returns the full page (header, navigation, article, footer), but htmx extracts only article.post-content and swaps that into #main-content."]},{"l":"Stripping Wrapper Elements","p":["If your partial view includes a wrapper you don't want:","Server returns:","Client extracts just the list:"]},{"l":"Complete hx-select Example","p":["Pages/Articles.cshtml:","Pages/Articles.cshtml.cs:","Pages/Shared/_ArticleFull.cshtml:","The client uses hx-select=.article-body to extract only the content div, leaving out the header and footer."]},{"l":"Out-of-Band Swaps","p":["Out-of-band (OOB) swaps update elements outside your hx-target. The server includes extra elements in the response marked with hx-swap-oob, and htmx processes them after the primary swap."]},{"l":"How OOB Works","p":["htmx sends request to server","Server returns primary content plus OOB elements","htmx swaps primary content into hx-target","htmx finds elements with hx-swap-oob attribute","For each OOB element, htmx finds matching element on page by ID","htmx swaps the OOB content into the matching element"]},{"l":"Basic OOB Pattern","p":["Page structure:","Add to cart button:","Server response includes OOB update:","The feedback message goes into #cart-feedback(the target). The cart count updates #cart-count in the header via OOB."]},{"l":"OOB Swap Strategies","p":["afterbegin","Append to matching element","beforeend","Behavior","Examples:","innerHTML","outerHTML","outerHTML:#other-id","Prepend to matching element","Replace a different element by ID","Replace innerHTML (same as true)","Replace innerHTML of matching element","Replace the entire matching element","The hx-swap-oob attribute accepts swap strategies:","true","Value"]},{"l":"Complete OOB Example: Task Management","p":["A task list where completing a task updates the list, completion count, and shows a toast notification.","Pages/Tasks.cshtml:","Pages/Tasks.cshtml.cs:","Pages/Shared/_TaskItem.cshtml:","Pages/Shared/_TaskToggleResponse.cshtml:","Pages/Shared/_TaskDeleteResponse.cshtml:","Toast CSS:"]},{"l":"Shopping Cart with Multiple OOB Updates","p":["A product page where adding to cart updates the cart count, shows confirmation, and updates stock display.","Pages/Product.cshtml:","Pages/Product.cshtml.cs:","Pages/Shared/_AddToCartSuccess.cshtml:"]},{"l":"Using hx-select-oob on the Trigger","p":["While hx-swap-oob goes in the response, hx-select-oob goes on the triggering element. It tells htmx which elements to treat as OOB from the response.","This is useful when you can't modify the server response but know it contains elements with IDs that should swap OOB:","The response might be:","htmx swaps #main-content into the target, then processes #notification-count and #user-status as OOB swaps."]},{"l":"Debugging OOB Swaps","p":["When OOB swaps don't work, check these common issues:"]},{"l":"1. Missing ID on Page Element","p":["The OOB element must have a matching ID on the page:"]},{"l":"2. ID Mismatch","p":["IDs are case-sensitive:"]},{"l":"3. Element Not in DOM","p":["If the target element is inside content that gets swapped first, it may not exist when OOB runs. Place OOB targets outside swap areas."]},{"l":"4. Using htmx Debug Mode","p":["Enable debug logging:","Check the console for OOB processing messages."]},{"l":"Accessibility Considerations"},{"l":"Announce Dynamic Updates","p":["Use aria-live for regions that update:"]},{"l":"Maintain Focus","p":["When updating content, avoid disrupting keyboard focus:"]},{"l":"Screen Reader Feedback","p":["For important updates, include screen-reader-only text:"]},{"l":"Summary","p":["This chapter covered scoped updates with htmx:","hx-select extracts specific content from responses using CSS selectors","hx-swap-oob in responses marks elements for out-of-band swapping","hx-select-oob on triggers specifies which response elements are OOB","OOB swap strategies include true, outerHTML, beforeend, afterbegin","Multiple OOB elements can update several page sections from one response","Toast notifications append to a container using hx-swap-oob=beforeend","Debugging requires matching IDs and htmx debug logging","OOB swaps let your server tell the full story of what changed, updating every affected element in a single response. This keeps your UI consistent without client-side state management or multiple requests."]},{"l":"Preview of Next Chapter","p":["Chapter 17 covers advanced form techniques with hx-params, hx-vals, and hx-validate. You will learn to control which parameters get sent, inject computed values into requests, and integrate client-side validation with server-side processing."]}],[{"l":"Form Enhancements with hx-params, hx-vals, and hx-validate","p":["Forms collect data. htmx submits that data without page reloads. But real-world forms need more control. You need to exclude fields from submission, inject values that aren't visible in the form, and validate input before it reaches the server. This chapter covers three htmx attributes that give you that control: hx-params filters which fields get sent, hx-vals injects additional data into requests, and hx-validate triggers HTML5 validation before submission.","These attributes work together with the form patterns from Chapter 11. Combined with server-side validation, they create forms that guide users through correct input while keeping your validation logic where it belongs: on the server."]},{"l":"Anti-Forgery Token Setup","p":["All POST form examples in this chapter require anti-forgery tokens. Configure htmx to include them automatically:","Pages/Shared/_Layout.cshtml:"]},{"l":"Filtering Parameters with hx-params","p":["The hx-params attribute controls which form fields are included in a request. By default, htmx sends all fields. With hx-params, you can include all, exclude specific fields, or send none."]},{"l":"hx-params Values","p":["Value","Behavior","*","Send all parameters (default)","none","Send no parameters","not fieldName","Send all except the named field","fieldName","Send only the named field","field1, field2","Send only these fields"]},{"l":"Multi-Step Form Example","p":["A wizard-style form where each step submits only its own fields:","Pages/Signup.cshtml:","Pages/Shared/_SignupStep1.cshtml:","Pages/Shared/_SignupStep2.cshtml:","Pages/Signup.cshtml.cs:"]},{"l":"Excluding Specific Fields","p":["Use hx-params=not fieldName to exclude fields:"]},{"l":"Sending No Parameters","p":["Use hx-params=none for actions that don't need form data:"]},{"l":"Injecting Values with hx-vals","p":["The hx-vals attribute adds extra name-value pairs to requests. These values don't appear in the form but get sent to the server alongside form fields."]},{"l":"Static Values","p":["For fixed values, use JSON syntax:","The server receives source=homepage and category=general as if they were form fields."]},{"l":"Values from Razor","p":["Inject server-side values:","Rendered HTML:"]},{"l":"Dynamic JavaScript Values","p":["For values computed at request time, use the js: prefix:","The js: prefix tells htmx to evaluate the object as JavaScript when the request fires."]},{"l":"Complete Feedback Form Example","p":["Pages/Feedback.cshtml:","Pages/Feedback.cshtml.cs:"]},{"l":"Combining hx-vals with Form Data","p":["Values from hx-vals merge with form fields:","The server receives: Quantity(from form) + productId+ source(from hx-vals)."]},{"l":"HTML5 Validation with hx-validate","p":["The hx-validate attribute triggers HTML5 form validation before htmx sends a request. If validation fails, the request is cancelled and the browser shows validation messages."]},{"l":"Basic Usage","p":["Without hx-validate, htmx would send the request even if fields are empty. With hx-validate, the browser prevents submission and shows \"Please fill out this field\" messages."]},{"l":"Validation Attributes","p":["Common HTML5 validation attributes work with hx-validate:"]},{"l":"When to Use hx-validate","p":["Use hx-validate on form submissions to catch obvious errors before hitting the server:","Don't use hx-validate on real-time validation triggers (like keyup). It would prevent the request from firing at all if the field is incomplete:"]},{"l":"Real-Time Server Validation","p":["For validation that requires server checks (username availability, email uniqueness), use hx-get with debounced triggers."]},{"l":"Username Availability Check","p":["Pages/Register.cshtml:","Pages/Register.cshtml.cs:","Pages/Shared/_RegisterErrors.cshtml:"]},{"l":"Key Patterns for Real-Time Validation","p":["1. Debounce with delay:","Waits 500ms after typing stops before sending the request.","2. Cancel in-flight requests:","If the user keeps typing, cancel the previous request and send a new one.","3. Show loading state:","Display a spinner while checking.","4. Target feedback area:","Put validation messages in a dedicated container."]},{"l":"Validation CSS"},{"l":"Combining All Three Attributes","p":["A profile editor that uses all three attributes:","Pages/Profile.cshtml:","Pages/Profile.cshtml.cs:"]},{"l":"Summary","p":["This chapter covered form enhancement attributes:","hx-params controls which fields are sent: *(all), none, not fieldName, or specific field names","hx-vals injects additional data using JSON syntax or js: prefix for dynamic values","hx-validate triggers HTML5 validation before htmx sends the request","Real-time validation uses hx-get with delay: trigger and hx-sync=this:replace","Server validation should always run on submit, even if client-side checks passed","These attributes give you fine control over form data while keeping validation logic on the server where it can access databases, enforce business rules, and stay consistent across all clients."]},{"l":"Preview of Next Chapter","p":["Chapter 18 covers drag-and-drop functionality with htmx and Hyperscript. You will learn to build sortable lists, kanban boards, and file upload zones that let users rearrange content with natural mouse and touch interactions."]}],[{"l":"Caching and History with hx-history and hx-history-elt","p":["The fastest request is the one you never make. If you have ever hit the back button on a web app and watched it reload a page you visited seconds ago, you know the frustration. That reload breaks your flow, wastes your time, and makes the app feel sluggish. This chapter shows you how htmx eliminates that pain by caching responses in the browser's history stack. With minimal effort, your Razor Pages can feel as fluid as a single-page app without the JavaScript complexity.","You have already seen how htmx handles form submissions, dynamic interactions, and server-driven updates. Now you can give users a smoother navigation experience by preserving state across page transitions. These features do more than improve performance. They let users move backward and forward through your app without losing their place or waiting for redundant server calls. This builds naturally on the scoped updates, real-time interactions, and Hyperscript techniques from earlier chapters.","We will start by examining how htmx manages browser history and caching. You will learn how to control caching behavior for specific elements, reducing server load while making your app feel more responsive. A content-heavy dashboard benefits from caching just as much as a multi-step workflow does. In both cases, intelligent caching dramatically improves the user experience.","By the end of this chapter, you will have the tools to create state-aware applications that feel fast and modern while keeping the simplicity of Razor Pages. Let us see how htmx puts the browser's built-in navigation features to work for you."]},{"l":"Understanding htmx History Caching","p":["Before we look at specific attributes and code, you need to understand how htmx handles history. When you use hx-push-url=true on a request, htmx automatically does two things: it updates the browser's URL, and it saves a snapshot of the current page content to a local cache. This cache lives in the browser's localStorage and holds the HTML content that was on the page before the navigation occurred.","When a user clicks the back button, htmx intercepts that navigation. Instead of making a new server request, it pulls the cached HTML from localStorage and restores it to the page. This restoration happens almost instantly because no network round-trip is required.","The key insight here is that htmx caches by default when you push URLs. The hx-history attribute exists primarily to opt out of this behavior, not to opt in. Setting hx-history=false tells htmx to skip caching for that particular element or request. This becomes important when you have sensitive content like personal information, checkout flows, or admin panels that should not persist in the browser's cache.","You can control how many pages htmx keeps in its history cache through configuration:","Setting this to zero disables history caching entirely. For most applications, the default works well, but you might increase it for apps where users frequently navigate back through many pages."]},{"l":"Making Back Feel Fast Again: History Management with hx-history","p":["In traditional server-rendered apps, clicking the back button typically reloads the entire page. Users lose form inputs, search results disappear, and any scroll position resets. This behavior is so common that many users avoid the back button altogether. With htmx, you can reclaim the back button and make it work the way users expect.","When hx-push-url=true is set on a request, htmx stores the current page content before swapping in the new response. If the user navigates back, htmx restores that stored content without hitting the server. The result feels instant.","Consider a user searching for products in your app. They browse results, click into a product detail page, then hit the back button expecting to see their search results. Without htmx history caching, the page reloads and the results vanish. With hx-push-url=true, the result list reappears immediately, exactly as they left it. No server call. No loading spinner. No frustration.","Here is a search form on a Search.cshtml page that demonstrates this pattern:","The hx-push-url=true attribute handles the caching work. It updates the browser URL with the search query and triggers htmx to cache the page state. When the user navigates away and returns, htmx restores the cached results.","On the server side, the handler returns a partial view:","The _SearchResults.cshtml partial renders the product list:","Notice that the product links use hx-target=#main-content rather than targeting the body. This scoped approach gives you more control over what gets replaced and avoids potential issues with scripts or styles in the document head.","When should you disable history caching? Use hx-history=false in these situations:","Checkout or payment pages where sensitive data should not persist","User profile or account settings pages","Admin panels with privileged information","Any content that becomes stale quickly and must be fresh on every view","This pattern keeps secure content out of the browser's localStorage while still updating the URL for bookmarking purposes."]},{"l":"Locking In the Experience: Retaining State with hx-history-elt","p":["The hx-history-elt attribute solves a specific problem: which element's innerHTML should htmx snapshot when saving to the history cache? By default, htmx snapshots the body element. This works for simple pages, but complex layouts often need more precision.","Place hx-history-elt on the container element whose content represents the \"main\" state of your page. When htmx takes a history snapshot, it captures the innerHTML of this element. When the user navigates back, htmx restores that specific content.","Consider a dashboard with a main content area and persistent navigation:","With hx-history-elt on #app-content, htmx only caches the main content area. The sidebar stays untouched, and the notifications panel can update independently without being overwritten by stale cached data.","Here is a tabbed interface that uses this pattern:","The Hyperscript on each button handles the active state: first it removes the .active class from all tab buttons, then adds it to the clicked button. This sequence ensures only one tab appears active at a time.","When the user clicks Tab 2, views its content, navigates to another page, and then hits back, htmx restores the entire #dashboard-content element including the active tab state and the tab content. The experience feels continuous rather than reset.","You can also preserve form input values by placing the form inside your history element:","When users apply filters, navigate to a product, and return, their filter selections and search text remain intact. This small detail eliminates the frustration of re-entering search criteria."]},{"l":"Speed in the Stack: Supercharging UX with History-Based Caching","p":["Performance extends beyond server response time to include how quickly your app responds to user actions. History caching gives you a performance boost without touching backend code. Instead of reloading content when a user navigates back, htmx serves the previous state from memory. The page appears instantly.","When users browse paginated content like search results or data tables, each page typically requires an hx-get request. Without caching, clicking into an item and returning to the list means another server request to reload the same data. With htmx history caching, the previous list view comes from the browser's cache instead. Users perceive a dramatic speed improvement.","Combine hx-push-url with hx-select to control exactly which parts of the response get stored:","The hx-trigger=load ensures the request fires when the element enters the DOM. The hx-select=#page-content tells htmx to extract only the #page-content portion from the server response. This scoped approach prevents caching headers, footers, or other page elements that should remain dynamic.","Your server handler returns a complete response, but htmx extracts only what you specified:","When users navigate through pages, each view gets cached. Hitting the back button cycles through those cached pages without server requests. The pagination feels as responsive as flipping through local content.","Test your caching behavior using browser developer tools. Open the Application tab and inspect localStorage to see what htmx has cached. You can also add htmx.logAll() to your JavaScript console to watch htmx events in real time, including history save and restore operations."]},{"l":"Designing for Memory: Best Practices with History and Performance","p":["History caching makes your app feel faster, but it requires thoughtful implementation. Cache the wrong content and users see stale data. Cache too much and you waste browser storage. Here are patterns that work well in production."]},{"l":"Isolate Dynamic Content","p":["Real-time elements like notification counts, shopping cart totals, or live status indicators should not live inside cached regions. Structure your layout to keep these elements outside the hx-history-elt container:","The cart count loads fresh on every page view while the main content benefits from caching."]},{"l":"Use hx-select to Scope Cached Responses","p":["When your server returns a full page but you only want to cache part of it, use hx-select:","The server returns both the product list and cart summary, but only #product-list gets extracted and cached."]},{"l":"Build Consistent Partials","p":["Razor Partials should return stable HTML structures regardless of request context. Avoid conditional wrappers that change the DOM structure:","Consistent structures ensure htmx can reliably cache and restore content without layout shifts or broken references."]},{"l":"Manage Focus for Accessibility","p":["When content restores from cache, users navigating via keyboard or screen reader need proper focus management. Use Hyperscript to restore focus after history restoration:","The htmx:historyRestore event fires after htmx restores cached content. The Hyperscript moves focus to the search input, orienting the user within the restored interface.","For screen reader users, include aria-live regions to announce dynamic updates:"]},{"l":"Handle Forms Carefully","p":["Forms inside cached regions retain their values when restored, which is usually what users want. CSRF tokens and other security-sensitive hidden fields can become stale though. Consider refreshing these on restoration:","This pattern ensures security tokens stay valid even when forms are restored from cache."]},{"l":"Test Navigation Thoroughly","p":["History-related bugs are subtle and vary by browser. Build a testing checklist:","Navigate forward through several pages","Use the back button to return through each page","Use the forward button to advance again","Verify scroll positions, form values, and active states at each step","Test with browser developer tools open to watch for console errors","Test on multiple browsers since history handling can differ","Use htmx debugging to trace history operations:","This logs only history-related events, making it easier to trace caching behavior."]},{"l":"Common Pitfalls and Solutions"},{"l":"Stale Data After Server Changes","p":["If server data changes while a user has cached content, they might see outdated information when navigating back. For critical data, consider adding a freshness check:","The htmx:historyRestore from:body trigger causes a fresh request whenever content is restored from history, ensuring users always see current data. Use this selectively since it negates the performance benefits of caching."]},{"l":"Cache Size Limits","p":["Browsers limit localStorage to around 5-10MB. If your pages are large or users navigate extensively, you might hit this limit. Monitor cache size and adjust historyCacheSize accordingly:"]},{"l":"URL Mismatch Issues","p":["Ensure your hx-get URLs match the pattern you want in the browser address bar. Inconsistent URLs can cause confusion when users bookmark or share links:","The hx-push-url can specify a different URL than hx-get, letting you maintain clean user-facing URLs while using Razor Pages handler routing internally."]},{"l":"Summary","p":["History caching transforms how users experience navigation in your Razor Pages application. Instead of reloading pages, htmx restores cached content instantly. Instead of losing form inputs and scroll positions, users return to exactly where they left off.","The key concepts to remember:","hx-push-url=true enables history caching automatically","hx-history=false disables caching for sensitive content","hx-history-elt specifies which element to snapshot","hx-select scopes which parts of the response get cached","Consistent HTML structures make caching reliable","Focus management maintains accessibility","Testing across browsers catches subtle issues","In the next chapter, we will explore hx-disable and hx-request for fine-grained control over when and how htmx makes requests. These tools complement history caching by letting you optimize request behavior and manage loading states."]}],[{"l":"Optimizing Requests with hx-disabled-elt, hx-request, and hx-sync","p":["Every click, every keystroke, every interaction in your application translates to a potential server request. Most of the time, that is exactly what you want. But what happens when users click a submit button five times because they are impatient? What happens when two requests race each other and the slower one overwrites fresher data? What happens when your API expects specific headers or timeout settings that htmx does not send by default?","These problems will find you eventually. The question is: do you have the tools to handle them?","This chapter shifts focus from visual interactivity to request behavior. You have already learned how to cache history, preserve state, and build responsive interfaces. Now you will learn how to control the requests themselves. Three htmx attributes give you that control: hx-disabled-elt prevents duplicate submissions by disabling elements during requests, hx-request configures timeout and credential settings, and hx-sync coordinates multiple requests to prevent race conditions.","By the end of this chapter, you will know how to build forms that cannot be double-submitted, configure requests for cross-origin authentication, and synchronize competing interactions so they do not corrupt your data. These are the details that separate amateur implementations from production-ready applications."]},{"l":"Preventing Double Submissions with hx-disabled-elt","p":["Users click buttons more than once. They do it when the network is slow. They do it when nothing appears to happen. They do it out of habit. Each extra click can trigger another request to your server, creating duplicate database entries, charging credit cards twice, or sending the same email multiple times.","The hx-disabled-elt attribute solves this problem by disabling specified elements while a request is in flight. When the request completes, htmx automatically re-enables the elements. The user sees immediate feedback that their action registered, and your server handles exactly one request.","Here is a feedback form that uses hx-disabled-elt to prevent duplicate submissions:","The find button[type='submit'] expression tells htmx to locate the submit button within the form and disable it during the request. You can also use simpler selectors:","Using this as the selector disables the element that triggered the request. This works when the button itself carries the htmx attributes.","The server-side handler stays simple:","Notice that the parameter name Message matches the form field name exactly. ASP.NET Core model binding is case-insensitive by default, but matching cases makes your code clearer."]},{"l":"Disabling Multiple Elements","p":["Sometimes you need to disable more than just the submit button. A form might have multiple action buttons, or you might want to disable the entire input area to prevent edits during submission:","The comma-separated selector disables all inputs and buttons within the controls container. Users cannot modify the promo code or click either button while the order processes."]},{"l":"Combining with Visual Feedback","p":["Disabling elements prevents duplicate submissions, but users also need visual confirmation that something is happening. Combine hx-disabled-elt with hx-indicator for a complete solution:","The htmx-indicator class hides the spinner by default. When a request starts, htmx adds the htmx-request class to the element, and your CSS can reveal the spinner:","Now users see the button dim and display \"Processing...\" while the payment request completes. They cannot click again, and they know the system received their action."]},{"l":"Configuring Request Behavior with hx-request","p":["The hx-request attribute lets you configure how htmx sends requests. Unlike what you might assume, this attribute focuses on three specific settings: timeout duration, credential handling, and whether to include htmx-specific headers."]},{"l":"Setting Request Timeouts","p":["By default, htmx does not enforce a timeout on requests. If your server hangs, the user waits indefinitely. The timeout option lets you set a maximum wait time in milliseconds:","This request will abort after 30 seconds if the server has not responded. You can handle the timeout on the client with htmx events:","The Hyperscript listens for the htmx:timeout event and displays a friendly message when the request exceeds the time limit."]},{"l":"Handling Credentials for Cross-Origin Requests","p":["When your Razor Pages application calls APIs on different domains, browsers apply strict rules about cookies and authentication headers. The credentials option controls whether htmx includes credentials with cross-origin requests:","Setting credentials to true is equivalent to setting credentials: 'include' on a fetch request. The browser will send cookies and HTTP authentication headers to the cross-origin server.","Your server must be configured to accept credentialed requests. In ASP.NET Core, this means setting up CORS properly:","Without the AllowCredentials() call and a specific origin (not wildcard), the browser will block the credentialed request."]},{"l":"Suppressing htmx Headers","p":["Every htmx request includes several custom headers: HX-Request, HX-Trigger, HX-Target, and others. These headers help your server understand the request context. In some situations, you might want to suppress them:","Setting noHeaders to true prevents htmx from adding its custom headers. This can be useful when calling third-party APIs that might reject requests with unfamiliar headers, or when you want requests to appear as standard browser requests rather than htmx-initiated ones."]},{"l":"Combining Options","p":["You can combine multiple options in a single hx-request attribute:","This request will timeout after 10 seconds, include credentials, and omit htmx headers."]},{"l":"Adding Custom Headers with hx-headers","p":["When you need to send custom headers with your requests, use hx-headers rather than trying to configure them through hx-request. This attribute accepts a JSON object of header names and values:","The server receives the custom header and can validate it:","The CryptographicOperations.FixedTimeEquals method prevents timing attacks by comparing strings in constant time. Never use simple string equality for security tokens."]},{"l":"Dynamic Headers","p":["For headers that change based on user state or page context, you can set them dynamically using JavaScript:","The htmx:configRequest event fires before each request, allowing you to modify headers, parameters, or other request details."]},{"l":"Security Considerations","p":["Placing tokens directly in HTML attributes means anyone can view them by inspecting the page source. For truly sensitive operations:","Use server-side sessions and cookies rather than client-visible tokens","Implement proper authentication middleware","Consider using hx-vals to send data that gets validated server-side against the user's session","This approach embeds the anti-forgery token in a header rather than a hidden field, which some security configurations require."]},{"l":"Coordinating Competing Requests with hx-sync","p":["Race conditions happen when multiple requests compete and the results arrive out of order. Picture a search box that sends a request on every keystroke. The user types \"cat\", generating requests for \"c\", \"ca\", and \"cat\". If the \"ca\" response arrives after the \"cat\" response, the user sees results for \"ca\" instead of their complete query.","The hx-sync attribute prevents these problems by coordinating requests from related elements. It specifies a synchronization strategy that determines how competing requests should be handled."]},{"l":"Basic Synchronization Strategies","p":["The hx-sync attribute takes two parts: a CSS selector identifying the synchronization scope, and a strategy keyword.","Drop Strategy- Ignore new requests while one is in flight:","With drop, if a request is already running when a new one would start, the new request is simply ignored. This prevents request pileup but might miss the user's final input.","Abort Strategy- Cancel the in-flight request and start the new one:","With abort, the previous request is cancelled when a new one starts. This ensures users always see results for their most recent input. For search boxes, this is usually the right choice.","Replace Strategy- Same as abort, the default behavior:","The replace strategy is the default and behaves identically to abort. Explicitly stating it can make your intent clearer.","Queue Strategies- Process requests in order:","Queue strategies process requests sequentially. Options include:","queue first- Queue the first request, drop subsequent ones","queue last- Queue only the most recent request","queue all- Queue every request (use with caution)"]},{"l":"Synchronizing Multiple Elements","p":["The CSS selector in hx-sync determines what scope to synchronize against. This lets you coordinate requests across related elements:","All three filter controls synchronize against the same form. If a user changes the category while a search request is running, the search request aborts and the category request proceeds. This ensures the product list always reflects the most recent filter state."]},{"l":"Server-Side Handler for Synchronized Requests","p":["The handler receives all filter parameters and returns the filtered results:","Because requests are synchronized on the client, you do not need to worry about race conditions corrupting the displayed data. The UI always reflects the most recent user selection."]},{"l":"Combining Attributes for Production-Ready Forms","p":["Real forms often need multiple optimizations working together. Here is a complete example that combines hx-disabled-elt, hx-sync, hx-indicator, and proper validation:","This form:","Disables all inputs and the button during submission","Aborts any in-flight request if the user somehow triggers another","Shows a loading indicator in the button","Uses HTML5 validation attributes for client-side checks","The server handler:"]},{"l":"Debugging Request Issues","p":["When requests behave unexpectedly, htmx provides tools to understand what is happening."]},{"l":"Browser Developer Tools","p":["Open the Network tab in your browser's developer tools. Filter by XHR/Fetch to see only AJAX requests. For each request, examine:","Headers: Verify custom headers are present and correct","Payload: Confirm form data is being sent as expected","Timing: Identify slow requests that might need timeouts","Response: Check that the server returns valid HTML"]},{"l":"htmx Logging","p":["Enable htmx logging to see events in the console:","This outputs every htmx event, which can be noisy but thorough. For targeted debugging, listen for specific events:"]},{"l":"Common Issues and Solutions","p":["Problem: Button does not re-enable after request completes. Solution: Verify the request actually completes. Check for JavaScript errors. Ensure hx-disabled-elt selector matches the element.","Problem: Requests still race despite hx-sync. Solution: Confirm all related elements use the same sync scope. The CSS selector must resolve to the same element for coordination to work.","Problem: Custom headers not appearing in requests. Solution: Check for typos in hx-headers JSON. Verify the JSON is valid. Some proxies strip non-standard headers.","Problem: Credentials not sent to cross-origin API. Solution: Ensure both hx-request='{credentials: true}' on the client and AllowCredentials() in server CORS configuration."]},{"l":"Summary","p":["Request optimization separates functional applications from professional ones. Users expect buttons to work exactly once. They expect the most recent action to win. They expect the application to handle edge cases gracefully.","The three attributes covered in this chapter give you that control:","hx-disabled-elt prevents duplicate submissions by disabling elements during requests","hx-request configures timeout, credentials, and header behavior","hx-sync coordinates competing requests to prevent race conditions","Use hx-headers when you need custom headers. Combine these attributes with hx-indicator for visual feedback. Test thoroughly with browser developer tools.","In the next chapter, we will explore advanced performance techniques including lazy loading, request batching, and strategies for minimizing latency in complex Razor Pages applications."]}],[{"l":"Performance Optimization","p":["Performance is more than speed. It is responsiveness, stability, and fluidity at every interaction. After building a solid foundation with htmx and Razor Pages, after layering in forms, tabs, modals, history management, and drag-and-drop interactivity, you need to look under the hood and refine how everything runs. This chapter focuses on smart, thoughtful enhancements that make your app feel fast without burning through server resources or exhausting browser patience.","You have seen how htmx handles interactions by communicating directly with the server using small, focused HTTP requests. But as your UI grows more dynamic and your users become more active, you will notice where optimizations matter most. Knowing when to prevent unnecessary requests, when to cache previously loaded content, and how to coordinate competing interactions can turn a sluggish interface into something satisfying to use.","This chapter explores patterns and techniques for improving performance from both client and server perspectives. You will learn how to reduce network chatter, streamline rendering, and prevent the classic pitfalls of excessive or redundant requests. You will also see how to synchronize competing requests so they do not corrupt your data or confuse your users.","Before moving into building a real-world dashboard in the next chapter, this chapter serves as your final checkpoint. It is where you tighten the bolts, polish the engine, and make sure the interactive experience you have built runs at its best."]},{"l":"Smart Requests, Smooth Experience: Reducing Load the Right Way","p":["When htmx makes it easy to fetch and swap content with just a few attributes, you will be tempted to use it everywhere. That temptation is part of its appeal. But unintentional overuse can silently degrade performance. One of the most common pitfalls in growing htmx applications is triggering more requests than necessary. Search boxes firing on every keystroke, buttons clicked repeatedly in quick succession, filters that race each other and arrive out of order: these inefficiencies add up fast, especially as your user base grows.","A good starting point for reducing server load is understanding where redundant or excessive requests happen. Dynamic search inputs are a frequent culprit. Developers often bind hx-get to keyup events without any delay, resulting in a flood of server requests as users type. This creates strain on your backend and jittery UX as responses race to update the DOM, sometimes arriving out of order.","Consider a search form where results appear as the user types. A naive implementation might look like this:","Every single keystroke fires a request. If your user types quickly, that could mean 10 or more server calls in just a few seconds. The solution is throttling. Adding delay:500ms to hx-trigger introduces a half-second pause after typing stops before firing the request. Combined with changed, which ensures it only triggers if the value has actually changed, this drastically cuts the number of requests:","This simple change alone can reduce server requests by 80 to 90 percent in many cases. Throttling and debouncing are foundational patterns for interactive elements that respond to rapid user input. While htmx handles some of this internally, explicitly controlling trigger behavior with delay settings gives you more predictable and scalable performance.","On the server side, your Razor Page handler stays lean:","The _SearchResults.cshtml partial returns a simple list of results, allowing htmx to update the UI efficiently without loading or redrawing anything unrelated.","By optimizing when and how requests are sent, you help your server operate more efficiently and deliver a smoother experience to users. As your application scales, these adjustments make the difference between an app that groans under traffic and one that handles it with grace."]},{"l":"Preventing Race Conditions with hx-sync","p":["Debouncing helps reduce request volume, but it does not solve every problem. What happens when a user changes a dropdown while a previous request is still in flight? What if they click a button twice before the first response arrives? These race conditions can corrupt your UI by displaying stale data or applying updates in the wrong order.","The hx-sync attribute coordinates requests from related elements, ensuring they do not compete in destructive ways. It specifies a synchronization scope and a strategy for handling conflicts."]},{"l":"Abort Strategy for Search Inputs","p":["For search boxes and filters, the abort strategy cancels any in-flight request when a new one starts:","With hx-sync=this:abort, if the user types \"cat\" while a request for \"ca\" is still pending, the \"ca\" request gets cancelled. The results will always reflect the most recent input, never an outdated intermediate state."]},{"l":"Drop Strategy for Expensive Operations","p":["For operations that should not be interrupted, the drop strategy ignores new requests while one is running:","If the user clicks while a report is generating, the second click is ignored entirely. Combined with hx-disabled-elt to visually disable the button, this creates a foolproof interaction that cannot produce duplicate reports."]},{"l":"Synchronizing Multiple Elements","p":["When several elements can trigger requests that update the same target, synchronize them against a common ancestor:","All three controls synchronize against #product-filters. If a user changes the category while a search request is running, the search request aborts and the category request proceeds. The product list always reflects the most recent user action.","The server handler receives all filter parameters:"]},{"l":"On-Demand Loading: Lazy Loading for Speed and Sanity","p":["Lazy loading defers fetching content until it is actually needed. Instead of overwhelming the browser and backend by loading everything up front, you spread the work across the user's session. This approach improves perceived performance and reduces bandwidth usage, which matters most when dealing with large datasets, media-heavy pages, or sections hidden until scrolled into view.","htmx makes lazy loading almost effortless using hx-get combined with hx-trigger=revealed. The revealed trigger fires when an element becomes visible in the viewport. You can delay loading sections of your page until the user scrolls down to them, reducing initial page load time significantly.","Suppose you have a report with several data tables, and only the first one is visible when the page loads. Rather than load all of them at once, lazy load the others as the user scrolls:","On the server side:","The _SalesTable.cshtml partial renders the table. With this setup, the placeholder div swaps out with actual content once it becomes visible in the browser. The interaction feels smooth without blocking initial page load."]},{"l":"Infinite Scrolling","p":["You can extend lazy loading to create infinite scrolling. Each batch of content includes a loader for the next batch at the bottom:","The server sends both content and the next loader. Users see endless scrolling without overwhelming the page:","Taking one extra record lets you determine if more content exists without a separate count query."]},{"l":"Lazy Loading Images","p":["For media-heavy pages, wrap images in containers that load actual markup only when visible:","The server returns the actual image tag:","This reduces the number of active image requests on initial load, giving users a faster and more responsive browsing experience."]},{"l":"History Caching for Instant Back Navigation","p":["When users click the back button, they expect instant results. Without caching, htmx would need to re-fetch content from the server. History caching stores previously loaded content and restores it immediately during navigation.","When you use hx-push-url=true, htmx automatically caches the current page state before navigation. The hx-history-elt attribute specifies which element should be snapshotted. Place it on the container whose content represents your page's main state:","The hx-history-elt attribute on #main-content tells htmx to snapshot that element's innerHTML when the URL changes. When users navigate back, htmx restores the cached content instantly without a server request."]},{"l":"When to Disable History Caching","p":["Some content should not be cached. Sensitive information, rapidly changing data, or personalized content might become stale or inappropriate to restore. Use hx-history=false to exclude specific requests from caching:","This still updates the URL but does not cache the response. Navigating back will trigger a fresh server request."]},{"l":"Configuring Cache Size","p":["htmx stores history in localStorage with a default limit of 10 pages. Adjust this based on your application's needs:","Set it to zero to disable history caching entirely while keeping URL updates functional."]},{"l":"Out-of-Band Updates for Complex Interactions","p":["Sometimes a single user action needs to update multiple unrelated parts of the page. A form submission might need to refresh a data table, update a notification count, and show a status message. Making three separate requests wastes bandwidth and creates timing issues.","Out-of-band (OOB) updates let you include multiple fragments in a single response. htmx swaps the primary content into the target, then processes any elements marked with hx-swap-oob=true and swaps them into matching elements elsewhere on the page.","Suppose submitting a support ticket should update the ticket list, notification badge, and show a confirmation message:","Your server response includes the primary content plus OOB fragments:","Or using a partial view that includes OOB elements:","htmx processes the response as follows:","Swaps the primary content (everything before the first OOB element) into #ticket-list","Finds #notification-badge in the current page and replaces it with the OOB version","Finds #status-message in the current page and replaces it with the OOB version","This pattern keeps your interactions efficient while handling complex UI updates in a single round trip."]},{"l":"Server-Side Performance for htmx Endpoints","p":["Client-side optimizations only go so far. Your server needs to respond quickly with minimal payloads for htmx to feel fast."]},{"l":"Return Minimal HTML Fragments","p":["htmx endpoints should return only the HTML needed for the swap. Avoid returning full page layouts:"]},{"l":"Enable Response Compression","p":["ASP.NET Core can compress responses, reducing transfer size for HTML fragments:"]},{"l":"Cache Partial View Results","p":["For content that does not change frequently, cache the rendered output:"]},{"l":"Add Timing Headers for Debugging","p":["Include server timing information in responses to help identify slow endpoints:","Browser developer tools display these timings in the Network tab, making performance issues visible during development."]},{"l":"Debugging htmx Performance","p":["When requests behave unexpectedly or performance degrades, htmx provides tools to understand what is happening."]},{"l":"Enable Logging","p":["The simplest debugging approach is enabling htmx logging:","This outputs every htmx event to the console. For targeted debugging, listen for specific events:"]},{"l":"Monitor Network Activity","p":["Your browser's Network tab reveals:","Which requests htmx is firing","Request frequency (are triggers too aggressive?)","Response sizes (are you returning too much HTML?)","Timing breakdowns (where is time being spent?)","Filter by XHR/Fetch to see only AJAX requests and hide static assets."]},{"l":"Common Performance Issues","p":["Problem: Search fires too many requests. Solution: Add delay:300ms to debounce and hx-sync=this:abort to cancel stale requests.","Problem: Page feels slow despite fast server responses. Solution: Check if you are returning too much HTML. Use browser paint profiling to identify rendering bottlenecks.","Problem: Back button triggers server requests instead of using cache. Solution: Verify hx-push-url is set and hx-history-elt is on the correct container element.","Problem: Multiple clicks create duplicate database entries. Solution: Add hx-disabled-elt to disable buttons during requests and hx-sync=this:drop to ignore repeated clicks.","Problem: Filters update with stale data after rapid changes. Solution: Synchronize all filter elements with hx-sync against a common ancestor using the abort strategy."]},{"l":"Summary","p":["Performance optimization with htmx combines several complementary techniques:","Debouncing reduces request volume by waiting for user input to settle","hx-sync prevents race conditions by coordinating competing requests","Lazy loading defers content fetching until elements become visible","History caching restores previously loaded content instantly during navigation","Out-of-band updates handle complex multi-element updates in single responses","Server optimizations ensure fast responses with minimal payloads","These patterns work together. A well-optimized htmx application debounces rapid input, synchronizes related controls, lazy loads heavy content, caches navigation states, and returns minimal server responses. The result is an interface that feels immediate and reliable, even as complexity grows.","In the next chapter, you will build a dynamic, data-rich dashboard using htmx and Razor Pages. You will apply these performance techniques across interactive charts, live updates, and admin panels to see how clean and responsive your applications can be when performance is part of the plan from the start."]}],[{"l":"Debugging htmx Applications","p":["When an htmx application works, it feels like magic. Partial updates flow smoothly, the page responds instantly, and users never see a loading screen. When something breaks, that same magic becomes a mystery. Where did the request go? Why didn't the content update? What happened to my data?","Debugging htmx applications requires different techniques than traditional web development. This chapter provides the tools and methods to diagnose and fix htmx issues quickly and systematically."]},{"l":"21.1 Introduction"},{"l":"Why Debugging htmx Differs from Traditional Web Apps","p":["Traditional web applications follow a predictable pattern: user clicks a link, browser sends a request, server returns a complete page, browser renders it. When something goes wrong, you see an error page or a blank screen. The failure is visible.","htmx operates differently. Requests happen in the background. Responses replace portions of the page rather than the whole thing. State exists simultaneously on the server (in session, database, or handler properties) and in the browser's DOM. A failure might mean nothing visible happens at all, which is harder to diagnose than an obvious error.","Several characteristics make htmx debugging unique:","Invisible Updates: When you click a button and nothing happens, was the request sent? Did the server respond? Did the response reach the right element? Traditional page loads answer these questions automatically. With htmx, you need to investigate each step.","Partial Responses: The server returns HTML fragments, not complete pages. If the fragment is malformed, targets the wrong element, or includes unexpected content, the visible result may be confusing or absent.","Dual State: Your application state lives in two places. The server knows what data exists. The browser's DOM reflects what the user sees. These can fall out of sync if updates fail partway through, if OOB swaps miss their targets, or if the user navigates with the back button.","Event Timing: htmx operations are asynchronous. A fast typist might trigger multiple search requests. A slow network might deliver responses out of order. Debouncing and request cancellation help, but timing issues can still cause unexpected behavior.","Attribute-Driven Behavior: htmx behavior comes from HTML attributes, not JavaScript code. A typo in an attribute name silently fails. An incorrect selector in hx-target sends content to the wrong place without throwing an error."]},{"l":"Common Categories of htmx Issues","p":["Most htmx problems fall into a few categories:","Configuration Errors: Typos in attribute names ( hx-triger instead of hx-trigger), incorrect handler names in URLs, missing htmx.js include, wrong attribute values.","Server Response Problems: Handler returns full page instead of partial, wrong content type, partial view not found, server error (500), authentication redirect (302).","Targeting Failures: Target element doesn't exist, selector matches wrong element, element ID changed after previous swap, OOB target missing.","Event and Timing Issues: Trigger never fires, events fire too often, request cancellation causes unexpected behavior, debounce timing wrong.","Anti-Forgery Token Problems: Token not included in request, token expired, token mismatch between form and handler.","History and URL State: Back button shows stale content, URL doesn't reflect current state, history cache serves outdated responses."]},{"l":"What This Chapter Covers","p":["This chapter provides systematic approaches to debugging each category of issue. You'll learn to use browser developer tools effectively for htmx requests, use htmx's built-in debugging features, implement server-side logging for htmx requests in ASP.NET Core, diagnose common problems with proven solutions, and build a systematic debugging workflow.","The examples use the Chinook Dashboard from Chapter 21. If you haven't built that project, the techniques still apply to any htmx application."]},{"l":"21.2 Browser Developer Tools for htmx","p":["Browser developer tools are your primary debugging interface. Chrome, Firefox, and Edge all provide similar capabilities. This section focuses on Chrome DevTools, but the concepts transfer to other browsers."]},{"l":"21.2.1 Network Tab Essentials","p":["The Network tab shows every request the browser makes. For htmx debugging, you need to filter and interpret these requests effectively."]},{"l":"Opening the Network Tab","p":["Press F12 to open DevTools, then click the Network tab. Check \"Preserve log\" to keep requests visible across navigations. For htmx work, filter to \"Fetch/XHR\" to hide CSS, images, and other resource requests."]},{"l":"Identifying htmx Requests","p":["htmx adds an HX-Request: true header to every request it makes. This header distinguishes htmx requests from regular browser navigation or other JavaScript fetch calls.","In the Network tab, click on any request to see its details. Under the Headers section, look for Request Headers. htmx requests include:","These headers tell you:","HX-Request: Confirms this is an htmx request","HX-Current-URL: The page URL when the request was made","HX-Target: The ID of the element that will receive the response (without the # prefix)","HX-Trigger: The ID of the element that triggered the request","If you don't see the HX-Request header, the request wasn't made by htmx. Check that htmx.js is loaded and the element has proper htmx attributes."]},{"l":"Reading Response Headers","p":["The server can send instructions back to htmx through response headers:","These headers control behavior after the response arrives:","HX-Redirect: Forces a full page redirect","HX-Refresh: Triggers a full page refresh","HX-Trigger: Fires a custom event on the target element","HX-Trigger-After-Swap: Fires after the swap completes","HX-Push-Url: Updates the browser URL","Check response headers when htmx behaves unexpectedly after receiving a response. An HX-Redirect from an authentication handler, for example, might explain why your partial update instead triggers a full page load."]},{"l":"Inspecting Response Content","p":["Click the Response or Preview tab to see what the server returned. For htmx partials, you should see an HTML fragment, not a complete page with !DOCTYPE html and html tags.","If you see a full HTML page, your handler is returning Page() instead of Partial(), or your partial view is somehow pulling in the layout. This is a common issue covered in detail in Section 21.4.2.","Check the response status code as well:","200: Success, response should be swapped","204: Success, no content (htmx does nothing)","400: Bad request (often anti-forgery token issues)","404: Handler or page not found","500: Server error"]},{"l":"Demo: Debugging a 404 Handler Not Found","p":["Let's walk through a real debugging scenario. You have an Edit button on an artist row:","You click the button. Nothing happens. Here's how to diagnose it:","Step 1: Open Network Tab","Press F12, select Network, filter to Fetch/XHR.","Step 2: Click the Button Again","Watch for a new request to appear.","Step 3: Examine the Request","You see a request to /Artists?handler=Edittid=1. The status code is 404.","Step 4: Identify the Problem","The handler name is Editt with two t's. The actual handler in your PageModel is OnGetEditAsync, which maps to handler=Edit.","Step 5: Fix and Verify","Change the button:","Refresh and test. The request now returns 200 and the edit form appears.","This pattern applies to any \"nothing happens\" scenario: open Network, trigger the action, check the status code, examine the URL and response."]},{"l":"21.2.2 Console Tab for Errors and Events","p":["The Console tab displays JavaScript errors and log output. htmx and Hyperscript both report errors here."]},{"l":"JavaScript Console Errors","p":["When htmx encounters a problem it can detect, it logs to the console. Common errors include:","This means hx-target specified an element that doesn't exist in the DOM.","The server returned an error status code.","Hyperscript also reports parsing errors:","This indicates a typo in your Hyperscript code.","Always check the Console tab when something doesn't work. Many issues produce explicit error messages."]},{"l":"Using htmx.logAll() for Verbose Logging","p":["htmx can log every event it processes. This verbose output helps understand the sequence of operations:","Run this in the Console tab, then trigger an htmx action. You'll see output like:","This shows the complete lifecycle: configuring the request, sending it, receiving the response, swapping content, and settling (running scripts in the new content).","If something fails, the chain breaks at a specific point. No htmx:beforeRequest? The trigger didn't fire. No htmx:afterRequest? The request failed. No htmx:afterSwap? The swap failed, possibly due to a missing target."]},{"l":"Custom Console Logging","p":["For ongoing debugging, add event listeners that log specific information:","Add these to your site.js file during development. They provide a running commentary of htmx activity without the noise of htmx.logAll()."]},{"l":"21.2.3 Elements Tab for DOM Inspection","p":["The Elements tab shows the current state of the DOM. Use it to verify htmx attributes and watch for changes."]},{"l":"Inspecting htmx Attributes","p":["Right-click any element and select \"Inspect\" to jump to it in the Elements tab. Expand the element to see its attributes:","Verify each attribute:","Is hx-get pointing to the correct URL?","Does the hx-target selector match an existing element?","Is the hx-swap value what you expect?","You can edit attributes directly in the Elements tab to test fixes before changing your code. Double-click an attribute value to modify it, then trigger the action again."]},{"l":"Using \"Break on Subtree Modifications\"","p":["When content changes unexpectedly, you can set a breakpoint that triggers whenever an element's children change:","Right-click the element in the Elements tab","Select \"Break on\" → \"subtree modifications\"","Trigger the htmx action","The debugger pauses when the DOM changes, showing you the call stack that caused the modification. This helps identify which swap or JavaScript code is modifying the element."]},{"l":"Testing CSS Selectors in Console","p":["If an hx-target selector isn't working, test it in the Console:","Note that htmx supports special selectors like closest, find, next, and previous that aren't standard CSS. You can't test these directly with querySelector, but you can test the underlying CSS selector."]},{"l":"Demo: Element Not Found After Swap","p":["Consider this scenario: clicking Edit works the first time, but the second click does nothing.","The Setup:","The handler returns an edit form that replaces the entire row:","The Problem:","The Cancel button targets #artist-row-1, but that element no longer exists. It was replaced by #artist-edit-1.","Debugging Steps:","Open Elements tab after clicking Edit","Search for artist-row-1- not found","The swap with outerHTML replaced the element, changing its ID","The Fix:","Use a consistent ID, or target a stable container:","This scenario illustrates why the Elements tab matters: it shows the actual DOM state, which might differ from what your code expects."]},{"l":"21.3 htmx Built-in Debugging Features","p":["htmx includes several features specifically designed for debugging. These work alongside browser DevTools to provide deeper insight into htmx behavior."]},{"l":"21.3.1 The htmx.logAll() Method","p":["The htmx.logAll() method enables verbose logging of all htmx events. This creates detailed output that traces every step of htmx processing."]},{"l":"Enabling in Development Only","p":["You don't want verbose logging in production. Use ASP.NET Core's environment detection to enable it conditionally:","In _Layout.cshtml:","Now logging activates automatically during development but stays off in production."]},{"l":"Understanding Event Lifecycle Output","p":["With logAll() enabled, triggering an htmx action produces output like this:","Each event represents a stage in the htmx lifecycle:","configRequest: htmx is configuring the request (you can modify it here)","beforeRequest: Request is about to be sent","afterRequest: Response received (check successful property)","beforeSwap: About to insert content into DOM","afterSwap: Content inserted","afterSettle: Any scripts in new content have run","When debugging, identify where the chain breaks. If you see configRequest but not beforeRequest, something prevented the request. If you see afterRequest with successful: false, the server returned an error."]},{"l":"Filtering Specific Events","p":["Full logging is verbose. For targeted debugging, listen to specific events instead:","This approach focuses on what matters while reducing console noise."]},{"l":"21.3.2 The htmx.config Object","p":["htmx's behavior is controlled by a configuration object. Inspecting and modifying this object helps diagnose certain issues."]},{"l":"Viewing Current Configuration","p":["In the browser console, type:","You'll see all current settings:"]},{"l":"Useful Settings for Debugging","p":["Disable History Cache:","When debugging back-button issues, disable caching to ensure fresh content loads on every navigation.","Increase Timeout:","When stepping through server-side code with a debugger, increase the timeout to prevent premature request failures.","Force History Refresh:","If history restoration fails (cache miss), this forces a full page refresh instead of showing stale content.","Check Default Swap Style:","If content is replacing elements when you expect it to replace children (or vice versa), verify the default swap style matches your expectations."]},{"l":"21.3.3 The htmx:responseError Event","p":["The htmx:responseError event fires when the server returns a 4xx or 5xx status code. Setting up a global handler for this event provides consistent error handling."]},{"l":"Global Error Handling Setup","p":["Add this to your site.js or a script block in your layout:","This handler provides both developer information (console log) and user feedback (toast or alert)."]},{"l":"Integration with Toast Notifications","p":["If you built the toast system from Chapter 21, integrate it:"]},{"l":"21.3.4 The htmx:beforeRequest and htmx:configRequest Events","p":["These events let you inspect and modify requests before they're sent."]},{"l":"Inspecting Outgoing Requests","p":["The htmx:configRequest event fires while htmx is configuring the request. The event detail contains:","This shows exactly what htmx will send, helping verify that parameters and headers are correct."]},{"l":"Modifying Requests for Debugging","p":["You can modify the request during htmx:configRequest:","On the server, check for these parameters:","You can also add custom headers:"]},{"l":"21.4 ASP.NET Core Server-Side Debugging","p":["Client-side tools show what the browser sends and receives. Server-side debugging reveals what happens between those two points."]},{"l":"21.4.1 Logging htmx Requests"},{"l":"Identifying htmx Requests in Handlers","p":["Check for the HX-Request header to determine if a request came from htmx:","This logs htmx-specific details that help trace request handling."]},{"l":"Complete HtmxLoggingMiddleware Implementation","p":["For complete logging across all htmx requests, create middleware:","Middleware/HtmxLoggingMiddleware.cs"]},{"l":"Registration in Program.cs","p":["Add the middleware in development only:","Now your development logs show htmx request flow:"]},{"l":"21.4.2 Debugging Partial View Returns","p":["One of the most common htmx issues is returning the wrong content from the server."]},{"l":"Common Issues","p":["Returning Page() Instead of Partial()","Wrong Partial View Path","Model Type Mismatch"]},{"l":"Diagnostic Extension Method","p":["Create an extension that logs partial view returns:","Extensions/PartialResultExtensions.cs","Use it in your handlers:"]},{"l":"Adding Debug Headers to Responses","p":["In development, add headers that help identify what was returned:","These headers appear in the Network tab's response headers, confirming what the server intended to return."]},{"l":"21.4.3 Anti-Forgery Token Debugging","p":["Anti-forgery token failures are among the most frustrating htmx issues because they silently fail with a 400 status code."]},{"l":"Common Issues and Symptoms","p":["Symptoms:","POST/PUT/DELETE requests return 400 Bad Request","Server logs show \"The required antiforgery cookie is not present\" or \"The antiforgery token could not be decrypted\"","Request works in a regular form but fails with htmx","Common Causes:","Token not included in htmx request headers","No form element with token on the page","[ValidateAntiForgeryToken] attribute missing from handler","Token expired","Cookie and token mismatch after deployment"]},{"l":"Debugging Token Flow","p":["Step 1: Verify Token Exists on Page","In browser console:","If this returns null, add a form with an anti-forgery token to your layout:","Step 2: Verify htmx Sends the Token","Check that your JavaScript includes the token in requests:","Step 3: Verify Server Receives the Token","Check the Network tab. Under Request Headers, you should see:","If the header is missing, the client-side code isn't attaching it.","Step 4: Verify Server Configuration","In Program.cs:","And verify your handler has the attribute:"]},{"l":"Complete Verification Code","p":["Add this diagnostic code temporarily to identify token issues:"]},{"l":"21.4.4 Debugging Model Binding","p":["Model binding transforms request data into handler parameters. When binding fails, parameters arrive as null or with unexpected values."]},{"l":"Logging Bound Values","p":["Add explicit logging to see what values arrive:","If values are null when you expect them to have data, check the parameter names match the form field names."]},{"l":"Diagnosing Binding Failures via ModelState","p":["When validation fails, check ModelState for binding errors:"]},{"l":"Common Binding Issues","p":["Parameter Name Mismatch:","Checkbox Binding:","Checkboxes only submit when checked. For unchecked state, you need a hidden field:","Array Binding:","Multiple values need matching names with proper indexing:","Debugging Request Body:","For complex binding issues, log the raw request:","This diagnostic approach reveals exactly what data the server received, independent of model binding."]},{"l":"21.5 Common htmx Problems and Solutions","p":["This section catalogs the most frequent htmx issues and provides systematic approaches to diagnose and fix each one. Each problem includes symptoms, debugging steps, root cause analysis, and complete solutions."]},{"l":"21.5.1 \"Nothing Happens\" When Clicking","p":["The most common htmx complaint: you click a button or link and nothing visible happens. No error, no feedback, no change."]},{"l":"Diagnostic Checklist","p":["1. Is htmx loaded?","2. Are there JavaScript errors?","200: Server succeeded, problem is with swap","204: No content returned, htmx does nothing (by design)","3. Does the element have htmx attributes?","4. Is a network request being made?","400: Bad request (often anti-forgery token)","404: Handler or page not found","5. What's the response status?","500: Server error","6. Does the response contain expected content?","7. Does the target element exist?","8. Is hx-swap correct for the situation?","Check the Console tab for red error messages. Any JavaScript error might prevent htmx from functioning.","Click the request in Network tab, check Response or Preview. Verify it's the HTML you expect.","If a request appears, check its status code:","If attributes are missing, check your Razor view source.","If hx-swap=outerHTML but you're returning content that should go inside the element, or vice versa, the result may look like nothing happened.","If this returns null, the target doesn't exist.","If this returns undefined, htmx isn't loaded. Check your script include.","In Console, test the selector:","Open browser console and type:","Open Network tab, filter to Fetch/XHR, then click the element. If no request appears, the trigger isn't firing.","Right-click the element, select Inspect, and verify htmx attributes are present:","Work through this checklist in order. Most \"nothing happens\" issues resolve within the first few items."]},{"l":"Common Causes with Code Examples","p":["htmx Not Processing Dynamic Content","When content is loaded via htmx, new elements in that content need htmx processing. By default, htmx processes new content automatically after swaps. But if you're adding content via other JavaScript, htmx won't know about it.","But if you add content with vanilla JavaScript:","Missing htmx.js Include","The script tag might be missing, misplaced, or failing to load:","Verify in Network tab that the script loads with status 200. A 404 means the file path is wrong.","Element Inside a Form with Conflicting Action"]},{"l":"Demo: The Silent Button","p":["Symptom: Clicking \"Load Artists\" does nothing. No console errors, no network activity.","The Code:","Debug Steps:","Console: typeof htmx returns undefined- htmx isn't loaded!","Check _ Layout.cshtml - the htmx script is there","Check if the Scripts section renders: look at page source, htmx script is missing from this page","Found it: _ Layout.cshtml has @RenderSection(Scripts, required: false) but the htmx include is inside that section in a _ Scripts partial, and this page has its own Scripts section that overrides it","Root Cause: The page's @section Scripts overrides the layout's script section, excluding the htmx include.","Solution:","Move htmx to the layout body, outside any section:","Prevention: Always include htmx in the main layout body, not in a replaceable section."]},{"l":"21.5.2 Content Replaces Wrong Element","p":["You click a button, content updates, but it appears in the wrong place or replaces the wrong element."]},{"l":"Duplicate ID Problems","p":["HTML IDs must be unique. When multiple elements share an ID, querySelector returns only the first one.","Symptom: Editing artist row 5 updates artist row 1 instead.","The Problem:","The Fix:","Debug Technique:"]},{"l":"Target Doesn't Exist When Response Arrives","p":["The target element might be removed by a previous operation or never existed.","Symptom: First click works, subsequent clicks do nothing.","The Problem:","The form's hx-target points to #modal-container, which was replaced by #create-modal.","The Fix:","Option 1: Use hx-swap=innerHTML to preserve the container:","Option 2: Update the form's target to match the new structure:"]},{"l":"Debugging Target Resolution","p":["Add an event listener that warns when targets don't exist:","This logs a warning before the request is made if the target element doesn't exist."]},{"l":"Demo: Second Click Fails","p":["Symptom: Click \"Edit\" on a row, the edit form appears. Click \"Cancel\" and nothing happens.","The Code:","Debug Steps:","First click: Network shows 200, row becomes edit form - working","Click Cancel: Network shows 200, nothing changes","Check Console: \"htmx target not found: #artist-row-1\" (if using our debug listener)","Elements tab: search for \"artist-row-1\" - not found, only \"artist-edit-1\" exists","Root Cause: The outerHTML swap replaced #artist-row-1 with #artist-edit-1. The Cancel button still targets the old ID.","Solution: Use consistent IDs or relative targeting:"]},{"l":"21.5.3 OOB Updates Not Working","p":["Out-of-band (OOB) updates let a single response update multiple page areas. When they fail, only the primary target updates."]},{"l":"Troubleshooting Steps","p":["1. Verify OOB element has correct attribute","The element in the response must have hx-swap-oob:","2. Verify target element exists in DOM","The OOB element's ID must match an existing element:","3. Check OOB element is at root level of response","OOB elements must be direct children of the response, not nested inside other elements:","4. Verify OOB value syntax","Valid values include:","true- replace element (same as outerHTML)","innerHTML- replace element's content","outerHTML- replace entire element","beforebegin, afterbegin, beforeend, afterend- insert adjacent","delete- remove the target element","none- do nothing (useful for conditional updates)"]},{"l":"Demo: OOB Element ID Mismatch","p":["Symptom: Creating a new artist adds the row but doesn't update the count badge.","The Response:","The Page:","Debug Steps:","Network tab shows 200 response with both elements","Table row appears (primary swap worked)","Count still shows 275 (OOB failed)","Response Preview shows id=artistCount(camelCase)","Elements tab shows page has id=artist-count(kebab-case)","Root Cause: ID mismatch due to inconsistent naming convention.","Solution: Use consistent ID naming:"]},{"l":"Debugging OOB with Events","p":["htmx fires events for OOB processing:"]},{"l":"21.5.4 Forms Submit But Data Is Lost","p":["The form submits, the server receives the request, but form field values are missing or empty."]},{"l":"Button Outside Form Problem","p":["Buttons with htmx attributes outside a form don't automatically include form data.","Symptom: Server receives POST request but all form values are null.","The Problem:","The Fix:","Option 1: Move button inside form:","Option 2: Use hx-include to specify form:","Option 3: Use form attribute (HTML5):"]},{"l":"hx-include vs Form Containment","p":["hx-include specifies additional elements to include in the request. Understanding its behavior prevents data loss:","Both included-by-form and extra are sent because the button is inside the form AND specifies hx-include.","Common Mistake:"]},{"l":"Debugging Form Data","p":["Add a listener that logs exactly what htmx will send:","This logs parameters before the request is sent, showing exactly what data htmx collected."]},{"l":"21.5.5 Anti-Forgery Token Failures","p":["Anti-forgery token issues cause cryptic 400 errors that give little indication of the actual problem."]},{"l":"Symptoms","p":["Network Tab Shows:","Status: 400 Bad Request","Response may contain: \"The required antiforgery cookie is not present\" or \"The antiforgery token could not be decrypted\"","Console Shows:","htmx:responseError with status 400","No JavaScript errors (this is a server-side rejection)","Server Logs Show:","\"Antiforgery token validation failed\"","\"The required antiforgery form field '__ RequestVerificationToken' is not present\""]},{"l":"4-Step Diagnostic Process","p":["Step 1: Verify Token Exists in Page","If null, add a form with anti-forgery to your layout:","Step 2: Verify JavaScript Sends Token","Check that your htmx configuration includes the token:","Test by adding logging:","Step 3: Verify Server Receives Token","Check Network tab, click the failed request, look at Request Headers:","If missing, the JavaScript isn't attaching it. If present, continue to step 4.","Step 4: Verify Server Configuration","Check Program.cs:","Check handler has attribute:"]},{"l":"Complete Solution Implementation","p":["_Layout.cshtml:","Program.cs:","Handler:"]},{"l":"21.5.6 History/Back Button Issues","p":["htmx can integrate with browser history, but misconfiguration leads to confusing back-button behavior."]},{"l":"Common Problems","p":["Stale Content on Back Button","After navigating forward with htmx, pressing back shows outdated content.","URL Doesn't Update","User applies filters but the URL stays the same, making the view non-bookmarkable.","Scroll Position Lost","After navigating back, page scrolls to top instead of previous position."]},{"l":"Debugging History Events","p":["htmx fires events during history operations:"]},{"l":"Demo: Filters Not Preserved on Back Button","p":["Symptom: Search for \"AC/DC\", results appear. Click an artist to view details. Press back. Search is gone, showing all artists.","The Code:","Debug Steps:","Type \"AC/DC\" in search - URL stays /Artists","Click artist - URL stays /Artists","Press back - URL still /Artists, content jumps to all artists","No htmx:pushedIntoHistory events in console","Root Cause: Neither the search nor the detail link uses hx-push-url, so the browser history never records the filtered state.","Solution:","Now the URL updates with each action, and back button restores previous content.","Additional Fix - Server-Side Support:","The server must handle direct navigation to filtered URLs:"]},{"l":"21.6 Debugging Hyperscript","p":["Hyperscript provides client-side interactivity through a human-readable syntax. When Hyperscript doesn't work as expected, debugging requires understanding its unique error reporting and syntax rules."]},{"l":"21.6.1 Hyperscript Syntax Errors","p":["Hyperscript has its own syntax distinct from JavaScript. Common mistakes come from mixing the two."]},{"l":"JavaScript Syntax in Hyperscript","p":["Wrong: Using JavaScript method calls","Hyperscript doesn't understand JavaScript syntax. This silently fails or produces parsing errors.","Correct: Using Hyperscript syntax","Wrong: JavaScript conditionals","Correct: Hyperscript conditionals","Wrong: JavaScript string concatenation","Correct: Hyperscript string interpolation"]},{"l":"Missing 'then' Between Actions","p":["Hyperscript commands must be chained with then:","Wrong: Missing connectors","This might partially work or fail unpredictably.","Correct: Chain with 'then'"]},{"l":"Wrong Element References","p":["Hyperscript has specific syntax for referencing elements:","Wrong: JavaScript-style element access","Correct: Hyperscript element references"]},{"l":"Enabling Hyperscript Debug Mode","p":["Hyperscript can output debug information:","With debug mode enabled, Hyperscript logs parsing information and execution details to the console.","You can also add inline debugging:"]},{"l":"21.6.2 Hyperscript Event Issues","p":["Events in Hyperscript follow specific patterns that differ from JavaScript event handling."]},{"l":"Event Bubbling Considerations","p":["By default, Hyperscript's on click triggers when the element or any descendant is clicked:","To handle only direct clicks:"]},{"l":"Being Specific About Event Targets","p":["Filter events to specific child elements:","The from selector/ in me pattern limits which descendant elements trigger the handler."]},{"l":"Adding Logging to Hyperscript","p":["The log command outputs to the console:","For complex debugging, create a verbose handler:"]},{"l":"21.6.3 htmx Event Integration","p":["Hyperscript can listen to htmx events, enabling coordination between htmx requests and client-side behavior."]},{"l":"Correct Event Name Casing","p":["htmx event names use camelCase after the colon. Getting the case wrong causes silent failures:","Wrong: All lowercase","Wrong: All caps","Correct: Proper camelCase","Common htmx events to listen for:","htmx:configRequest- Before request is configured","htmx:beforeRequest- Just before request is sent","htmx:afterRequest- After response received","htmx:beforeSwap- Before content is swapped","htmx:afterSwap- After content is swapped","htmx:afterSettle- After settling (scripts run, etc.)","htmx:responseError- Server returned error status"]},{"l":"Complete Example: Form with Multiple htmx Event Handlers","p":["This example shows a form with full htmx lifecycle handling in Hyperscript:"]},{"l":"Debugging Integration Issues","p":["When Hyperscript doesn't respond to htmx events:","1. Verify the event fires","Add a JavaScript listener to confirm htmx fires the event:","If this logs but Hyperscript doesn't respond, the issue is in Hyperscript.","2. Check event name spelling and case","3. Verify element receives the event","htmx events bubble up from the target element. If your Hyperscript is on an unrelated element, it won't receive the event:","Fix by listening on body or a common ancestor:","Or target the specific element:","4. Check event.detail properties","Different events provide different details:","Use log event.detail to see all available properties:","This outputs the entire detail object to the console, showing what data is available."]},{"l":"21.7 Debugging Workflow: A Systematic Approach","p":["Random debugging wastes time. Clicking around and changing things hoping something works is inefficient and often introduces new problems. A systematic approach finds root causes faster and produces reliable fixes."]},{"l":"21.7.1 The Five-Step Debug Process","p":["This process applies to any htmx issue, from simple attribute typos to complex timing problems."]},{"l":"Step 1: Reproduce Consistently","p":["A bug you can't reproduce is a bug you can't fix with confidence. Spend time here until you have reliable reproduction steps.","Actual result (what happens instead?)","Any browser extensions that might interfere?","Authenticated or anonymous user?","Before debugging, you need a reliable way to trigger the bug.","Browser and version (Chrome 120, Firefox 121, etc.)","Check for intermittent behavior:","Development or production?","Document the exact steps:","Does it happen every time?","Expected result (what should happen?)","Note the environment:","Only the first time? Only after the first time?","Only with certain data?","Starting state (fresh page load? after specific actions?)","User action (what exactly do you click/type?)"]},{"l":"Step 2: Isolate the Layer","p":["htmx applications have multiple layers where problems can occur. Identify which layer contains the bug:","Decision tree for isolation:","Is a network request made?(Check Network tab)","No → Problem is client-side (htmx attributes, triggers, JavaScript)","Yes → Continue to step 2","What's the response status?","4xx/5xx → Problem is server-side (handler, validation, database)","200 → Continue to step 3","Is the response content correct?","No → Problem is server-side (wrong partial, model issue)","Yes → Continue to step 4","Does the content appear in the right place?","No → Problem is client-side (hx-target, hx-swap)","Yes → Problem might be CSS or content issue"]},{"l":"Step 3: Gather Evidence","p":["Application logs","Attribute values on triggering element","Client-side evidence:","Console errors and warnings","Database query results","Debugger output (breakpoint values)","DOM state before and after (Elements tab screenshots)","Exception details if any","Full URL including query parameters","htmx event log ( htmx.logAll() output)","Keep notes or screenshots. You'll need to compare before and after states.","Network evidence:","Once you know which layer to focus on, collect relevant data:","Request headers (especially HX-* headers)","Response body content","Response headers","Response status code","Server-side evidence:"]},{"l":"Step 4: Form and Test Hypothesis","p":["Based on the evidence, form a specific hypothesis about what's wrong.","Good hypothesis:\"The Cancel button's hx-target points to #artist-row-1, but the Edit swap changed that element's ID to #artist-edit-1\"","Bad hypothesis:\"Something's wrong with htmx\"","Test your hypothesis with a minimal change:","If you think the ID is wrong, change just the ID","If you think the handler name is wrong, fix just the handler name","Don't change multiple things at once","If the fix doesn't work, your hypothesis was wrong. Return to Step 3 and gather more evidence."]},{"l":"Step 5: Fix and Verify","p":["When you find the fix:","Implement the fix properly- Don't just patch the symptom","Test the original reproduction steps- Does the bug still occur?","Test related functionality- Did you break anything else?","Test edge cases- Empty data, special characters, rapid clicks","Document what you learned. If this bug could happen elsewhere in the codebase, check those places too."]},{"l":"21.7.2 Debug Scenario Walkthrough","p":["Let's walk through a complete debugging session using the Chinook Dashboard."]},{"l":"The Bug Report","p":["Reported behavior:\"When I edit an artist name and click Save, the old name still shows.\""]},{"i":"step-1-reproduce-consistently-1","l":"Step 1: Reproduce Consistently","p":["Reproduction steps:","Navigate to /Artists","Click Edit on any artist (e.g., \"AC/DC\")","Change the name to \"AC/DC Updated\"","Click Save","Expected: Row shows \"AC/DC Updated\"","Actual: Row shows \"AC/DC\" (original name)","Environment: Chrome 120, development mode, localhost:5001","Consistency: Happens every time, with any artist."]},{"i":"step-2-isolate-the-layer-1","l":"Step 2: Isolate the Layer","p":["Check 1: Is a request made?","Open Network tab, filter to Fetch/XHR, reproduce the bug.","Yes, request is made. Status 200 means server processed it successfully.","Check 2: Is the response correct?","Click the request, view Response tab:","The response contains \"AC/DC Updated\" - the correct, updated name. Server is working correctly.","Conclusion: Problem is client-side. The server returns correct data, but it's not displaying."]},{"i":"step-3-gather-evidence-1","l":"Step 3: Gather Evidence","p":["htmx event log:","Enable logging and reproduce:","Notice: beforeSwap shows target: tr#artist-edit-1","DOM inspection before Save:","Check Elements tab for the edit form:","The form's hx-target is #artist-row-1.","DOM inspection - search for artist-row-1:","Search in Elements tab: \"artist-row-1\" - Not found","The edit form replaced #artist-row-1 with #artist-edit-1. The target no longer exists."]},{"i":"step-4-form-and-test-hypothesis-1","l":"Step 4: Form and Test Hypothesis","p":["Hypothesis: The form targets #artist-row-1, but that element doesn't exist (it was replaced by #artist-edit-1). htmx can't find the target, so it uses a fallback or fails silently.","Test: Check htmx behavior for missing targets.","Looking at htmx documentation: when a target isn't found, htmx falls back to the element that triggered the request (the form itself). But the form is inside #artist-edit-1, so the swap replaces content inside the edit row, not the edit row itself.","Let's verify by checking what actually happened:","The response was inserted inside the edit row, creating invalid nested table rows. The browser may render this unexpectedly or the original edit form content may still be visible.","Hypothesis confirmed: Target mismatch causes incorrect swap location."]},{"i":"step-5-fix-and-verify-1","l":"Step 5: Fix and Verify","p":["The fix: Keep the ID consistent, or use a stable target.","Option A: Same ID throughout","Edit row partial keeps the original ID:","Option B: Use relative target","Verification:","Edit artist, change name, click Save - ✅ Shows updated name","Edit same artist again - ✅ Edit form appears","Edit different artist - ✅ Works correctly","Cancel edit - ✅ Returns to view mode","Rapid edit/save/edit - ✅ No issues","Root cause documented: When entering edit mode, the row ID changed from artist-row-X to artist-edit-X. The save form targeted the original ID, which no longer existed. Fix: maintain consistent IDs or use relative selectors."]},{"l":"21.7.3 Creating a Debug Page","p":["A dedicated debug page helps test htmx behavior in isolation. Build one into your development environment."]},{"l":"Debug Page Model","p":["Pages/Debug/Index.cshtml.cs"]},{"l":"Debug Page View","p":["Pages/Debug/Index.cshtml"]},{"l":"21.8 Production Debugging Considerations","p":["Development debugging with browser DevTools and console.log doesn't work in production. You need logging, error reporting, and diagnostic tools that work without direct browser access."]},{"l":"21.8.1 Error Logging for htmx Requests","p":["Production errors need structured logging that captures context without exposing sensitive data.","Middleware/HtmxErrorLoggingMiddleware.cs"]},{"l":"Integration with Serilog","p":["For structured logging with Serilog, the above middleware works as-is. Configure Serilog in Program.cs:"]},{"l":"21.8.2 Client-Side Error Reporting","p":["Capture client-side errors and send them to the server for logging.","wwwroot/js/error-reporting.js","API Endpoint for Receiving Errors"]},{"l":"21.8.3 Feature Flags for Debug Mode","p":["Control debug features based on environment and configuration.","Program.cs","Conditional htmx.logAll() in Layout","appsettings.Production.json","appsettings.Development.json"]},{"l":"21.9 Summary","p":["Debugging htmx applications requires understanding both client-side and server-side behavior. The techniques in this chapter provide a systematic approach to finding and fixing issues."]},{"l":"Key Debugging Tools","p":["Tool","Purpose","When to Use","Browser Network Tab","Inspect requests and responses","Always start here for htmx issues","Browser Console","View errors, run htmx.logAll()","JavaScript errors, event tracing","Browser Elements Tab","Inspect DOM and htmx attributes","Target issues, attribute verification","Server Logs","Track server-side processing","Handler execution, database issues"]},{"l":"Essential htmx Debug Methods","p":["Configuration issues","Debug OOB updates","Development debugging","Global error handling","Handle server errors","htmx:afterSwap","htmx:configRequest","htmx:oobAfterSwap","htmx:responseError","htmx.config","htmx.logAll()","Inspect/modify requests","Log all htmx events","Method/Event","OOB swap completion","Post-swap processing","Purpose","Request debugging, token injection","Usage","Verify swaps completed","View/modify htmx settings"]},{"l":"The Systematic Debugging Approach","p":["Reproduce- Document exact steps to trigger the bug","Isolate- Determine if issue is client, network, or server","Gather- Collect evidence from appropriate tools","Hypothesize- Form specific theory about root cause","Verify- Test fix and check for regressions"]},{"l":"Common Issues Quick Reference","p":["_ hyperscript.config.debug","400 Bad Request","404 Not Found","Anti-forgery token missing","Back button stale","Button outside form","Console errors, Network tab","Content in wrong place","Debug Focus","Duplicate ID issues","Elements tab search","Form data missing","History events","htmx not loaded, JS error, no trigger","hx-include, form structure","Hyperscript silent fail","ID consistency","Likely Cause","Missing hx-push-url","Non-unique IDs in loop","Nothing happens on click","Old data after save","OOB not updating","Request headers, token config","Response HTML, DOM IDs","Symptom","Syntax error","Target changed by edit","Target element existence","Target ID mismatch","URL in Network tab","Wrong handler name, typo","Wrong hx-target selector"]},{"l":"Companion Code Files"},{"l":"What's Next","p":["Chapter 23 covers testing strategies for htmx applications. You'll learn to write integration tests that verify htmx interactions, test partial responses, and automate the verification of complex multi-step workflows. The debugging skills from this chapter form the foundation for understanding what to test and how to verify correct behavior."]}],[{"l":"Testing htmx Applications","p":["A well-tested application gives confidence that changes won't break existing functionality. Testing htmx applications requires techniques beyond traditional web testing because htmx fundamentally changes how pages update. This chapter covers testing strategies from unit tests through full browser automation, providing patterns you can apply to any htmx project."]},{"l":"22.1 Introduction"},{"l":"Why Testing htmx Applications Requires Special Consideration","p":["Traditional ASP.NET Core testing focuses on complete page responses. You request a URL, receive HTML, and verify the content. htmx applications work differently in several ways that affect testing strategy.","Partial Responses: Most htmx requests return HTML fragments, not complete pages. A handler might return just a table row or a form, without the surrounding layout. Tests must verify these fragments contain the correct content and htmx attributes without expecting full page structure.","htmx Attributes Drive Behavior: The attributes on HTML elements determine what htmx does. A missing hx-target or incorrect hx-swap value causes bugs that don't produce server errors. Tests must verify these attributes exist and have correct values.","Dynamic DOM Updates: htmx replaces, appends, or removes DOM elements based on server responses. Testing that a search filter works requires verifying not just that the server returns correct data, but that the browser correctly updates the visible page.","Out-of-Band Updates: A single response can update multiple page regions through OOB swaps. Tests must parse responses to find OOB elements and verify they target the correct elements with correct content.","Client-Side Interactions: Hyperscript behaviors, keyboard shortcuts, and timed actions like toast auto-dismiss happen entirely in the browser. Unit and integration tests can't verify these; you need browser automation."]},{"l":"The Testing Pyramid for htmx Applications","p":["The testing pyramid remains valid for htmx applications, but the middle layer (integration tests) becomes more important.","Unit Tests verify business logic in isolation: service methods, view model calculations, helper functions. These run fast and catch logic errors early.","Integration Tests verify that Razor Page handlers return correct partial HTML with proper htmx attributes. This layer is larger for htmx applications than traditional MVC because so much behavior depends on the HTML structure and attributes.","Browser Tests verify that htmx actually performs the expected updates in a real browser. These are slower but necessary for testing dynamic interactions, Hyperscript behaviors, and complex multi-step workflows."]},{"l":"What This Chapter Covers","p":["This chapter walks through testing at each level:","Unit testing services, view models, and helper methods","Setting up integration test infrastructure with WebApplicationFactory","Testing partial responses and verifying htmx attributes","Testing response headers (HX-Trigger, HX-Push-Url)","Parsing and testing OOB updates","Browser automation with Playwright for dynamic interactions","Testing Hyperscript behaviors and keyboard interactions","Testing error scenarios and validation","Organizing tests and running them in CI/CD","The examples use the Chinook Dashboard from Chapter 21. You'll build a test project that verifies the dashboard's functionality at every level."]},{"l":"22.2 Unit Testing the Server Side","p":["Unit tests verify individual components in isolation. For htmx applications, this means testing services, view models, and helper methods without involving HTTP requests or HTML rendering."]},{"l":"22.2.1 Testing Services","p":["Services contain business logic and data access. Test them using an in-memory database to avoid external dependencies."]},{"l":"Test Project Setup","p":["Create a test project alongside your main project:","ChinookDashboard.Tests.csproj"]},{"l":"Testing with In-Memory Database","p":["Create a base class for service tests that sets up an in-memory SQLite database:","Unit/ServiceTestBase.cs"]},{"l":"Complete ArtistServiceTests","p":["Unit/Services/ArtistServiceTests.cs"]},{"l":"22.2.2 Testing View Models","p":["View models often contain computed properties and transformation logic. Test these independently of the data layer."]},{"l":"Testing Computed Properties","p":["Unit/Models/TrackSummaryTests.cs"]},{"l":"Testing PaginatedList","p":["Unit/Models/PaginatedListTests.cs"]},{"l":"22.2.3 Testing Helper Methods","p":["Test extension methods and helpers that support htmx functionality.","Unit/Helpers/HtmxExtensionTests.cs","Unit/Helpers/ToastHelperTests.cs"]},{"l":"22.3 Integration Testing Razor Page Handlers","p":["Integration tests verify that your Razor Page handlers return correct HTML with proper htmx attributes. These tests use WebApplicationFactory to host the application in-memory and send real HTTP requests."]},{"l":"22.3.1 Setting Up Test Infrastructure"},{"l":"ChinookTestFactory","p":["Create a custom factory that configures the application for testing:","Integration/Fixtures/ChinookTestFactory.cs"]},{"l":"Integration Test Base Class","p":["Integration/IntegrationTestBase.cs"]},{"l":"htmx Request Helper Extensions","p":["Integration/Common/HttpClientHtmxExtensions.cs"]},{"l":"22.3.2 Testing Full Page Requests","p":["Test that full page loads return complete HTML with all required elements.","Integration/Artists/ArtistPageTests.cs"]},{"l":"22.3.3 Testing Partial Responses","p":["Test that htmx requests return partial HTML without layout.","Integration/Artists/ArtistPartialTests.cs"]},{"l":"22.3.4 Testing htmx Response Headers","p":["Test that handlers set correct htmx response headers.","Integration/Artists/ArtistResponseHeaderTests.cs"]},{"l":"22.3.5 Testing OOB Updates","p":["Test that responses include correct OOB update elements.","Integration/Artists/ArtistOobTests.cs"]},{"l":"HTML Parsing Helpers","p":["Create a helper class for common HTML assertions:","Integration/Common/HtmlAssertions.cs"]},{"l":"Running the Tests","p":["Execute tests from the command line:","The integration tests verify that your Razor Page handlers return correct HTML for both full page and htmx partial requests. They confirm htmx attributes are present and correct, response headers are set properly, and OOB updates target the right elements. This level of testing catches most htmx-related bugs before they reach the browser."]},{"l":"22.4 Testing htmx Attributes and HTML Structure","p":["Integration tests verify that HTML responses contain correct htmx attributes. This section provides tools and patterns for parsing HTML and asserting on htmx-specific elements."]},{"l":"22.4.1 HTML Parsing Strategies","p":["AngleSharp provides a DOM parser that works like browser JavaScript, letting you query elements with CSS selectors and read attributes."]},{"l":"Setting Up AngleSharp","p":["AngleSharp is already in the test project dependencies. Create a helper class for common parsing operations:","Integration/Common/HtmlParsingHelper.cs"]},{"l":"22.4.2 Creating Custom htmx Assertions","p":["Create a dedicated assertions class with clear error messages that show actual vs expected values.","Integration/Common/HtmxAssertions.cs"]},{"l":"22.4.3 Testing Attribute Correctness","p":["With parsing helpers and assertions in place, write tests that verify htmx attributes are correct.","Integration/Tracks/TrackRowAttributeTests.cs"]},{"l":"22.4.4 Testing Form Structure","p":["Forms need correct field names, anti-forgery tokens, and htmx attributes.","Integration/Artists/ArtistEditFormTests.cs"]},{"l":"22.5 Browser Testing with Playwright","p":["Integration tests verify HTML structure but can't verify that htmx actually updates the DOM correctly. Browser tests with Playwright automate a real browser to test full user interactions."]},{"l":"22.5.1 Setting Up Playwright for ASP.NET Core","p":["Playwright requires setup to run the ASP.NET Core application and control a browser."]},{"l":"Installing Browsers","p":["After adding the Playwright package, install browsers:","Or add a build target to install automatically:"]},{"l":"PlaywrightFixture","p":["Create a fixture that starts the application and provides the browser:","Browser/Fixtures/PlaywrightFixture.cs"]},{"l":"Alternative: Simpler Fixture Using WebApplicationFactory","p":["For most scenarios, a simpler approach using WebApplicationFactory with a known port works well:","Browser/Fixtures/PlaywrightFixture.cs(Simplified Version)"]},{"l":"PlaywrightTestBase","p":["Create a base class for browser tests:","Browser/PlaywrightTestBase.cs"]},{"l":"22.5.2 Testing htmx Interactions","p":["Test that htmx requests work without causing full page reloads.","Browser/Artists/ArtistSearchTests.cs"]},{"l":"22.5.3 Testing Dynamic DOM Updates","p":["Test that content swaps work correctly.","Browser/Artists/InlineEditTests.cs"]},{"l":"22.5.4 Testing OOB Updates in Browser","p":["Verify that OOB swaps update multiple elements.","Browser/Artists/DeleteWithOobTests.cs"]},{"l":"22.5.5 Testing Modals and Dialogs","p":["Test the complete modal workflow.","Browser/Artists/CreateArtistModalTests.cs"]},{"l":"Running Browser Tests","p":["Browser tests verify the complete user experience, catching issues that integration tests miss: JavaScript errors, htmx processing, DOM updates, and visual feedback. They run slower than integration tests, so use them for critical user workflows rather than exhaustive coverage."]},{"l":"22.6 Testing Hyperscript Behaviors","p":["Hyperscript runs entirely in the browser. Testing Hyperscript behaviors requires browser automation to verify that classes toggle, focus moves, and timed behaviors work correctly."]},{"l":"22.6.1 Testing Client-Side State Changes","p":["Hyperscript often manages UI state through class changes. Test that clicking elements updates classes correctly.","Browser/Hyperscript/TabSelectionTests.cs"]},{"l":"22.6.2 Testing Keyboard Interactions","p":["Test keyboard shortcuts implemented with Hyperscript.","Browser/Hyperscript/KeyboardNavigationTests.cs"]},{"l":"22.6.3 Testing Auto-Dismiss Behaviors","p":["Test time-based behaviors like toast notifications that auto-dismiss.","Browser/Hyperscript/ToastAutoDismissTests.cs"]},{"l":"22.6.4 Testing Focus Management","p":["Test that focus moves correctly for accessibility and usability.","Browser/Hyperscript/EditFormFocusTests.cs"]},{"l":"22.7 Testing Error Scenarios","p":["Test that your application handles errors gracefully, showing appropriate messages and maintaining usable state."]},{"l":"22.7.1 Testing Server Error Handling","p":["Test responses to various HTTP error status codes.","Browser/Errors/ServerErrorTests.cs"]},{"l":"22.7.2 Testing Validation Errors","p":["Test form validation feedback.","Browser/Errors/FormValidationTests.cs"]},{"l":"22.7.3 Testing Network Errors","p":["Test behavior when network connectivity is lost.","Browser/Errors/NetworkErrorTests.cs"]},{"l":"22.7.4 Testing Timeout Behavior","p":["Test handling of slow or timing-out requests.","Browser/Errors/TimeoutTests.cs"]},{"l":"22.8 Test Organization and Best Practices","p":["Good test organization makes tests easier to maintain, run, and understand."]},{"l":"22.8.1 Organizing Test Files","p":["Structure your test project by test type and feature:","Naming Conventions:","Test classes: {Feature}{TestType}Tests.cs(e.g., ArtistSearchTests.cs)","Test methods: {Action}_{Condition}_{ExpectedResult}(e.g., Search_WithMatchingTerm_ReturnsFilteredResults)","Use descriptive names that read like requirements"]},{"l":"22.8.2 Test Data Management","p":["Create a centralized seeding class for consistent test data.","TestData/SeedData.cs"]},{"l":"22.8.3 Test Utilities and Shared Code","p":["Create helpers for common testing patterns.","Browser/Common/PlaywrightHelpers.cs","Integration/Common/TestHelpers.cs"]},{"l":"22.8.4 Continuous Integration","p":["Configure GitHub Actions to run tests automatically.",".github/workflows/test.yml"]},{"l":"22.9 Summary","p":["Testing htmx applications requires a multi-layered approach. Unit tests verify business logic, integration tests verify HTML structure and htmx attributes, and browser tests verify actual user interactions."]},{"l":"Testing Strategy","p":["Browser","Business logic, calculations, data access","Fast (ms)","Full interactions, JavaScript","Handlers, partials, attributes","HTML structure, htmx attributes, response headers","Integration","Medium (seconds)","Playwright","Scope","Services, models, helpers","Slow (seconds)","Speed","Test Type","Tools","Unit","User workflows, Hyperscript, dynamic updates","WebApplicationFactory, AngleSharp","When to Use","xUnit, in-memory database"]},{"l":"Key Testing Patterns","p":["client.HtmxGetAsync(url, target)","context.SetOfflineAsync(true)","document.QuerySelector([hx-get])","document.QuerySelectorAll([hx-swap-oob])","Example","Extract OOB update elements","HTML Parsing","htmx Assertions","htmx Request Headers","HtmxAssertions.HasHxTarget(element, #target)","Keyboard Simulation","Network error handling","Offline Testing","OOB Parsing","page.Keyboard.PressAsync(Escape)","page.WaitForResponseAsync(predicate)","Pattern","Purpose","Response Headers","response.Headers[HX-Trigger]","Simulate htmx requests","Sync browser tests","Test HX-Trigger, HX-Push-Url","Test shortcuts","Verify DOM structure","Verify htmx attributes","Wait for Response"]},{"l":"Test Coverage Checklist","p":["All service methods (CRUD operations)","Browser Tests Should Cover:","Delete with confirmation","Error scenarios show feedback","Form fields match handler parameters","Forms have anti-forgery tokens","Full page loads return complete HTML","Helper method logic","htmx attributes have correct values","Inline edit complete workflow","Integration Tests Should Cover:","Keyboard shortcuts work","Modal open/submit/close cycle","OOB elements target correct IDs","OOB updates change multiple elements","Pagination calculations","Partial responses don't include layout","Response headers are set correctly","Search filters results without page reload","Toast appears and auto-dismisses","Unit Tests Should Cover:","View model computed properties"]},{"l":"Common Testing Pitfalls","p":["Timing Issues:","Always use explicit waits ( WaitForSelector, WaitForResponse)","Avoid arbitrary WaitForTimeout when possible","Add small buffers after dynamic operations","Flaky Tests:","Use unique data for each test (GUIDs)","Reset state between tests","Don't depend on test execution order","Anti-Patterns:","Testing implementation details instead of behavior","Over-mocking (hiding real bugs)","Ignoring error paths","Skipping browser tests for \"simple\" features"]},{"l":"Companion Code Files","p":["This chapter covered testing strategies for htmx applications from unit tests through browser automation. The patterns and tools presented here provide a foundation for maintaining quality as your application grows. Well-tested htmx applications give confidence that changes won't break existing functionality and that users will have a smooth, responsive experience."]}],[{"l":"Deploying htmx Applications on Azure","p":["Building an htmx application is only half the work. Getting it running reliably in production requires careful configuration, proper infrastructure, and automated deployment pipelines. This chapter takes the Chinook Dashboard from development to a production-ready Azure deployment."]},{"l":"23.1 Introduction"},{"l":"Why Deployment Matters for htmx Applications","p":["htmx applications have specific characteristics that affect deployment strategy. Understanding these helps you make better infrastructure decisions.","Latency Sensitivity: htmx makes frequent small requests. Each button click, form submission, or search keystroke triggers a server round-trip. High latency makes applications feel sluggish. Server proximity to users matters more than with traditional page-based applications.","Partial Response Compression: htmx responses are often small HTML fragments. A table row might be 500 bytes, a form 2KB. Compression algorithms work best on larger payloads, but even small gains add up when users generate dozens of requests per session.","Caching Opportunities: Some htmx responses are highly cacheable. A genre dropdown or static list doesn't change often. Proper cache headers reduce server load and improve response times.","Static Asset Optimization: htmx.js, Hyperscript, and your CSS are requested on every page load. CDN delivery and aggressive caching for these files significantly improves initial page load."]},{"l":"Azure Hosting Options","p":["Azure offers several ways to host ASP.NET Core applications:","Azure App Service is the focus of this chapter. It provides managed hosting with automatic OS patching, built-in load balancing, deployment slots, and easy scaling. Best for most web applications.","Azure Container Apps runs containerized applications with automatic scaling, including scale-to-zero. Good if you want container portability without managing Kubernetes.","Azure Kubernetes Service (AKS) provides full Kubernetes orchestration. Best for complex microservices architectures or teams already invested in Kubernetes.","Azure Static Web Apps hosts static files with optional API backends. Not ideal for htmx applications since server-side rendering is central to the pattern.","For the Chinook Dashboard, App Service provides the right balance of simplicity, features, and cost. The patterns in this chapter apply to other hosting options with minor modifications."]},{"l":"What This Chapter Covers","p":["This chapter walks through:","Preparing the application for production (configuration, compression, assets)","Creating Azure resources (App Service, SQL Database, Key Vault)","Building CI/CD pipelines with GitHub Actions","htmx-specific deployment considerations (caching partials, error handling)","Monitoring with Application Insights","Scaling and performance optimization","Security hardening","By the end, you'll have a fully automated pipeline that builds, tests, and deploys your htmx application to Azure."]},{"l":"23.2 Preparing Your Application for Production","p":["Before deploying, configure your application for production workloads. Development defaults prioritize convenience; production requires security, performance, and reliability."]},{"l":"23.2.1 Environment-Specific Configuration","p":["appsettings.{Environment}.json(environment-specific)","appsettings.json(base configuration)","appsettings.Production.json","ASP.NET Core loads configuration from multiple sources in a specific order. Later sources override earlier ones:","Azure App Settings: Set in the Azure Portal or via CLI","Azure Key Vault: For highly sensitive secrets with audit logging","Command-line arguments","Connection strings: Use placeholder values. Actual secrets come from Azure App Settings or Key Vault.","Environment variables","Environment variables: Set by the deployment platform","Feature flags: Disable development features in production.","htmx settings: These values can be injected into your layout for client-side configuration.","Key points about this configuration:","Logging levels: Set Microsoft namespaces to Warning to reduce noise. Keep your application namespace at Information for useful operational logs.","Managing Secrets","Never commit secrets to source control. The appsettings.Production.json contains structure but not actual secrets. Sensitive values come from:","The ASPNETCORE_ENVIRONMENT variable determines which environment file loads. Azure App Service sets this to \"Production\" by default."]},{"l":"23.2.2 Optimizing Static Assets","p":["Production applications should serve minified, cached static files."]},{"l":"Client-Side Library Management with LibMan","p":["LibMan (Library Manager) manages client-side dependencies without npm complexity.","libman.json","Restore libraries during build:"]},{"l":"Bundling and Minification","p":["For custom CSS and JavaScript, use WebOptimizer or BundlerMinifier:","bundleconfig.json"]},{"l":"Static File Caching","p":["Configure aggressive caching for static files. Fingerprinted assets (with hash in filename) can cache for one year.","For versioned files (using asp-append-version tag helper), the cache is automatically invalidated when files change:"]},{"l":"23.2.3 Response Compression","p":["Compression reduces bandwidth and improves response times. htmx partial responses benefit even though they're small."]},{"l":"Why Compression Matters for htmx","p":["Consider a typical htmx interaction:","Search results partial: 3KB uncompressed → 800 bytes compressed (73% reduction)","Edit form partial: 2KB uncompressed → 500 bytes compressed (75% reduction)","Table row: 500 bytes uncompressed → 180 bytes compressed (64% reduction)","Over a session with 50 htmx requests, compression saves significant bandwidth."]},{"l":"Brotli vs Gzip","p":["Brotli typically achieves 15-20% better compression than Gzip and is supported by all modern browsers. Configure both with Brotli as primary:","Enable compression early in the pipeline:"]},{"l":"23.2.4 Database Considerations","p":["Production database configuration differs significantly from development."]},{"l":"Connection String Format for Azure SQL","p":["Azure SQL connection strings include additional parameters:"]},{"l":"Key Vault References","p":["Instead of storing connection strings directly in App Settings, reference Key Vault:"]},{"l":"Production DbContext Configuration","p":["Configure Entity Framework for production workloads:"]},{"l":"Migration Strategy","p":["For production deployments, generate SQL scripts rather than running migrations directly:","The --idempotent flag generates scripts that check if migrations have already been applied, making them safe to run multiple times."]},{"l":"Complete Production Program.cs","p":["Here's the complete Program.cs with all production configurations:"]},{"l":"23.3 Setting Up Azure Resources","p":["With the application prepared, create the Azure infrastructure to host it."]},{"l":"23.3.1 Azure App Service Setup","p":["Azure App Service provides managed hosting for web applications. Choose the right tier based on your needs:","Tier","Use Case","Features","F1 (Free)","Testing only","60 min/day compute, no custom domain","B1 (Basic)","Dev/Test","Custom domain, manual scale","P1v3 (Premium)","Production","Auto-scale, deployment slots, more CPU/RAM","For production htmx applications, P1v3 provides deployment slots for zero-downtime deployments and auto-scaling for traffic spikes."]},{"l":"Azure CLI Setup Script","p":["Create a script to provision all resources:","infrastructure/azure-setup.sh","Make the script executable and run it:"]},{"l":"23.3.2 Azure SQL Database Setup","p":["The setup script creates the database, but you may need additional configuration."]},{"l":"Connection String Format","p":["The complete connection string for Azure SQL:"]},{"l":"Firewall Configuration","p":["The script allows Azure services. To connect from your local machine for migrations:"]},{"l":"Running Migrations","p":["Apply migrations to the production database:","Or use the Azure Portal Query Editor for smaller scripts."]},{"l":"23.3.3 Application Settings and Connection Strings","p":["Azure App Settings override appsettings.json values. Configure them via CLI or Portal."]},{"l":"Setting App Settings via CLI"},{"i":"key-vault-references-1","l":"Key Vault References","p":["For sensitive values, use Key Vault references instead of plain text:"]},{"l":"Slot Settings","p":["Some settings should differ between production and staging slots. Mark them as slot settings:"]},{"l":"23.3.4 Custom Domain and SSL","p":["Add a custom domain to your App Service."]},{"l":"Prerequisites","p":["Own a domain (e.g., chinook.example.com)","Access to DNS management for that domain"]},{"l":"DNS Configuration","p":["Add a CNAME record pointing to your App Service:","Type","Name","Value","CNAME","chinook","chinook-dashboard.azurewebsites.net","Or for apex domains (example.com without subdomain), use an A record with Azure's IP and a TXT record for verification."]},{"l":"Complete Custom Domain Setup Script","p":["infrastructure/setup-domain.sh"]},{"l":"Enforcing HTTPS in Application","p":["Even with Azure's HTTPS-only setting, add middleware for defense in depth:","Configure HSTS properly:","With the Azure resources provisioned and the application configured for production, you're ready to set up automated deployments with GitHub Actions in the next section."]},{"l":"23.4 GitHub Actions CI/CD Pipeline","p":["Automated deployment pipelines eliminate manual deployment steps, reduce errors, and enable rapid iteration. GitHub Actions integrates directly with your repository to build, test, and deploy on every commit."]},{"l":"23.4.1 Understanding GitHub Actions","p":["GitHub Actions uses YAML files in the .github/workflows directory to define automation workflows."]},{"l":"Workflow Structure"},{"l":"Trigger Types","p":["push: Runs when commits are pushed to specified branches","pull_request: Runs when PRs target specified branches","workflow_dispatch: Allows manual triggering from GitHub UI"]},{"l":"GitHub Secrets","p":["Store sensitive values in repository or organization secrets:","Navigate to repository Settings → Secrets and variables → Actions","Add secrets like AZURE_CREDENTIALS, SQL_CONNECTION_STRING","Reference in workflows: ${{ ERROR }}"]},{"l":"Environments for Deployment Approvals","p":["Create environments with protection rules:","Settings → Environments → New environment","Add required reviewers for production deployments","Reference in workflow: environment: production"]},{"l":"23.4.2 Basic Build and Test Workflow","p":["Start with a workflow that builds and tests on every push and pull request.",".github/workflows/build-test.yml"]},{"l":"23.4.3 Deployment Workflow","p":["To deploy to Azure, create a service principal and store its credentials as a GitHub secret."]},{"l":"Creating Azure Service Principal","p":["Save the JSON output as a GitHub secret named AZURE_CREDENTIALS."]},{"l":"Basic Deployment Workflow","p":[".github/workflows/deploy.yml"]},{"l":"23.4.4 Complete CI/CD Pipeline","p":["Combine building, testing, and deployment into a single pipeline with proper stage dependencies and approvals.",".github/workflows/azure-deploy.yml"]},{"l":"23.4.5 Database Migrations in CI/CD","p":["Apply database migrations during deployment using generated SQL scripts."]},{"l":"Migration Step in Build Job","p":["Add migration script generation to the build job:"]},{"l":"Migration Job","p":["Add a separate job to apply migrations before deployment:"]},{"l":"Rollback Considerations","p":["For migration rollbacks, maintain down migration scripts or use point-in-time restore:"]},{"l":"23.5 htmx-Specific Deployment Considerations","p":["htmx applications have unique deployment considerations around caching, error handling, and health checks."]},{"l":"23.5.1 Caching Strategies for Partial Responses","p":["Not all htmx responses should be cached. Consider the content type:","Cache these (static or slowly changing):","Genre dropdown options","Navigation menus","Static lookup lists","Rarely updated reference data","Don't cache these:","User-specific content","Search results","Real-time data (stats, counts)","Form submissions","Anything with user context"]},{"l":"HtmxResponseCachingMiddleware","p":["Middleware/HtmxResponseCachingMiddleware.cs","Configuration in Program.cs:"]},{"l":"23.5.2 CDN Configuration for Static Assets","p":["Serve static assets from Azure CDN for better global performance."]},{"l":"Azure CDN Setup Script","p":["infrastructure/setup-cdn.sh"]},{"l":"Cache Invalidation","p":["Purge CDN cache after deployments:","Add to deployment workflow:"]},{"l":"23.5.3 Health Checks and Monitoring","p":["Health checks enable Azure to detect unhealthy instances and route traffic appropriately."]},{"l":"DatabaseHealthCheck Implementation","p":["Health/DatabaseHealthCheck.cs"]},{"l":"Complete Health Check Registration","p":["Health/HealthCheckExtensions.cs","Registration in Program.cs:"]},{"l":"23.5.4 Error Handling in Production","p":["Production error handling should return appropriate responses for htmx requests versus full page requests."]},{"l":"ProductionExceptionMiddleware","p":["Middleware/ProductionExceptionMiddleware.cs"]},{"l":"Error Partial Views","p":["For more complex error templates, use Razor partial views:","Pages/Shared/_Error404.cshtml","Pages/Shared/_Error500.cshtml","Registration in Program.cs:"]},{"l":"Error Container in Layout","p":["Add an error container to your layout for htmx error responses:","This ensures htmx error responses have a consistent location to display, while maintaining the ability to show inline errors when appropriate."]},{"l":"23.6 Monitoring and Troubleshooting","p":["Production applications need visibility into performance, errors, and usage patterns. Azure Application Insights provides deep monitoring for ASP.NET Core applications."]},{"l":"23.6.1 Application Insights Setup","p":["Install the Application Insights package:","Basic Configuration in Program.cs:"]},{"l":"HtmxTelemetryMiddleware","p":["Track htmx-specific properties for better insights into partial request patterns.","Middleware/HtmxTelemetryMiddleware.cs","Registration in Program.cs:"]},{"l":"23.6.2 Logging Best Practices","p":["Serilog provides structured logging with multiple sinks for different environments.","Complete Serilog Configuration in Program.cs:","appsettings.Production.json Serilog Section:"]},{"l":"23.6.3 Performance Monitoring"},{"l":"Key Metrics for htmx Applications","p":["Track these metrics in Application Insights:","Response Time: Average and P95 for htmx vs full page requests","Throughput: Requests per second by handler","Error Rate: Failed requests percentage","Response Size: Average partial response size"]},{"l":"Custom Application Insights Queries","p":["Query htmx-specific performance data in Log Analytics:"]},{"l":"Azure Monitor Alerts","p":["Create alerts for critical conditions:"]},{"l":"23.6.4 Debugging Production Issues"},{"l":"Azure Kudu Console","p":["Access the Kudu console at https://{app-name}.scm.azurewebsites.net:","Debug Console: Browse files, run commands","Process Explorer: View running processes","Log Stream: Real-time log viewing","Environment: Check environment variables"]},{"l":"Log Streaming via CLI"},{"l":"Common htmx Deployment Issues","p":["Anti-forgery Token Failures:","Solution: Configure data protection key storage (see Section 23.8.2).","Missing Partial Views (Linux case sensitivity):","Solution: Ensure file names match exactly, including case. _artistRow.cshtml won't be found if code references _ArtistRow.","CORS Issues with CDN:","Solution: Configure CORS headers on CDN or serve htmx responses from the origin."]},{"l":"Troubleshooting Checklist","p":["500 errors","Anti-forgery failures","Application Insights dependencies","Application Insights exceptions","Browser console, network tab","Certificate binding","Check","Check for JavaScript errors","Configure Azure Blob Storage for keys","Data protection key storage","File names, case sensitivity","htmx not working","Issue","Match exact casing on Linux","Missing views","Optimize database queries","Review stack trace, fix code","Slow responses","Solution","SSL errors","Verify SSL certificate status"]},{"l":"23.7 Scaling and Performance"},{"l":"23.7.1 Horizontal Scaling","p":["Scale out to multiple instances for high traffic."]},{"l":"Auto-Scale Configuration"},{"l":"Session Affinity for htmx","p":["htmx applications are typically stateless, making session affinity unnecessary. Disable it for better load distribution:","Enable session affinity only if your application stores session state in memory (not recommended for production)."]},{"l":"23.7.2 Vertical Scaling","p":["1","1.75 GB","16 GB","2","32 GB","4","8","8 GB","B1","Best For","Dev/Test","High traffic","Medium production","Memory","P1v3","P2v3","P3v3","Small production","Tier","vCPUs"]},{"l":"Load Testing with k6","p":["loadtest.js:","Run with: k6 run loadtest.js"]},{"l":"23.7.3 Output Caching","p":["ASP.NET Core 7+ includes built-in output caching.","Output Caching Configuration:","Applying Cache Policies to Handlers:","Redis Cache Configuration:"]},{"l":"23.7.4 Database Performance"},{"l":"Azure SQL Recommendations","p":["Enable Query Store for performance analysis","Use Automatic Tuning for index recommendations","Configure Read Scale-Out for read-heavy workloads"]},{"l":"Connection Resiliency","p":["Already configured in Program.cs with EnableRetryOnFailure. For htmx endpoints with many small queries, connection pooling is critical:"]},{"l":"23.8 Security Hardening"},{"l":"23.8.1 Security Headers","p":["htmx requires specific CSP configuration to allow inline event handlers and dynamic content loading.","Middleware/SecurityHeadersMiddleware.cs","Configuration in Program.cs:"]},{"l":"23.8.2 Anti-Forgery in Production","p":["In multi-instance deployments, data protection keys must be shared across instances.","Data Protection Configuration:","Azure Resource Setup:"]},{"l":"23.8.3 Rate Limiting","p":["Protect htmx endpoints from abuse with ASP.NET Core rate limiting.","Applying Rate Limits to Handlers:"]},{"l":"23.9 Cost Optimization"},{"l":"23.9.1 Right-Sizing Resources","p":["Monitor actual usage before choosing tiers:"]},{"l":"23.9.2 Cost-Saving Strategies","p":["~$200","~$30","$0.03/operation","$0.08/GB","$13","$145","$15","$2.30/GB","$30","20-50%","30-40%","40%","50-60%","60-70%","App Service (B1/P1v3)","Application Insights","Auto-shutdown dev/test","Auto-Shutdown for Dev/Test:","Azure Hybrid Benefit","Blob Storage for static","CDN","Commit to production workloads","Component","Dev/Test","Estimated Monthly Costs (East US):","Free tier","Implementation","Key Vault","Long-term stable workloads","Monitor DTU usage","Offload from App Service","Production","Reserved Instances (1yr)","Reserved Instances (3yr)","Right-size SQL tier","Savings","Schedule via Azure Automation","SQL Database (S0/S1)","Strategy","Total (est.)","Use existing Windows licenses","Variable"]},{"l":"23.10 Summary","p":["Deploying htmx applications to Azure requires attention to configuration, security, monitoring, and performance. This chapter covered the complete deployment lifecycle."]},{"l":"Deployment Checklist","p":["/health endpoint","1 year for fingerprinted assets","Alerts configured","Application Insights configured","appsettings.Production.json","Assets","Auto-scale rules set","Azure Blob + Key Vault","Brotli + Gzip","Build pipeline working","Cache headers configured","Category","CDN configured (optional)","CI/CD","Configuration","Connection strings in Key Vault","CPU and memory thresholds","CSP, X-Frame-Options","Data protection keys configured","Deployment pipeline working","Environment-specific settings","Error rate, response time","For cacheable htmx responses","For global distribution","GitHub Actions","Health checks implemented","HSTS enabled","htmx telemetry middleware","htmx.min.js, site.min.css","HTTPS enforced","Item","Logging levels set","Monitoring","Never in source control","Notes","Output caching configured","Performance","Protect htmx endpoints","Rate limiting configured","Response compression enabled","Rollback procedure documented","Security","Security headers set","Slot swap back","Staging → Production","Static files minified","Test pipeline working","Unit + Integration + Browser","Warning for framework, Info for app"]},{"l":"Key Azure Services","p":["Alerts","Application hosting","Application Insights","Azure App Service","Azure Blob Storage","Azure Cache for Redis","Azure CDN","Azure Key Vault","Azure Monitor","Azure SQL Database","Basic C0","Data protection keys","Distributed caching","Included","Monitoring","P1v3 for production","Pay-as-you-go","Purpose","Recommended Tier","Relational data","S1 for production","Secrets management","Service","Standard","Standard LRS","Standard Microsoft","Static asset delivery"]},{"l":"CI/CD Pipeline Flow"},{"l":"htmx-Specific Deployment Tips","p":["Compression: Enable Brotli compression for htmx partial responses. Even small fragments benefit from compression.","Caching: Use output caching selectively. Cache static lookups and navigation, but never user-specific content or form submissions.","Error Handling: Return HTML partials for htmx errors using HX-Retarget. Full error pages break the htmx UX.","Health Checks: Include an htmx-compatible health endpoint that returns HTML for dashboard displays.","Telemetry: Track htmx requests separately in Application Insights. Add HX-Target and handler as custom properties.","Security Headers: Configure CSP to allow htmx's inline event handlers ( unsafe-inline or nonces).","Rate Limiting: Apply stricter limits to search endpoints even with client-side debouncing."]},{"l":"Companion Code Files","p":["With these configurations in place, your htmx application is ready for production traffic on Azure. The automated pipeline ensures consistent deployments, while monitoring and alerting provide visibility into application health. As traffic grows, the scaling configurations handle increased load automatically."]}],[{"l":"Appendix A: htmx Command Reference","p":["This appendix provides a complete reference for htmx attributes, headers, events, and JavaScript API. Use it as a quick lookup while building htmx applications with ASP.NET Core."]},{"l":"A.1 Core Attributes","p":["These attributes initiate HTTP requests when triggered."]},{"l":"hx-get","p":["Issues an HTTP GET request to the specified URL."]},{"l":"hx-post","p":["Issues an HTTP POST request. Form values are sent in the request body."]},{"l":"hx-put","p":["Issues an HTTP PUT request for full resource updates."]},{"l":"hx-patch","p":["Issues an HTTP PATCH request for partial resource updates."]},{"l":"hx-delete","p":["Issues an HTTP DELETE request."]},{"l":"URL Patterns","p":["Pattern","Example","Description","Relative","/Artists","Relative to current origin","With handler","/Artists?handler=List","Razor Pages handler","With parameters","/Artists?handler=Editid=5","Handler with parameters","Absolute","https://api.example.com/data","Full URL (CORS required)"]},{"l":"A.2 Targeting and Swapping"},{"l":"hx-target","p":["Closest ancestor","closest selector","CSS selector","Description","Example","find selector","First descendant","hx-target=#results","hx-target=closest tr","hx-target=find .content","hx-target=next","hx-target=next .item","hx-target=previous","hx-target=previous .item","hx-target=this","next","Next matching sibling","next selector","Next sibling","previous","Previous matching sibling","previous selector","Previous sibling","Specifies the element to update with the response. Accepts CSS selectors.","Target by selector","The triggering element","this","Value"]},{"l":"hx-swap","p":["afterbegin","afterend","beforebegin","beforeend","delete","Delete target element","Description","innerHTML","Insert after target","Insert at end of target","Insert at start of target","Insert before target","No swap (use for side effects)","none","outerHTML","Replace entire element","Replace inner HTML (default)","Specifies how the response content is swapped into the target.","Value"]},{"l":"Swap Modifiers","p":["Add modifiers to hx-swap to control timing and scrolling.","Delay before settle","Delay before swap","Description","Enable view transitions","Example","focus-scroll:bool","hx-swap=innerHTML focus-scroll:true","hx-swap=innerHTML scroll:top","hx-swap=innerHTML settle:100ms","hx-swap=innerHTML show:top","hx-swap=innerHTML swap:500ms","hx-swap=innerHTML transition:true","Modifier","Scroll after swap","Scroll focused element","scroll:target","settle:time","Show element","show:target","swap:time","transition:bool"]},{"l":"hx-swap-oob","p":["afterbegin","afterend","beforebegin","beforeend","delete","Description","Enables out-of-band swaps. The response can update multiple elements.","innerHTML","Insert after","Insert at end","Insert at start","Insert before","No action","none","OOB swap strategies:","outerHTML","Remove element","Replace entire element","Replace inner content","true","Use outerHTML swap","Value"]},{"l":"hx-select","p":["Selects a portion of the response to swap."]},{"l":"hx-select-oob","p":["Selects elements from response for out-of-band swaps."]},{"l":"A.3 Triggering Requests"},{"l":"hx-trigger","p":["Description","every time","Example","hx-trigger=every 5s","hx-trigger=intersect","hx-trigger=load","hx-trigger=revealed","intersect","Intersection observer","load","On element load","Polling interval","revealed","Special Triggers:","Specifies the event that triggers the request.","Standard DOM Events:","Trigger","When scrolled into view"]},{"l":"Trigger Modifiers","p":["all","changed","consume","Debounce","delay:time","Description","Drop if request in flight","Example","Filter by event target","first","from:selector","hx-trigger=click consume","hx-trigger=click from:body","hx-trigger=click once","hx-trigger=click queue:last","hx-trigger=click target:.btn","hx-trigger=keyup changed","hx-trigger=keyup delay:300ms","hx-trigger=scroll throttle:500ms","last","Listen on another element","Modifier","none","once","Only if value changed","Queue all requests","Queue behavior","Queue first, ignore rest","Queue last, ignore previous","Queue Strategies:","queue:strategy","Stop event propagation","Strategy","target:selector","Throttle","throttle:time","Trigger only once"]},{"l":"Multiple Triggers","p":["Separate multiple triggers with commas:"]},{"l":"hx-confirm","p":["Shows a confirmation dialog before the request."]},{"l":"hx-prompt","p":["Shows a prompt dialog and sends the input value.","The prompt value is sent in the HX-Prompt header."]},{"l":"A.4 Request Modifiers"},{"l":"hx-include","p":["Includes additional element values in the request.","Value","Description","CSS selector","Include matching elements","this","Include triggering element","closest selector","Include closest ancestor","find selector","Include descendants","next selector","Include next sibling","previous selector","Include previous sibling"]},{"l":"hx-params","p":["Filters which parameters are submitted.","Value","Description","*","All parameters (default)","none","No parameters","not list","Exclude listed parameters","list","Only listed parameters"]},{"l":"hx-vals","p":["Adds additional values to the request as JSON."]},{"l":"hx-headers","p":["Adds custom HTTP headers to the request.","For anti-forgery tokens in ASP.NET Core:"]},{"l":"hx-sync","p":["abort","Abort current request for new one","Abort current, queue new","Description","drop","Drop new request if one in flight","queue","queue all","Queue all requests","queue first","Queue first, drop rest","queue last","Queue last, drop previous","replace","Strategy","Synchronizes requests to prevent race conditions."]},{"l":"hx-encoding","p":["Sets the encoding type for the request."]},{"l":"A.5 History and Navigation"},{"l":"hx-push-url","p":["Pushes a URL to the browser history."]},{"l":"hx-replace-url","p":["Replaces the current URL in history (no new history entry)."]},{"l":"hx-history","p":["Controls whether the element's innerHTML is saved to history cache."]},{"l":"hx-history-elt","p":["Specifies which element's content to snapshot for history."]},{"l":"A.6 Indicators and Feedback"},{"l":"hx-indicator","p":["Specifies an element to show during the request.","Multiple indicators:"]},{"l":"hx-disabled-elt","p":["Disables elements during the request."]},{"l":"CSS Classes Applied by htmx","p":["Class","Applied When",".htmx-request","Request in progress",".htmx-settling","During settle phase",".htmx-swapping","During swap phase",".htmx-added","Element just added to DOM",".htmx-indicator","Indicator elements"]},{"l":"A.7 Inheritance and Scope"},{"l":"hx-boost","p":["Converts standard anchors and forms to use AJAX."]},{"l":"hx-inherit","p":["Controls which attributes are inherited from ancestors."]},{"l":"hx-disinherit","p":["Prevents attribute inheritance."]},{"l":"hx-preserve","p":["Preserves an element across swaps (useful for video, audio, iframes)."]},{"l":"A.8 Extensions"},{"l":"hx-ext","p":["Enables htmx extensions for an element and its descendants."]},{"l":"Built-in Extensions","p":["Advanced class manipulation","alpine-morph","Auto-remove elements","class-tools","client-side-templates","debug","Debug logging","Enhanced loading indicators","event-header","Extension","head-support","Include triggering event","json-enc","loading-states","morphdom-swap","multi-swap","Multiple response targets","Multiple swap targets","Mustache/Handlebars templates","path-deps","preload","Preload on hover/focus","Process head elements","Purpose","Refresh on path dependencies","remove-me","response-targets","Send request body as JSON","Use Alpine.js morph","Use morphdom for DOM diffing"]},{"l":"hx-ws (WebSocket)","p":["Establishes a WebSocket connection.","Value","Description","connect:url","Connect to WebSocket URL","send","Send form data over WebSocket"]},{"l":"hx-sse (Server-Sent Events)","p":["Connects to a Server-Sent Events endpoint.","Value","Description","connect:url","Connect to SSE endpoint","swap:event","Swap content on event"]},{"l":"A.9 Request Headers","p":["Current page URL","Description","Element ID","Header","Headers automatically sent by htmx with each request:","HX-Boosted","HX-Current-URL","HX-History-Restore-Request","HX-Prompt","HX-Request","HX-Target","HX-Trigger","HX-Trigger-Name","Identifies request as htmx","If request is boosted","If restoring from history","Name attribute","Name of triggering element","String","Target element ID","Triggering element ID","true","URL","User input from hx-prompt","Value"]},{"l":"Detecting htmx Requests in ASP.NET Core"},{"l":"A.10 Response Headers","p":["Headers the server can send to control htmx behavior:"]},{"l":"HX-Location","p":["Triggers client-side redirect without full page reload."]},{"i":"hx-push-url-1","l":"HX-Push-Url","p":["Pushes URL to browser history."]},{"i":"hx-replace-url-1","l":"HX-Replace-Url","p":["Replaces current URL in history."]},{"l":"HX-Redirect","p":["Triggers full page redirect."]},{"l":"HX-Refresh","p":["Triggers full page refresh."]},{"l":"HX-Retarget","p":["Changes the target element."]},{"l":"HX-Reswap","p":["Changes the swap method."]},{"l":"HX-Reselect","p":["Changes which part of response to select."]},{"i":"hx-trigger-1","l":"HX-Trigger","p":["Triggers client-side events after response is received."]},{"l":"HX-Trigger-After-Settle","p":["Triggers events after the settle phase."]},{"l":"HX-Trigger-After-Swap","p":["Triggers events after the swap phase."]},{"l":"Response Header Helper Class"},{"l":"A.11 Events"},{"l":"Request Lifecycle Events","p":["After response received","Before request config","Before request sent","Detail Properties","Event","htmx:afterRequest","htmx:beforeRequest","htmx:beforeSend","htmx:configRequest","htmx:responseError","htmx:sendError","htmx:timeout","htmx:xhr:loadend","htmx:xhr:loadstart","htmx:xhr:progress","HTTP error (4xx, 5xx)","Just before XHR send","Network error","parameters, headers, target, verb","Request timeout","When Fired","xhr","XHR load ended","XHR load started","XHR progress","xhr, loaded, total","xhr, target, requestConfig","xhr, target, requestConfig, successful, failed"]},{"l":"Swap and Settle Events","p":["After content swap","After OOB swap","After settle phase","Before content swap","Before OOB swap","Before settle phase","Detail Properties","Event","fragment, target","htmx:afterSettle","htmx:afterSwap","htmx:beforeSettle","htmx:beforeSwap","htmx:oobAfterSwap","htmx:oobBeforeSwap","When Fired","xhr, target, requestConfig","xhr, target, requestConfig, shouldSwap, serverResponse"]},{"l":"Other Events","p":["After cache miss load","After history push","Before confirmation","Before history update","Before prompt","Detail Properties","Element added to DOM","elt","elt, message, validity","Event","Form validation","History cache miss","History restored","history, navigator","htmx:beforeHistoryUpdate","htmx:confirm","htmx:historyCacheMiss","htmx:historyCacheMissLoad","htmx:historyRestore","htmx:load","htmx:prompt","htmx:pushedIntoHistory","htmx:validation:failed","htmx:validation:validate","path","path, xhr","question, triggeringEvent","Validation failed","When Fired"]},{"l":"Event Handling Examples"},{"l":"A.12 JavaScript API"},{"l":"htmx.ajax()","p":["Programmatically issue an htmx request."]},{"l":"DOM Manipulation"},{"l":"Events"},{"l":"Processing"},{"l":"Utilities"},{"l":"Extensions"},{"l":"A.13 Configuration"},{"l":"Configuration Options","p":["''","[get]","[hx-disable], [data-hx-disable]","0","10","20","Add cache buster param","addedClass","Allow eval (for hx-on)","allowEval","allowScriptTags","blob","Class during request","Class during settle","Class during swap","Class for indicators","Class for new elements","Default","Default settle delay (ms)","Default swap delay (ms)","Default swap method","defaultFocusScroll","defaultSettleDelay","defaultSwapDelay","defaultSwapStyle","Description","disableSelector","Enable history support","Enable view transitions","false","Full refresh on cache miss","full-jitter","getCacheBusterParam","globalViewTransitions","historyCacheSize","historyEnabled","htmx-added","htmx-indicator","htmx-request","htmx-settling","htmx-swapping","Ignore title tag updates","ignoreTitle","Include default indicator CSS","includeIndicatorStyles","indicatorClass","inlineScriptNonce","innerHTML","Methods using URL params","methodsThatUseUrlParams","Nonce for inline scripts","Number of pages to cache","Only allow same-origin","Option","Process script tags","refreshOnHistoryMiss","Request timeout (ms, 0=none)","requestClass","Scroll behavior","Scroll on boosted navigation","Scroll to focused element","scrollBehavior","scrollIntoViewOnBoost","Selector for disabled elements","selfRequestsOnly","Send credentials cross-origin","settlingClass","smooth","swappingClass","timeout","true","Use template for parsing","useTemplateFragments","WebSocket binary type","WebSocket reconnect strategy","withCredentials","wsBinaryType","wsReconnectDelay"]},{"l":"Setting Configuration","p":["Via JavaScript:","Via meta tag:"]},{"l":"Common Configuration Patterns"},{"l":"Quick Reference Card"},{"l":"Most-Used Attributes","p":["Attribute","Example","GET request","hx-get","hx-get=/data","hx-post","hx-post=/save","hx-swap","hx-swap=outerHTML","hx-target","hx-target=#output","hx-trigger","hx-trigger=click","POST request","Purpose","Swap method","Target element","Trigger event"]},{"l":"Common Patterns","p":["Debounced Search:","Inline Edit:","Modal Form:","Delete with Confirmation:"]},{"l":"Key Response Headers","p":["Header","Purpose","Example","HX-Trigger","Trigger events","{showToast: {message: Saved}}","HX-Retarget","Change target","#error-container","HX-Reswap","Change swap","innerHTML","HX-Redirect","Full redirect","/login"]},{"l":"Essential CSS"},{"l":"Key Events","p":["Event","Use Case","htmx:configRequest","Add headers","htmx:afterSwap","Post-swap init","htmx:responseError","Error handling","Custom events","HX-Trigger response","For detailed examples and explanations, refer to the relevant chapters in the main text."]}],[{"l":"Appendix B: htmx Extensions Reference","p":["This appendix provides a complete reference for htmx extensions, including official extensions maintained by the htmx team and guidance on creating custom extensions. Use this as a reference when extending htmx functionality in your ASP.NET Core applications."]},{"l":"B.1 Introduction to Extensions"},{"l":"What Are htmx Extensions?","p":["Extensions add functionality to htmx by hooking into its request/response lifecycle. They can modify requests, transform responses, add new attributes, and change swap behavior."]},{"l":"Loading Extensions","p":["Extensions can be loaded from CDN or installed via npm:"]},{"l":"Enabling Extensions","p":["Use the hx-ext attribute to enable extensions:"]},{"l":"Extension Inheritance","p":["Extensions enabled on a parent element apply to all descendants:"]},{"l":"B.2 Official Extensions"},{"l":"B.2.1 json-enc","p":["Encodes request bodies as JSON instead of form-urlencoded.","Installation:","Activation:","Usage:","Request body becomes:","ASP.NET Core Integration:","Configure JSON options in Program.cs:","Notes:","Sets Content-Type: application/json automatically","Nested objects require proper naming: address.city, address.zip","Arrays use bracket notation: tags[0], tags[1]"]},{"l":"B.2.2 client-side-templates","p":["Activation:","Array Rendering:","ASP.NET Core Endpoint:","Attribute","Engine","Handlebars","handlebars-template","handlebars.js","Installation:","Library","Mustache","mustache-template","mustache.js","Notes:","Nunjucks","nunjucks-template","nunjucks.js","Renders JSON responses using client-side template engines (Mustache, Handlebars, Nunjucks).","Server must return JSON (set Content-Type: application/json)","Supported Engines:","Template ID is referenced without #","Templates must be in template tags","Usage with Handlebars:","Usage with Mustache:"]},{"l":"B.2.3 path-deps","p":["Activation:","All elements depending on that path automatically refresh","Attribute","Attributes:","Automatically refreshes elements when other requests modify their dependencies.","Description","Element declares dependencies via path-deps","Example","How It Works:","Installation:","path-deps","path-deps=/artists","Paths this element depends on","Server-Side Trigger:","Usage:","When any htmx request modifies a dependency path (POST, PUT, PATCH, DELETE)","You can also trigger refreshes via response header:"]},{"l":"B.2.4 class-tools","p":["- After previous completes","100ms- Milliseconds","1s- Seconds","Activation:","add- Add class","Add/remove classes with timing","Animation Pattern:","Attribute","Attributes:","classes","classes Attribute Syntax:","Description","Examples:","Installation:","Operations:","Provides advanced class manipulation with timing support.","remove- Remove class","Timing:","toggle","Toggle classes on events","toggle- Toggle class"]},{"l":"B.2.5 loading-states","p":["Activation:","Add class during request","Attribute","Attributes:","Basic Usage:","Complete Form Example:","data-loading","data-loading-aria-busy","data-loading-class","data-loading-class-remove","data-loading-class-remove=hidden","data-loading-class=opacity-50","data-loading-delay","data-loading-delay=200ms","data-loading-disable","data-loading-path","data-loading-path=/api/save","data-loading-target","data-loading-target=#form","Delay before showing state","Delay to Prevent Flicker:","Description","Disable element during request","Example","Installation:","Only for specific paths","Path-Specific Loading:","Provides enhanced loading state management with fine-grained control.","Remove class during request","Scope loading state","Scoped Loading States:","Set aria-busy during request","Show element during request"]},{"l":"B.2.6 preload","p":["(none)","Activation:","Attribute","Attributes:","Basic Usage:","Configuration via meta tag:","Consider server load with many preload links","Description","Don't use for content that changes frequently","Installation:","mousedown","mouseover","Navigation Pattern:","Notes:","preload","Preload on mousedown","Preload on mouseenter","Preload on mouseover (same as default)","Preloaded content is cached in memory","Preloads content on mouseenter or focus for faster perceived performance.","Use preload=mousedown for actions that happen on click","Values"]},{"l":"B.2.7 remove-me","p":["Automatically removes elements from the DOM after a delay.","Installation:","Activation:","Attributes:","Attribute","Description","Example","remove-me","Remove after delay","remove-me=5s","Usage:","Toast Notification Pattern:","Server response includes self-removing toast:","Toast partial (_Toast.cshtml):","With CSS Animation:"]},{"l":"B.2.8 response-targets","p":["Activation:","ASP.NET Core Integration:","Attribute","Attributes:","Complete Error Handling Example:","Description","Example","hx-target-*","hx-target-4*","hx-target-4*=#client-error","hx-target-404=#not-found","hx-target-5*","hx-target-5*=#server-error","hx-target-error","hx-target-error=#error","Installation:","Specifies different target elements for different HTTP response codes.","Target for 4xx codes","Target for 5xx codes","Target for any error","Target for status code","Usage:","Wildcard Patterns:"]},{"l":"B.2.9 head-support","p":["Activation:","ASP.NET Core Partial with Head:","Configuration:","Default","Description","Duplicate prevention: Elements with same key attributes aren't duplicated","headSupport.mergeMode","How to handle existing elements","Installation:","link- Adds stylesheets","merge","Merges head elements from htmx responses into the document head.","Meta tags merge by name/property","meta- Merges meta tags","Notes:","Option","script- Executes scripts (with care)","Scripts execute once (tracked by src)","Server response can include head elements:","style- Adds inline styles","Supported Elements:","Title always replaces","title- Updates page title","Usage:"]},{"l":"B.2.10 multi-swap","p":["Enables swapping multiple elements from a single response.","Installation:","Activation:","Usage:","Use hx-swap=multi:#id1:swapStyle,#id2:swapStyle:","Server Response:","Alternative: Using hx-swap-oob","For most cases, hx-swap-oob is simpler:"]},{"l":"B.2.11 morphdom-swap","p":["Activation:","Benefits:","Chat interfaces","Content with embedded media","Example - Live Data Table:","Forms with many inputs","Installation:","Live data displays","Preserves focus state in form inputs","Preserves scroll position","Preserves video/audio playback state","Real-time updating content","Smoother transitions for dynamic content","Usage:","Uses morphdom for intelligent DOM diffing during swaps.","When to Use:"]},{"l":"B.2.12 alpine-morph","p":["Uses Alpine.js morph for swaps, preserving Alpine component state.","Installation:","Activation:","Usage:","Notes:","Requires Alpine.js 3.x","Alpine state ( x-data) is preserved during swaps","Useful when combining htmx with Alpine for client-side interactivity"]},{"l":"B.2.13 ws (WebSocket)","p":["Activation:","ASP.NET Core WebSocket Endpoint:","Attribute","Attributes:","Basic Usage:","Connect to WebSocket","Description","Enables WebSocket connections for real-time bidirectional communication.","Example","For more robust real-time features, use SignalR:","Installation:","Send form data","Server sends HTML that gets swapped:","SignalR Integration:","ws-connect","ws-connect=/ws/chat","ws-send"]},{"l":"B.2.14 sse (Server-Sent Events)","p":["Activation:","ASP.NET Core SSE Endpoint:","Attribute","Attributes:","Basic Usage:","Client HTML:","Connect to SSE endpoint","Description","Enables Server-Sent Events for server-to-client push.","Example","Installation:","Multiple Event Types:","sse-connect","sse-connect=/events","sse-swap","sse-swap=message","Swap on event"]},{"l":"B.2.15 debug","p":["Enables debug logging for htmx operations.","Installation:","Activation:","Usage:","Once enabled, all htmx events are logged to the browser console:","Scoped Debugging:","Custom Logger:"]},{"l":"B.2.16 event-header","p":["Includes the triggering event in request headers.","Installation:","Activation:","Headers Added:","Header","Content","Triggering-Event","JSON of the triggering event","Usage:","Server receives header:","ASP.NET Core:"]},{"l":"B.2.17 restored","p":["Adds the restored event and class when content is restored from history.","Installation:","Activation:","Behavior:","Adds .restored class to restored elements","Fires htmx:restored event","Usage:"]},{"l":"B.2.18 disable-element","p":["Disables specified elements during htmx requests.","Installation:","Activation:","Attributes:","Attribute","Description","Example","hx-disable-element","Element(s) to disable","hx-disable-element=#submit-btn","Usage:","Self-Disable:"]},{"l":"B.3 Creating Custom Extensions"},{"l":"Extension API"},{"l":"Example: Request Timing Extension"},{"l":"Example: Request Retry Extension"},{"l":"Example: Offline Support Extension"},{"l":"B.4 Extension Compatibility"},{"l":"Browser Support","p":["All official extensions support:","Chrome 60+","Firefox 55+","Safari 12+","Edge 79+"]},{"l":"htmx Version Requirements","p":["1.0.0","1.7.0","1.8.0","1.9.0","alpine-morph","class-tools","client-side-templates","debug","Extension","head-support","json-enc","loading-states","Minimum htmx Version","morphdom-swap","multi-swap","path-deps","preload","remove-me","response-targets","sse","ws"]},{"l":"Known Conflicts","p":["Extensions","Issue","Solution","morphdom-swap + alpine-morph","Both handle swap","Use only one","json-enc + multipart forms","Encoding conflict","Disable json-enc for file uploads","loading-states + custom indicators","May double-show","Use one approach"]},{"l":"Quick Reference"},{"l":"Most-Used Extensions","p":["(automatic)","data-loading","Error handling","Extension","head-support","hx-target-*","JSON request bodies","json-enc","Key Attribute","Loading indicators","loading-states","preload","Preload on hover","Purpose","response-targets","Update page head"]},{"l":"Extension Loading Template"},{"l":"Error Handling Pattern","p":["For detailed implementation examples, refer to the relevant chapters in the main text."]}],[{"l":"Appendix C: Hyperscript Quick Guide","p":["Hyperscript is a companion scripting language for htmx that provides a readable, English-like syntax for client-side interactions. This appendix covers the essential patterns for using Hyperscript with htmx applications."]},{"l":"C.1 Introduction"},{"l":"What is Hyperscript?","p":["Hyperscript is an expressive scripting language designed to be embedded directly in HTML. It complements htmx by handling client-side interactions that don't require server round-trips."]},{"l":"When to Use Hyperscript","p":["Use Hyperscript For","Use htmx For","Toggle visibility","Fetch server content","Add/remove classes","Form submissions","Keyboard shortcuts","CRUD operations","Close modals","Search/filter","Client-side validation","Load partial views"]},{"l":"Installation"},{"l":"C.2 Core Syntax"},{"l":"The _ Attribute","p":["Hyperscript code goes in the _ attribute (or data-script):"]},{"l":"Basic Structure"},{"l":"Targeting Elements","p":[".class","#id","add .active to me","add .highlight to .item","By class","By ID","Closest ancestor","closest selector","Example","hide my parent","hide previous .header","me","my parent","next selector","Next sibling","Parent","previous selector","Previous sibling","Query","remove .hidden from #modal","remove closest .card","selector/","Self","set input/.value to ''","show next .content","Syntax","Target"]},{"l":"C.3 Common Commands"},{"l":"Classes: add, remove, toggle"},{"l":"Attributes: set, remove"},{"l":"Visibility: show, hide, toggle"},{"l":"Variables: set, get"},{"l":"Timing: wait, settle"},{"l":"Events: trigger, send"},{"l":"JavaScript: call, js"},{"l":"C.4 Event Handling"},{"l":"Basic Events"},{"l":"Event Modifiers","p":["Modifier","Description","Example","once","Fire only once","on click once","debounced","Debounce","on keyup debounced at 300ms","throttled","Throttle","on scroll throttled at 100ms"]},{"l":"Event Filtering"},{"l":"Custom Events"},{"l":"C.5 htmx Integration Patterns"},{"l":"Modal: Close on Backdrop Click"},{"l":"Modal: Close on Escape Key"},{"l":"Form: Reset After htmx Submit"},{"l":"Form: Focus First Input in Modal"},{"l":"Toast: Auto-Dismiss"},{"l":"Loading: Button State"},{"l":"Keyboard: Global Shortcuts"},{"l":"Infinite Scroll: Remove Trigger"},{"l":"Inline Edit: Cancel on Escape"},{"l":"Confirmation: Custom Dialog"},{"l":"C.6 Quick Reference"},{"l":"Syntax Cheat Sheet","p":["Action","add .class to element","Add class","Call function","call functionName()","Conditional","halt","Halt event","Hide element","if condition action","Log","log value","remove .class from element","Remove class","Remove element","set $var to value","set element.prop to value","Set property","Set variable","Show element","Syntax","toggle .class on element","Toggle class","Trigger event","trigger eventName","Wait","wait 1s"]},{"l":"Common Patterns","p":["Auto-dismiss","Close on backdrop","Close on Escape","Code","Debounce","Focus input","init wait 5s then remove me","on click if event.target is me remove me","on click toggle .open on next .content","on htmx:afterRequest reset() me","on keydown[key=='Escape'] remove me","on keyup debounced at 300ms trigger search","on load set $i to first input/ in me then $i.focus()","Pattern","Reset form","Toggle sibling"]},{"l":"htmx Events","p":["Event","Use Case","htmx:beforeRequest","Add loading state","htmx:afterRequest","Remove loading state, reset form","htmx:afterSettle","Initialize components","htmx:afterSwap","Post-swap actions","htmx:confirm","Custom confirmation","For more details, see the Hyperscript documentation."]}],[{"l":"Appendix D: Tools and Resources","p":["This appendix provides a curated collection of tools, libraries, and resources for htmx and ASP.NET Core Razor Pages development."]},{"l":"D.1 Development Tools"},{"l":"Browser Extensions","p":["Available in Chrome Web Store","Browser","Chrome","Chrome/Firefox","Description","Firefox","Format JSON responses for inspection","htmx Debugger","htmx Debugger Chrome Extension:","htmx Devtools","Inspect htmx requests, view headers, debug swaps","Inspect HX-* request/response headers","JSON Viewer","Monitor swap operations","Similar debugging for Firefox","Tool","View all htmx requests in dedicated panel"]},{"l":"Visual Studio Code Extensions","p":["alexcvzz","ASP.NET Core Snippets","C# Dev Kit","C# language support","Description","dz4k","Extension","htmx-tags","Huachao Mao","Hyperscript","Hyperscript syntax highlighting","Live Server","Local development server","Microsoft","otovo-oss","Publisher","rahulsahay19","Razor Pages snippets","Recommended VS Code Settings for htmx:","REST Client","Ritwick Dey","SQLite Viewer","Syntax highlighting and snippets for htmx","Tailwind autocomplete","Tailwind CSS IntelliSense","Tailwind Labs","Test HTTP endpoints directly","View SQLite databases"]},{"l":"Visual Studio Extensions","p":["Extension","Description","Web Essentials","HTML/CSS/JS tooling","Bundler & Minifier","Bundle and minify static assets","Image Optimizer","Optimize images for web","File Nesting","Organize related files","Add New File","Quick file creation with templates"]},{"l":"JetBrains Rider","p":["Feature","Description","Built-in Razor support","Full IntelliSense for .cshtml files","HTTP Client","Test API endpoints","Database Tools","SQLite/SQL Server browsing","NuGet Browser","Package management"]},{"l":"Command Line Tools","p":["Tool","Install","Purpose","dotnet-ef","dotnet tool install -g dotnet-ef","EF Core migrations","dotnet-watch","Built-in","Hot reload during development","libman","dotnet tool install -g Microsoft.Web.LibraryManager.Cli","Client library management","httprepl","dotnet tool install -g Microsoft.dotnet-httprepl","REST API testing"]},{"l":"D.2 NuGet Packages"},{"l":"htmx Integration","p":["Package","Description","Install","Htmx","Tag helpers and response extensions","dotnet add package Htmx","Htmx.TagHelpers","htmx-specific tag helpers","dotnet add package Htmx.TagHelpers","Rizzy","Razor component library with htmx","dotnet add package Rizzy","Htmx Package Usage:"]},{"l":"Entity Framework Core","p":["Package","Purpose","Microsoft.EntityFrameworkCore.Sqlite","SQLite provider","Microsoft.EntityFrameworkCore.SqlServer","SQL Server provider","Microsoft.EntityFrameworkCore.Design","EF tooling","Microsoft.EntityFrameworkCore.Tools","PMC commands"]},{"l":"Testing","p":["AngleSharp","Assertion library","Bogus","Browser automation","Fake data generation","FluentAssertions","HTML parsing for tests","Integration testing","Microsoft.AspNetCore.Mvc.Testing","Microsoft.Playwright","Mocking framework","Moq","Package","Purpose","Snapshot testing for HTTP","Verify.Http"]},{"l":"Complementary Packages","p":["Package","Purpose","Serilog.AspNetCore","Structured logging","FluentValidation","Model validation","AutoMapper","Object mapping","MediatR","Mediator pattern","Polly","Resilience and transient fault handling","HealthChecks.UI","Health check dashboard"]},{"l":"D.3 Client-Side Libraries"},{"l":"htmx and Extensions","p":["Library","CDN URL","htmx","https://unpkg.com/htmx.org@1.9.10","htmx (minified)","https://unpkg.com/htmx.org@1.9.10/dist/htmx.min.js","Hyperscript","https://unpkg.com/hyperscript.org@0.9.12","htmx Extensions:"]},{"l":"CSS Frameworks","p":["Bootstrap","CDN","Classless styling","Classless, dark mode","Component library","Framework","https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css","https://cdn.jsdelivr.net/npm/water.css@2/out/water.css","https://cdn.simplecss.org/simple.min.css","https://unpkg.com/@picocss/pico@latest/css/pico.min.css","Minimal, classless","Notes","Pico CSS","Play CDN or build","Simple.css","Tailwind CSS","Utility-first, pairs excellently with htmx","Water.css"]},{"l":"Icon Libraries","p":["Library","CDN","Heroicons","https://unpkg.com/heroicons@2.0.0/","Lucide","https://unpkg.com/lucide@latest","Feather Icons","https://unpkg.com/feather-icons@4.29.0/dist/feather.min.js","Bootstrap Icons","https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css"]},{"l":"Utility Libraries","p":["Library","Purpose","CDN","Alpine.js","Lightweight reactivity","https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js","morphdom","DOM diffing","https://unpkg.com/morphdom@2.7.0/dist/morphdom-umd.min.js","Sortable.js","Drag and drop","https://unpkg.com/sortablejs@1.15.0/Sortable.min.js"]},{"l":"D.4 Testing Tools"},{"l":"Browser Testing","p":["Browser automation","Chrome automation","Cross-browser automation","Cypress","cypress.io","Description","E2E testing","Playwright","Playwright with .NET:","playwright.dev","pptr.dev","Puppeteer","Selenium","selenium.dev","Tool","Website"]},{"l":"API Testing","p":["Bruno","Built into most systems","CLI","curl","GUI","GUI, Git-friendly","httpie","httpie.io","Insomnia","insomnia.rest","Postman","postman.com","Tool","Type","usebruno.com","Website"]},{"l":"Load Testing","p":["Tool","Description","k6","Modern load testing","NBomber",".NET load testing","Apache JMeter","Java-based load testing","Artillery","Node.js load testing"]},{"l":"D.5 Online Resources"},{"l":"Official Documentation","p":["ASP.NET Core Documentation","Entity Framework Core","htmx Documentation","htmx Examples","htmx Reference","htmx.org/docs","htmx.org/examples","htmx.org/reference","Hyperscript Documentation","hyperscript.org/docs","learn.microsoft.com/aspnet/core","learn.microsoft.com/aspnet/core/razor-pages","learn.microsoft.com/ef/core","Razor Pages Documentation","Resource","URL"]},{"l":"Tutorials and Learning","p":["Resource","Description","URL","htmx Essays","Philosophy and patterns","htmx.org/essays","Hypermedia Systems","Free online book","hypermedia.systems",".NET Documentation","Official tutorials","learn.microsoft.com/dotnet","Microsoft Learn","Interactive modules","learn.microsoft.com"]},{"l":"Community","p":[".NET Reddit","Active community chat","Description","github.com/bigskysoftware/htmx","htmx Discord","htmx GitHub","htmx.org/discord","Q&A","r/dotnet","r/htmx","Reddit community","reddit.com/r/dotnet","reddit.com/r/htmx","Resource","Source and issues","Stack Overflow [htmx]","Stack Overflow [razor-pages]","stackoverflow.com/questions/tagged/htmx","stackoverflow.com/questions/tagged/razor-pages","URL"]},{"l":"Blogs and Articles","p":[".NET and web development",".NET Blog","Andrew Lock","andrewlock.net","ardalis.com","ASP.NET Core architecture","ASP.NET Core deep dives","Author/Source","Blog","Clean architecture","David Fowler","Focus","hanselman.com","htmx patterns and philosophy","htmx team","htmx.org Blog","Microsoft","Official .NET updates","Scott Hanselman","Steve Smith","Twitter/GitHub"]},{"l":"Video Resources","p":[".NET and C#","ASP.NET Core","C# tutorials","Channel/Course","Content","htmx in 100 Seconds","IAmTimCorey","Nick Chapsas","Platform","Pluralsight","Professional courses","Quick introduction","Raw Coding","Subscription","YouTube","YouTube (Fireship)"]},{"l":"D.6 Sample Projects"},{"l":"GitHub Repositories","p":["Repository","Description","bigskysoftware/htmx","htmx source code and examples","bigskysoftware/contact-app","Reference htmx application (Python)","htmx-examples","Community examples collection","dotnet/aspnetcore","ASP.NET Core source","dotnet/eShop","Reference .NET application"]},{"l":"Project Templates","p":["Template","Install","Razor Pages","dotnet new razor","Web App","dotnet new webapp","API","dotnet new webapi","Custom htmx Template (create your own):"]},{"l":"Reference Implementations","p":["Project","Technology","Features","Chinook Dashboard","Razor Pages + htmx","Full CRUD, search, modals","TodoMVC-htmx","Various backends","Classic todo app","RealWorld htmx","htmx spec","Blog platform"]},{"l":"D.7 Books and References"},{"l":"Recommended Reading","p":["Andrew Lock","ASP.NET Core comprehensive","ASP.NET Core in Action","Author","Book","C# in Depth","C# language mastery","Carson Gross et al.","Designing Data-Intensive Applications","EF Core deep dive","Entity Framework Core in Action","htmx philosophy (free online)","Hypermedia Systems","Jon P Smith","Jon Skeet","Martin Kleppmann","System design","Topic"]},{"l":"Specifications and Standards","p":["Specification","URL","HTML Living Standard","html.spec.whatwg.org","HTTP Semantics (RFC 9110)","httpwg.org/specs/rfc9110.html","REST Dissertation","ics.uci.edu/~ fielding/pubs/dissertation/rest_arch_style.htm","HATEOAS","Part of REST architectural style"]},{"l":"D.8 Quick Setup Checklist"},{"l":"New Project Setup"},{"l":"Essential VS Code Extensions"},{"l":"Recommended libman.json"},{"l":"Resource Links Summary"},{"l":"Essential Links","p":[".NET Downloads","ASP.NET Core","dotnet.microsoft.com/download","GitHub","github.com","htmx","htmx.org","Hyperscript","hyperscript.org","learn.microsoft.com/aspnet/core","NuGet","nuget.org","Resource","Stack Overflow","stackoverflow.com","URL"]},{"l":"CDN Quick Reference","p":["All URLs verified as of publication. Check official sources for latest versions."]}],[{"l":"Author Bio","p":["Chris Woodruff Presenting","Chris Woodruff, also known as Woody, is an Architect at Real Times Technologies and brings nearly three decades of industry expertise, having launched his career before the first .COM boom. Renowned for his contributions to software development and architecture, Woody is a regular speaker at international conferences, where he shares his deep knowledge on topics ranging from database development to APIs and web technologies.","A dedicated mentor, Woody thrives on guiding fellow developers and enhancing their skills through his talks, written work, and digital content. He co-hosts the popular “Breakpoint Show” podcast and YouTube channel, which he uses to connect with and educate the tech community. He is also writing a book covering network programming with C# and .NET.","Woody’s interests extend beyond his professional life, adding a personal touch to his character. He is a passionate bourbon enthusiast, often embarking on adventures along the Bourbon Trail in search of unique finds to savor and share with friends. Family time is a cherished part of his life, and he often shares insights from his professional journey on his blog at https://woodruff.dev. To stay updated on his latest projects and adventures, follow him on BlueSky at https://bsky.app/profile/woodruff.dev or Mastodon at https://mastodon.social/@cwoodruff, where he shares his thoughts and experiences, fostering a sense of connection with his audience."]},{"l":"Contact Info","p":["Email - chris@woodruff.dev","WhatsApp - https://wa.me/16167246885","GitHub - https://github.com/cwoodruff"]}],[{"l":"Updates and Corrections","p":["I want to thank every reader who took the time to share their feedback and corrections on my book. Your insights and meticulous attention to detail have helped enhance the work's quality and enriched the reading experience for others. It's through your engagement and thoughtful contributions that the book has evolved and improved. Thank you for your invaluable support and for being an integral part of this journey. Your feedback is genuinely appreciated.","Date","Chapter","Section","Acknowledgement","Notes","17 February 2025","2","Adding htmx to an ASP.NET Core 9 Razor Pages Project","/n/DenverBob","fixed the burron htmx to call the handler"]}]]